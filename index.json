[{"categories":[],"content":"前言 平时在mac上使用终端的时候,访问一些资源报错,提示443错误,例如访问github资源: fatal: unable to access 'https://github.com/ReactiveX/RxSwift.git/': LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 这时我们需要配置终端的代理,以便于正常访问资源.(终端和你网页走的并不是一个网络环境,我理解的是terminal走的网络权限比app的权限更高) ","date":"2024-01-31","objectID":"/terminal-443/:1:0","tags":[],"title":"MAC Terminal 443","uri":"/terminal-443/"},{"categories":[],"content":"配置 ","date":"2024-01-31","objectID":"/terminal-443/:2:0","tags":[],"title":"MAC Terminal 443","uri":"/terminal-443/"},{"categories":[],"content":"1.检查当前环境 终端输入: curl ipinfo.io 返回: { \"ip\": \"xxx.xxx.xxx.xxx\", \"city\": \"Shanghai\", \"region\": \"Shanghai\", \"country\": \"CN\", \"loc\": \"1111,1111\", \"org\": \"AS17621 China Unicom Shanghai network\", \"timezone\": \"Asia/Shanghai\", \"readme\": \"https://ipinfo.io/missingauth\" } ","date":"2024-01-31","objectID":"/terminal-443/:2:1","tags":[],"title":"MAC Terminal 443","uri":"/terminal-443/"},{"categories":[],"content":"2.配置终端代理 根据代理工具查看自己的代理模式和代理地址端口,例如一般为127.0.0.1:1082 export http_proxy=\"http://127.0.0.1:1082\" export https_proxy=\"http://127.0.0.1:1082\" 然后你的软件代理开启全局模式,进行测试: curl ipinfo.io 返回: { \"ip\": \"111.111.111.111\", \"city\": \"Urayasu\", \"region\": \"Tokyo\", \"country\": \"JP\", \"loc\": \"35.6609,139.7717\", \"org\": \"AS199524 G-Core Labs S.A.\", \"postal\": \"135-0061\", \"timezone\": \"Asia/Tokyo\", \"readme\": \"https://ipinfo.io/missingauth\" }% 说明代理成功,可以正常访问资源了. 注意 上面的全局模式只是为了测试,记得改回规则模式,按需代理. ","date":"2024-01-31","objectID":"/terminal-443/:2:2","tags":[],"title":"MAC Terminal 443","uri":"/terminal-443/"},{"categories":[],"content":"Swift数据类型，常量、变量、元组 值类型和引用类型区别，swift中值类型有哪些，引用类型有哪些。和OC相比有什么区别 定义值类型和引用类型 值类型 存储在栈区。 每个值类型变量都有其自己的数据副本，并且对一个变量的操作不会影响另一个变量。值类型包括：struct，enum，tuple。 引用类型 存储在其他位置（堆区），我们在内存中有一个指向该位置的引用。 引用类型的变量可以指向相同类型的数据。 因此，对一个变量进行的操作会影响另一变量所指向的数据。引用类型包括：class，closure，function。 和OC相比有什么区别 OC 中仅有基本数据类型、基础 struct 是值类型。 Swift 中的 struct、enum、tuple 都是值类型。(Array、Dictionary、String 都是struct) Optional可选类型属于引用类型还是值类型？如何实现的? Optional 是枚举类型，它有两个值：None 和 Some(T)。None 表示没有值，Some(T) 表示包含一个 T 类型的值。Optional 是值类型，它的本质是一个枚举类型，它的值是枚举类型的一个 case，所以它是值类型。 Optional 的本质 enum Optional\u003cT\u003e { case none case some(T) } 可选类型解包方式有哪些? 强制解包：在变量名后面加一个感叹号，强制解包，如果可选类型为 nil，强制解包会导致运行时错误。 可选绑定：使用 if let 或者 guard let 语句进行可选绑定，判断可选类型是否包含值，如果包含就把值赋给一个临时的常量或者变量，用于后续语句中使用。 Swift中的元组有什么特点？ 元组是一种数据结构，可以用于存储多个值，可以是不同类型的值。 元组中的值可以是任意类型，不要求是相同类型。 元组中的值可以通过名字或者数字索引来获取。 元组中的值可以是可选类型，也可以是非可选类型。 什么是字面量，字面量协议可以做什么？ **字面量类型(Literal Type)**就是支持通过字面量进行实例初始化的数据类型,比如整型字面量、浮点型字面量、布尔型字面量、字符串字面量、数组字面量、字典字面量、空字面量等。 let a = 10 let b = \"hello\" let c = [1, 2, 3] 以上代码中, 10、“hello”、[1, 2, 3] 就是字面量,用于表达源代码中一个固定值的表示法（notation）。 **字面量协议(Literal Protocol)**就是用来约束字面量类型的协议,Swift 包含一系列ExpressibleByLiteral协议，用于使用匹配的文字初始化自定义类型. 可以利用字面量协议来实现自定义类型的字面量初始化,比如自定义一个结构体,实现字面量协议,就可以使用字面量来初始化该结构体. struct MyStruct: ExpressibleByIntegerLiteral { var value: Int init(integerLiteral value: Int) { self.value = value } } let a: MyStruct = 10 ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:1","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"Swift流程控制 Swift中有哪些流程控制语句？ if 语句：用于基于特定条件选择性执行代码。 guard 语句：用于基于特定条件选择性执行代码，guard 语句总是有一个 else 分句，如果条件不满足则执行 else 分句中的代码。 switch 语句：用于基于多个条件选择性执行代码。 for-in 语句：用于重复执行一系列代码。 while 语句：用于重复执行一系列代码直到条件不满足时停止执行。 repeat-while 语句：用于重复执行一系列代码直到条件不满足时停止执行，和 while 语句的区别是 repeat-while 语句会先执行一次代码块。 for in 在Swift上有什么特点？ for in 循环遍历一个区间范围内的值，比如数字范围、字符串中的字符、数组中的元素等。 for in 循环遍历一个集合中的值，比如数组、字典、集合等。 for in 循环遍历一个序列中的值，比如数组、字典、集合等。 什么是区间类型？跨间隔的区间怎么实现？ **区间类型(Range Type)**就是用来表示一个范围的类型,Swift 中的区间类型包括:闭区间、半开区间、单侧区间、单侧半开区间等. // 闭区间 let closedRange = 0...5 // 半开区间 let halfOpenRange = 0..\u003c5 // 单侧区间 let singleSideRange = 0... // 单侧半开区间 let singleSideHalfOpenRange = ..\u003c5 跨间隔的区间 // 利用stride, stride(from:to:by:) 从起始值到结束值,每次增加固定的值,直到结束值,但不包括结束值 let strideRange = stride(from: 0, to: 10, by: 2) Swift中switch怎么实现贯穿效果？ Swift 中的 switch 语句默认不会贯穿，如果需要贯穿，需要在 case 分支中使用 fallthrough 关键字。 switch与元组结合有什么效果？元祖与where结合呢？ switch 与元组结合 let point = (1, 1) switch point { case (0, 0): print(\"原点\") case (_, 0): print(\"x轴\") case (0, _): print(\"y轴\") case (-2...2, -2...2): print(\"在矩形内\") default: print(\"在矩形外\") } 元组与 where 结合 let point = (1, 1) switch point { case let (x, y) where x == y: print(\"x == y\") case let (x, y) where x == -y: print(\"x == -y\") case let (x, y): print(\"(\\(x), \\(y))\") } switch区间匹配？ let score = 90 switch score { case 0..\u003c60: print(\"不及格\") case 60..\u003c80: print(\"及格\") case 80..\u003c90: print(\"良好\") case 90...100: print(\"优秀\") default: print(\"成绩有误\") } guard..else与do..while有什么区别 guard..else 语句是用来检查条件是否成立，如果不成立就执行 else 分支中的代码，else 分支中的代码必须包含控制转移语句，比如 return、break、continue、throw 等，用来退出当前代码块。 do..while 语句是用来重复执行一系列代码，直到条件不满足时停止执行，do..while 语句会先执行一次代码块，然后判断条件是否成立，如果成立就继续执行，否则就停止执行。 ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:2","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"Swift结构体，类，枚举 枚举是否可以递归？ 枚举是可以递归的，但是不能直接递归，需要在枚举名前面加上 indirect 关键字，表示这个枚举是可以递归的。 枚举值原始值和附加值分别是什么？内存占用怎么计算？ 枚举值原始值 枚举值原始值是指在定义枚举时指定的值，原始值可以是整型、浮点型、字符串型，原始值可以是隐式的，也可以是显式的。 enum Direction: Int { case north = 1 case south = 2 case east = 3 case west = 4 } 枚举值附加值(关联值) 枚举值附加值是指在使用枚举值时指定的值，附加值可以是任意类型，附加值可以是隐式的，也可以是显式的。 enum Score { case point(Int) case grade(Character) } 内存占用 枚举类型变量的内存占用可以解释为1个字节存储成员值(标明是哪个成员)，加上占用字节数最大的关联值的字节数。比如上面原始值类型占用1字节, 关联值类型占用 1 + 16 = 9 字节, 由于内存对齐, 所以占用 24 字节. 结构体自定义初始化方法和自动生成的初始化方法有什么关系？ 没有区别: struct Point { var x: Int var y: Int init(x: Int, y: Int) { self.x = x self.y = y } } struct Point { var x: Int var y: Int } 结构体能否继承？如果改变property，需要怎么做？ 结构体不能继承，结构体是值类型，类是引用类型，结构体是通过复制来传递的，类是通过引用来传递的。 如果需要改变结构体中的属性，需要在方法前面加上 mutating 关键字，表示该方法可以修改结构体中的属性。 类自动生成的初始化方法与结构体自动初始化方法有何区别？ 类的定义和结构体类似，但是编译器并没有为类自动生成可以传入成员值的初始化器。会生成一个无参的初始化器， 类中有初始值的话无参初始化器才会有用。 所有结构体都有一个编译器自动生成的初始化器。 struct 与 class有什么区别？ 结构体是值类型，类是引用类型。 结构体不能继承，类可以继承。 结构体在传递的时候是复制，类在传递的时候是引用。 ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:3","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"Swift函数,闭包 实例方法和类型方法有什么区别？ 实例方法是通过实例调用的方法，类型方法是通过类型调用的方法。 实例方法是可以访问实例属性和类型属性的，类型方法是可以访问类型属性和类型方法的。 技巧 有点类似OC中的实例方法和类方法 什么是闭包？闭包表达式是怎么样的？ 闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的代码块（blocks）以及其他一些编程语言中的 lambdas 函数比较相似。 闭包表达式是一种构建内联闭包的方式，它的语法简洁。在保证不丢失语境的情况下，可以通过引用已经存在的变量或者函数来创建闭包表达式。 // 闭包表达式语法 { (parameters) -\u003e returnType in statements } autoclosure 是什么? 怎么用 autoclosure 是一种自动创建闭包的技术，可以将一句表达式自动封装成一个闭包，然后将这个闭包作为参数传递给函数，这样就省去了写闭包的大量代码，提高了代码的简洁性。 func logIfTrue(_ predicate: () -\u003e Bool) { if predicate() { print(\"True\") } } logIfTrue({ return 2 \u003e 1 }) // 使用 autoclosure func logIfTrue(_ predicate: @autoclosure () -\u003e Bool) { if predicate() { print(\"True\") } } logIfTrue(2 \u003e 1) 什么是逃逸闭包和非逃逸闭包? 逃逸闭包是指在函数返回之后才执行的闭包，逃逸闭包需要在闭包前面加上 @escaping 关键字。 非逃逸闭包是指在函数返回之前就执行的闭包，非逃逸闭包需要在闭包前面加上 @noescape 关键字，Swift 3.0 之后默认就是非逃逸闭包，所以 @noescape 关键字已经被废弃了。 Swift中的函数参数有哪些？ 默认参数：在定义函数时可以给某个参数指定一个默认值，调用函数时如果没有传入该参数，则使用默认值。 可变参数：一个函数最多只能有一个可变参数，可变参数需要在参数类型后面加上 ...，可变参数在函数内部是一个数组。 输入输出参数：函数参数默认是常量，如果想要在函数中修改参数的值，并且想要修改函数外部传入的参数的值，可以将参数定义为输入输出参数，在参数类型前面加上 inout 关键字，输入输出参数不能有默认值，可变参数不能标记为输入输出参数。 ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:4","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"Swift属性,单例 什么是计算属性，什么是存储属性？只读计算属性，延迟存储属性呢？ 计算属性是通过某种方式计算得到的属性，计算属性可以用于类、结构体和枚举中，计算属性不直接存储值，而是提供一个 getter 和一个可选的 setter，来间接获取和设置其他的属性和值。 存储属性是存储在特定类或结构体的实例里的一个常量或变量，存储属性可以是变量存储属性，也可以是常量存储属性，存储属性只能用于类和结构体中。 只读计算属性只有 getter 没有 setter 的计算属性就是只读计算属性，只读计算属性只能用于类、结构体和枚举中。 延迟存储属性是指当第一次被调用的时候才会计算其初始值的属性，延迟存储属性必须声明成变量（使用 var 关键字），因为属性的初始值可能在实例构造完成之后才会得到，而常量属性在构造过程完成之前必须要有初始值，因此不能声明成延迟存储属性。 Swift中的属性观察器有哪些？ willSet：在设置新的值之前调用。 didSet：在新的值被设置之后立即调用。 枚举的原始值属于计算属性还是存储属性？ 计算属性, 因为枚举的原始值是通过计算得到的, 而不是存储的. 实例属性和类型属性有什么区别？ 实例属性是属于某个类、结构体或者枚举类型实例的属性，每次创建一个新的实例，实例都拥有一套属于自己的属性值，实例之间的属性相互独立。 类型属性是属于类型本身的属性，不属于某个实例，每个类型只有一份类型属性，不管创建多少个该类型的实例，这些实例都共享同一个类型属性。 Swift中的单例怎么实现？ class Singleton { static let shared = Singleton() private init() {} } 存储类型属性有什么特点? 在什么时候初始化？多个线程同时访问呢？ 存储类型属性是指在类型的作用域内定义的属性，用 static 关键字修饰的属性就是存储类型属性，存储类型属性可以是变量存储属性，也可以是常量存储属性，存储类型属性只能用于类和结构体中。 存储类型属性的特点 存储类型属性是延迟初始化的，只有在第一次被访问的时候才会初始化。 存储类型属性会被多个线程同时访问的时候，保证只会初始化一次，并且不需要使用 lazy 关键字。 Swift中的类型属性有哪些？ 存储类型属性：用 static 关键字修饰的属性就是存储类型属性，存储类型属性可以是变量存储属性，也可以是常量存储属性，存储类型属性只能用于类和结构体中。 计算类型属性：用 class 关键字修饰的属性就是计算类型属性，计算类型属性只能用于类中。 ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:5","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"Swift泛型 什么是泛型？泛型有什么作用？ 泛型是指在定义函数、结构体、类、枚举、方法时，不需要指定具体的类型，使用的时候再指定具体的类型，泛型可以提高代码的复用性，减少代码的重复编写。(类型参数化) Swift中的泛型有哪些？ 泛型函数：在函数名后面使用尖括号定义泛型类型，泛型类型可以是多个，多个泛型类型之间用逗号分隔。 泛型类型：在类型名后面使用尖括号定义泛型类型，泛型类型可以是多个，多个泛型类型之间用逗号分隔。 泛型下标：在下标后面使用尖括号定义泛型类型，泛型类型可以是多个，多个泛型类型之间用逗号分隔。 什么是关联类型？有什么作用？ 关联类型是指在协议中定义的一个占位符名称，用于指定协议中的某个类型，关联类型通过 associatedtype 关键字来指定。 protocol Container { associatedtype ItemType mutating func append(_ item: ItemType) var count: Int { get } subscript(i: Int) -\u003e ItemType { get } } 关联类型的作用 作为协议的一部分，为某个类型提供一个占位名（或者说别名），其实际类型在协议被实现时才会被指定。 关联类型可以在协议中被指定为类型的占位符，而不是一个具体的类型。 什么是协议类型，协议类型能否作为函数返回值？ 协议类型是指遵循了某个协议的类型，协议类型可以作为函数、方法或构造器中的参数类型或返回值类型，或者作为常量、变量或属性的类型，协议类型可以在类型后面加上 \u0026 符号组合在一起。 protocol Runnable { func run() } class Person: Runnable { func run() { print(\"Person run\") } } class Car: Runnable { func run() { print(\"Car run\") } } func get(_ type: Int) -\u003e Runnable { if type == 0 { return Person() } else { return Car() } } let runnable = get(0) runnable.run() 泛型类型如何约束？ 类型约束：在定义泛型的时候，可以对泛型进行类型约束，只有满足约束的类型才能使用这个泛型。 关联类型约束：在协议中使用关联类型，可以给关联类型添加类型约束，只有满足约束的类型才能实现这个协议。 // 类型约束, T 必须是 Equatable 类型 func swapTwoValues\u003cT: Equatable\u003e(_ a: inout T, _ b: inout T) { if a == b { return } (a, b) = (b, a) } 什么是不透明类型？ 不透明类型是指在函数、方法或者构造器中，返回值的类型可以是协议类型，但是不能是泛型类型，也不能是关联类型，只能是具体的类型。 func get() -\u003e some Runnable { return Person() } ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:6","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"swift 运算符 什么是溢出运算符？ 溢出运算符是为那些会产生溢出的运算提供额外的操作符，Swift 提供了三个溢出运算符：溢出加法运算符（\u0026+）、溢出减法运算符（\u0026-）和溢出乘法运算符（\u0026*）。 什么是运算符重载？ 运算符重载是指在自定义的类、结构体、枚举中，可以对已有的运算符进行重新定义，赋予它们更加特殊的功能，以适应自定义类型的需求。 Equatable协议与==运算符有什么关系？Swift为哪些类型提供默认的 Equatable 实现？ Equatable协议是用来判断两个对象是否相等的协议，Swift 为以下类型提供默认的 Equatable 实现：比较两个整数或浮点数是否相等，比较两个字符串是否相等，比较两个布尔值是否相等，比较两个枚举值是否相等，比较两个元组是否相等。 如何自定义新的运算符？ 自定义运算符可以对已有的运算符进行重新定义，赋予它们更加特殊的功能，以适应自定义类型的需求，自定义运算符可以使用 operator 关键字在全局作用域内进行定义，也可以使用 infix、prefix、postfix 关键字在局部作用域内进行定义。 // 定义全局运算符 prefix operator +++ prefix func +++(value: Int) -\u003e Int { return value + 2 } // 定义局部运算符 struct Point { var x: Int var y: Int } extension Point { static prefix func -(point: Point) -\u003e Point { return Point(x: -point.x, y: -point.y) } } let point = Point(x: 10, y: 20) let newPoint = -point print(newPoint) ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:7","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"swift 初始化器 指定初始化器和便捷初始化器有什么区别 指定初始化器是类中最主要的初始化器，一个类至少有一个指定初始化器，指定初始化器必须调用其直接父类的指定初始化器。 便捷初始化器是类中比较次要的初始化器，可以定义便捷初始化器来调用同一个类中的指定初始化器，并为其参数提供默认值，也可以定义便捷初始化器来调用同一个类中的便捷初始化器。 重写父类指定初始化器和便捷初始化器有何区别？ class Person { var age: Int init(age: Int) { self.age = age } convenience init() { self.init(age: 0) } } class Student: Person { var score: Int init(age: Int, score: Int) { self.score = score super.init(age: age) } override convenience init(age: Int) { self.init(age: age, score: 0) } } 重写父类指定初始化器：子类可以通过重写父类的指定初始化器来实现父类的初始化器，子类的指定初始化器必须调用父类的指定初始化器。 重写父类便捷初始化器：子类可以通过重写父类的便捷初始化器来实现父类的初始化器，子类的便捷初始化器必须调用同一个类中的指定初始化器或者便捷初始化器。 初始化器中赋值会触发属性观察器么？ 初始化器中赋值不会触发属性观察器，属性观察器只有在给属性赋值的时候才会触发。 什么是反初始化器？ deinit ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:8","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"swift 内存管理 swift 中内存管理方案？ARC引用类型有几种？ ARC：ARC 是 Swift 中的内存管理方案，ARC 是 Automatic Reference Counting 的缩写，表示自动引用计数，ARC 会在类的实例不再被使用时自动释放其占用的内存。 引用类型：Swift 中的引用类型有 class、closure、function。 Swift闭包循环引用如何产生，怎么解决？ 闭包循环引用是指闭包和闭包捕获的值相互引用，造成内存泄漏，解决闭包循环引用可以使用闭包捕获列表，闭包捕获列表会在闭包和捕获的值之间创建一个弱引用或无主引用，从而打破循环引用。 weak 弱引用 unowned 无主引用 能否在定义闭包属性的同时引用self 可以, 但是需要在闭包前面加上 lazy 关键字, 因为闭包在初始化器之前被调用, 而此时 self 还没有初始化完成. 如果lazy属性是闭包调用的结果，是否需要考虑循环引用问题？ 不需要, 因为闭包调用完毕后, 闭包会被释放, 闭包中的 self 也会被释放. 逃逸闭包能否捕获inout参数？ 不能, 因为逃逸闭包的调用时机不确定, 有可能在函数返回之后才调用, 这时候 inout 参数已经被释放了. Swift中指针类型有哪几种？ UnsafePointer：指向内存中某个类型的指针，不允许修改内存中的值。 UnsafeMutablePointer：指向内存中某个类型的指针，允许修改内存中的值。 UnsafeRawPointer：指向内存中某个类型的指针，不允许修改内存中的值，不允许进行内存的访问。 UnsafeMutableRawPointer：指向内存中某个类型的指针，允许修改内存中的值，不允许进行内存的访问。 ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:9","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"Swift 扩展 Swift中扩展与OC中分类有什么区别？能添加什么，不能添加什么？ 类别只能扩充方法，不能扩展属性和成员变量（如果包含成员变量会直接报错）； 如果分类中声明了一个属性，那么分类只会生成这个属性的set、get方法声明，也就是不会有实现 分类中的方法会覆盖原来类中的方法，但是不会覆盖原来类中的属性 扩展只能扩充计算属性，不能扩展存储属性，也不能扩展成员变量 扩展有时候也称为匿名分类，因为扩展是没有名字的 扩展不能添加指定构造器，但是可以添加便利构造器 扩展不能添加属性观察器 扩展不能添加父类 扩展也不能添加反初始化器 扩展可以给协议提供默认实现，也间接实现可选协议的效果 ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:10","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"Swift继承 如何限制不能被重写，或者不能被继承？ final：可以修饰类、属性、方法、下标、协议，表示不允许对类、属性、方法、下标、协议进行继承、重写或者修改。 是否可以重写存储属性？ 不可以, 因为存储属性是直接存储在实例中的, 重写的话会破坏继承链. 但是可以重写计算属性. let修饰的属性能否重写？ 不能, 因为 let 修饰的属性是常量, 不能被修改. static与class修饰的属性的异同? 不同点 class 修饰的计算属性可以被重写，static 修饰的不能被重写。 static 可以修饰存储属性，static 修饰的存储属性称为静态变量(常量)。 static 修饰的静态方法不能被重写，class 修饰的类方法可以被重写。 class 修饰的类方法被重写时，可以使用static 让方法变为静态方法。 class 修饰的计算属性被重写时，可以使用static 让其变为静态属性，但它的子类就不能被重写了。 相同点 可以修饰方法，static 修饰的方法叫做静态方法，class 修饰的叫做类方法。 都可以修饰计算属性。 ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:11","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"Swift模式匹配 Swift中什么是模式匹配？有哪些? 模式匹配是指检查一个值是否满足某种模式的过程，Swift 中的模式匹配可以用在 switch 语句中，也可以用在 if、guard、for-in、while、do-while 语句中。 通配符模式：用下划线（_）表示，可以匹配任意类型的值，但是并不将匹配的值绑定到临时的常量或变量。 标识符模式：用于匹配任意值，如果匹配成功，会将匹配的值赋值给指定的标识符。 值绑定模式：用于将匹配的值绑定到一个临时的常量或变量，以便在模式的执行体中使用。 元组模式：用于匹配元组，如果匹配成功，会将元组中的值分解成单独的常量或变量，以便在模式的执行体中使用。 可选模式：用于匹配可选值，如果匹配成功，会将可选值中的值分解成单独的常量或变量，以便在模式的执行体中使用。 枚举模式：用于匹配枚举值，如果匹配成功，会将枚举值分解成单独的常量或变量，以便在模式的执行体中使用。 表达式模式：用于匹配表达式，如果匹配成功，会将表达式的值分解成单独的常量或变量，以便在模式的执行体中使用。 类型转换模式：用于匹配指定类型的值，如果匹配成功，会将值转换成指定类型，并赋值给指定的常量或变量。 通配符匹配中_和_?有什么区别？ _：表示匹配任意类型的值。 _?：非空任意值。 枚举Case模式中if case语句是什么？ if case 语句是用来判断某个可选类型是否有值，如果有值，可以将值绑定到一个临时的常量或变量，以便在语句体中使用。 enum Score { case point(Int) case grade(Character) } let score = Score.point(100) if case let Score.point(i) = score { print(i) } ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:12","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":[],"content":"Swift 协议 Swift中什么是协议？协议能添加什么？ 协议规定了用来实现某一特定功能所必需的方法和属性。 协议中可以定义方法、属性、下标、初始化器的声明，协议中的方法、属性、下标、初始化器不需要写访问级别修饰符，因为协议中声明的都是抽象的内容，具体实现的时候才需要指定访问级别修饰符。 协议中可以定义类型方法和类型属性，用 static 关键字来修饰。 协议中可以定义 mutating 方法，用 mutating 关键字来修饰。 协议中可以定义初始化器，但是不能定义析构器。 协议中可以定义下标，但是不能定义存储属性和计算属性。 协议中可以定义关联类型，关联类型通过 associatedtype 关键字来指定。 swift协议中定义的内容是否必须全部都实现？如果想要实现可选协议呢？ 一般来讲是需要全部实现, 如果向要可选,可以使用extension 来实现. (或者利用OC的@optional,但是需要加上 @objc 关键字) protocol Runnable { func run() func run1() } extension Runnable { func run1() { print(\"run1\") } } ","date":"2023-12-25","objectID":"/ios-interview-swift/:0:13","tags":[],"title":"iOS面试题-Swift","uri":"/ios-interview-swift/"},{"categories":["工具"],"content":"vscode snippets对于MARKDOWN不生效 默认情况下，vscode 没有支持 markdown 的 snippets。 ","date":"2023-12-09","objectID":"/vscode-snippets/:1:0","tags":["vscode","markdown"],"title":"vscode snippets对于markdown不生效","uri":"/vscode-snippets/"},{"categories":["工具"],"content":"解决 打开 vscode 的 settings.json 文件，添加如下配置： \"[markdown]\": { \"editor.unicodeHighlight.ambiguousCharacters\": false, \"editor.unicodeHighlight.invisibleCharacters\": false, \"diffEditor.ignoreTrimWhitespace\": false, \"editor.wordWrap\": \"on\", \"editor.quickSuggestions\": { \"comments\": \"on\", \"strings\": \"on\", \"other\": \"on\" } } ","date":"2023-12-09","objectID":"/vscode-snippets/:2:0","tags":["vscode","markdown"],"title":"vscode snippets对于markdown不生效","uri":"/vscode-snippets/"},{"categories":["移动端"],"content":"前言 整理一些ios面试题，方便复习 ","date":"2023-11-01","objectID":"/ios-interview/:1:0","tags":["ios"],"title":"iOS面试题","uri":"/ios-interview/"},{"categories":["移动端"],"content":"OC ","date":"2023-11-01","objectID":"/ios-interview/:2:0","tags":["ios"],"title":"iOS面试题","uri":"/ios-interview/"},{"categories":["移动端"],"content":"OC对象 什么是内存对齐，内存对齐规则是什么样的？ 内存对齐说白了就是为了提高CPU寻址操作性能的一种规则。就像砖块一样,如果砖块有大有小毫无规律的摆放在一起,那么我们想要找到某一块砖块就会很麻烦,但是如果我们把砖块按照一定的规则整齐摆放,那么我们就可以很快的找到某一块砖块了,这就是内存对齐的原理。 内存对齐规则: 1.结构体的成员相对于结构体首地址的偏移量必须是成员大小的倍数，即后续数据成员的起始位置是该数据成员所占内存大小的整数倍； 2.结构体的大小必须是最大成员大小的倍数 各数据类型所占字节大小如下(64位): 数据类型 大小 char 1 short 2 int 4 long 8 long long 8 float 4 double 8 long double 16 指针(void *) 8 OC 对象的结构体中的数据成员的顺序： 首先是父类对象的结构体 然后是自己本身的数据成员,按照所占内存大小从小到大排列 所以OC对象对应的结构体第一个数据成员始终是isa指针。 相关函数: class_getInstanceSize表示成员变量的所占的内存大小 malloc_size表示实际分配的内存大小 sizeof表示变量或者类型的大小，传入结构体，返回的则是结构的大小，传入指针（这里的指针表示C指针，OC的引用）即传入值，则返回传入值的类型大小 分析一个结构体例子: struct Struct1 { double a; // 占用8字节,从偏移量0开始 char b; // 运用规则1,占用1字节,从偏移量8开始 int c; // 运用规则1,占用4字节,因为当前偏移量9不是4的倍数,所以从偏移量12开始 short d; // 运用规则1,占用2字节,因为当前偏移量16是2的倍数,所以从偏移量16开始 struct Struct2 { // 规则2,结构体的大小必须是最大成员大小的倍数,当前偏移量18不是8的倍数,所以从偏移量24开始 double a; // 运用规则1,占用8字节,从偏移量24开始 int b; // 运用规则1,占用4字节,因为当前偏移量32是4的倍数,所以从偏移量32开始 char c; // 运用规则1,占用1字节,因为整体系数是8,33补齐到8的,则整体占用40字节 }str2; }str1; sizeof(str1)的结果是40 instance对象，class对象，mate-class对象的区别与关系? 在内存中各自存储哪些信息 instance对象 instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象 内存中存储着:isa指针，其他成员变量 class对象 class对象是类对象，每个类在内存中都有唯一的一个class对象，class对象是一个结构体，里面存储着类的一些信息，比如类的成员变量、属性、方法、遵守的协议等等 meta-class对象 meta-class对象是元类对象，每个类在内存中都有唯一的一个meta-class对象，meta-class对象也是一个结构体，里面存储着类方法、遵守的协议等等 关系 instance对象的isa指针指向class对象，class对象的isa指针指向meta-class对象，meta-class对象的isa指针指向基类的meta-class对象，基类的meta-class对象的isa指针指向自己，形成一个闭环 怎么判断一个Class对象是否为meta-class？ 通过class_isMetaClass函数判断 isKindOfClass 和 isMemberOfClass的区别 isKindOfClass: 判断是否为当前类或者子类的实例 isMemberOfClass: 判断是否为当前类的实例 【图解isKindOfClass和isMemberOfClass方法】 new与alloc/init的区别？ new: new方法是一个类方法，内部会调用alloc方法和init方法，返回一个实例对象 alloc: alloc方法是一个类方法，内部会开辟一块内存空间，返回一个实例对象 init: init方法是一个实例方法，初始化对象，返回一个实例对象 ","date":"2023-11-01","objectID":"/ios-interview/:2:1","tags":["ios"],"title":"iOS面试题","uri":"/ios-interview/"},{"categories":["移动端"],"content":"OC分类 Category底层结构是怎么样的❓ 引用MJ课件中的一张图 Category clang编译文件得到的: struct _category_t { const char *name; struct _class_t *cls; const struct _method_list_t *instance_methods; // Instance对象方法 const struct _method_list_t *class_methods;// 类方法 const struct _protocol_list_t *protocols;// 协议 const struct _prop_list_t *properties; // 属性 }; 编译时: 每一个Category都会生成一个category_t结构体对象，记录着所有的属性、方法和协议信息 将所有的category_t对象放在一个category_list数组中 运行时: 通过Runtime加载某个类的所有Category数据 把所有Category的对象方法、类方法、属性、协议数据，分别合并到一个二维数组中，并且后面参与编译的Category数据，会在数组的前面 将合并后的Category数据（方法、属性、协议），插入到类原来数据的前面 调用顺序: 后编译的Category -\u003e 先编译的Category -\u003e 原类(本质原因是它们在方法栈中的顺序不同,优先级不同) -\u003e 父类 详解参考: 【Category底层结构】 【Objective-C之Category的底层实现原理】 为什么说不能添加属性？ 在iOS中，分类（Category）是一种将方法添加到现有类中的方式，而不是通过子类化来创建新的类。在Objective-C中，分类可以为现有的类添加方法，但不能添加实例变量或属性。 这是因为Objective-C的运行时系统在类加载时分配内存空间，并将实例变量和属性的偏移量计算到类的内部数据结构中。由于分类是在编译时定义的，它们不能更改类的内部数据结构，因此不能直接添加实例变量或属性。 不过，在Objective-C 2.0中，可以使用关联对象（Associated Object）来向分类中添加属性。关联对象允许将属性与现有的对象相关联，而不是将其存储在对象本身中。这样可以在运行时动态地向现有对象添加属性。关联对象是通过Objective-C运行时API实现的。 其实本质原因是底层结构中没有ivars成员列表，所以不能添加属性 对比原类结构: 原类结构 Category load、initialize的区别 +load 当类或者分类被添加到Objective-C runtime时，就会调用+load方法。每个类、分类的+load方法在程序运行过程中只会调用一次，无论这个类有没有被用到，即使这个类没有被用到，也会调用这个类的+load方法，而且是在main函数之前调用。 +load调用顺序: 先调用类的+load方法，再调用分类的+load方法 调用顺序是根据编译顺序决定的，先编译，先调用 调用子类的+load方法之前，会先调用父类的+load方法 +initialize +initialize方法会在类第一次接收到消息时调用 +initialize调用顺序: 先调用父类的+initialize方法，再调用子类的+initialize方法 +initialize和+load的很大区别是，+initialize是通过objc_msgSend进行调用的，Load是根据方法地址直接调用的，并不是经过objc_msgSend函数调用，所以有以下特点: 如果子类没有实现+initialize方法，会调用父类的+initialize方法，所以父类的+initialize方法可能会被调用多次 如果分类实现了+initialize方法，就会覆盖类本身的+initialize方法，因为分类的方法优先级高于类本身的方法 覆盖说明 参考上面 Category底层结构是怎么样的中的调用顺序,可知分类的方法优先级高于类本身的方法,方法查找顺序是先查找分类,再查找类本身,一旦找到就结束查找,所以这里说分类的+initialize方法会覆盖类本身的方法 分类(类别)和扩展的区别是什么？ 类别中原则上只能增加方法（能添加属性的的原因只是通过runtime解决无setter/getter的问题而已）。 类扩展不仅可以增加方法，还可以增加实例变量（或者属性），只是该实例变量默认是@private类型的（用范围只能在自身类，而不是子类或其他地方）。 类扩展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中。 类扩展不能像类别那样拥有独立的实现部分（@implementation部分），也就是说，类扩展所声明的方法必须依托对应类的实现部分来实现。 定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。类扩展是在 .m 文件中声明私有方法的非常好的方式。 ","date":"2023-11-01","objectID":"/ios-interview/:2:2","tags":["ios"],"title":"iOS面试题","uri":"/ios-interview/"},{"categories":["移动端"],"content":"block block是什么? block本质上是一个对象(它内部也有个isa指针)，封装了函数调用以及函数调用环境的OC对象。 block的底层结构如下图所示: block block的类型有哪些? 全局Block: 没有访问auto变量的block，编译器会将这种block优化为全局block，存储在程序的数据区域 栈Block: 访问了auto变量的block，编译器会将这种block优化为栈block，存储在栈中 堆Block: 对栈block调用了copy方法，编译器会将这种block优化为堆block，存储在堆中 block的类型 说明 auto变量是指在函数内部定义的变量(局部变量)，不包括static修饰的变量 【Wiki】 block变量捕获有哪些情况？ auto变量的捕获 变量的捕获 ARC环境下，哪些情况编译器会根据情况自动将栈上的block复制到堆上 block作为函数返回值时 return ^{ return 10; }; block作为Cocoa API中方法名含有usingBlock的方法参数时 @[@1,@2,@3].enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {} block作为GCD API的方法参数时 dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"hello world\"); }); block作为OC方法中的强引用的循环引用时 self.block = ^{ NSLog(@\"hello world\"); }; block内部为什么不能修改局部变量，__block为什么能？ block内部为什么不能修改局部变量: block内部不能修改局部变量，是因为block内部会对局部变量进行copy操作，而copy操作是将局部变量的值拷贝到block结构体中，而不是引用，所以block内部修改的是block结构体中的值，而不是局部变量的值 __block为什么能: __block修饰的变量是一个结构体，结构体中有一个isa指针，指向一个对象，这个对象中有一个变量，这个变量的值就是局部变量的值，所以block内部修改的是这个对象中的变量，而不是局部变量的值 struct __Block_byref_i_0 { void *__isa; __Block_byref_i_0 *__forwarding; int __flags; int __size; int val; //变量名 }; ","date":"2023-11-01","objectID":"/ios-interview/:2:3","tags":["ios"],"title":"iOS面试题","uri":"/ios-interview/"},{"categories":["移动端"],"content":"内存管理 OC中内存分区？ OC中内存分区从高到低: 1. 栈区(stack) 栈是用于存放本地变量，内部临时变量以及有关上下文的内存区域。程序在调用函数时，操作系统会自动通过压栈和弹栈完成保存函数现场等操作，不需要程序员手动干预。 栈是一块连续的内存区域，栈顶的地址和栈的最大容量是系统预先规定好的。能从栈获得的空间较小。如果申请的空间超过栈的剩余空间时，例如递归深度过深，将提示stackoverflow。 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。 2. 堆区(heap) 堆是用于存放除了栈里的东西之外所有其他东西的内存区域，当使用malloc和free时就是在操作堆中的内存。对于堆来说，释放工作由程序员控制，容易产生memory leak。 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，永远都不可能有一个内存块从栈中间弹出。 堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。 计算机底层并没有对堆的支持，堆则是C/C++函数库提供的，同时由于上面提到的碎片问题，都会导致堆的效率比栈要低。 3. 全局区(静态区) 全局区又分为.bss段和.data段，内存地址一般由0x1开头： .bss段：block started by symbol,未初始化的全局变量和静态变量，程序执行前会自动清0 .data段：data,已初始化的全局变量和静态变量 4. 常量区(.rodata) .rodata: read only data(只读),常量字符串就是放在这里的，程序执行前会自动加载到内存中，程序结束后由系统释放 常量区的内存在编译时就已经确定，主要存放已经使用过的，且没有指向的字符串常量(因为字符串常量可能在程序中多次被使用，所以在程序运行之前就会提前分配内存)。常量区的常量在程序结束后，由系统释放 5. 代码区(.text) 存储程序代码，在编译时加载到内存中，代码会被编译成二进制的形式进行存储 OC中的内存管理机制? 在 Objective-C 中，对象通常是使用 alloc 方法在堆上创建的。 [NSObject alloc] 方法会在对堆上分配一块内存，按照NSObject的内部结构填充这块儿内存区域。 一旦对象创建完成，就不可能再移动它了。因为很可能有很多指针都指向这个对象，这些指针并没有被追踪。因此没有办法在移动对象的位置之后更新全部的这些指针。 MRC和ARC Objective-C中提供了两种内存管理机制：MRC（MannulReference Counting）和 ARC(Automatic Reference Counting)，分别提供对内存的手动和自动管理，来满足不同的需求。现在苹果推荐使用 ARC 来进行内存管理。 MRC 对象操作 OC中对应的方法 对应的 retainCount 变化 创建对象 alloc/new/copy/mutableCopy +1 对象引用 retain +1 对象释放 release -1 对象释放后置空指针 dealloc 0 四个法则: 自己生成的对象，自己持有 非自己生成的对象，自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放 如下是四个黄金法则对应的代码示例： // 自己生成的对象，自己持有 NSString *string1 = [[NSString alloc] init]; // 非自己生成的对象，自己也能持有 NSString *string2 = [NSString stringWithFormat:@\"hello\"]; // 不再需要自己持有的对象时释放 [string1 release]; // 非自己持有的对象无法释放 [string2 release]; // crash autorelease 使得对象在超出生命周期后能正确的被释放(通过调用release方法)。在调用 release 后，对象会被立即释放，而调用 autorelease 后，对象不会被立即释放，而是注册到 autoreleasepool 中，经过一段时间后 pool结束，此时调用release方法，对象被释放。 在MRC的内存管理模式下，与对变量的管理相关的方法有：retain, release 和 autorelease。retain 和 release 方法操作的是引用记数，当引用记数为零时，便自动释放内存。并且可以用 NSAutoreleasePool 对象，对加入自动释放池（autorelease 调用）的变量进行管理，当 drain 时回收内存。 ARC ARC 是编译器特性，编译器会在编译时自动在合适的地方插入 retain/release/autorelease 代码，以此来管理内存。ARC 会在编译时根据代码的上下文来判断应该插入哪些内存管理代码，这样就不需要程序员手动管理内存了。 变量标识符 标识符 说明 __strong 默认的标识符，表示强引用 __weak 表示弱引用，不会改变引用计数，当对象被释放后，会自动将指针置为nil __unsafe_unretained 表示弱引用，不会改变引用计数，当对象被释放后，不会自动将指针置为nil __autoreleasing 表示自动释放，一般用于传递参数，表示传递的参数是一个autorelease对象,在函数返回时会被自动释放掉 属性标识符 标识符 说明 strong 表明属性定义一个拥有者关系。当给属性设定一个新值的时候，首先这个值进行 retain ，旧值进行 release ，然后进行赋值操作 weak 表明属性定义了一个非拥有者关系。当给属性设定一个新值的时候，这个值不会进行 retain，旧值也不会进行 release， 而是进行类似 assign 的操作。不过当属性指向的对象被销毁时，该属性会被置为nil。 copy 类似于 strong，不过在赋值时进行 copy 操作而不是 retain 操作。通常在需要保留某个不可变对象（NSString最常见），并且防止它被意外改变时使用。 assign 表明 setter 仅仅是一个简单的赋值操作，通常用于基本的数值类型，例如CGFloat和NSInteger。 unsafe_unretained 语义和 assign 类似，不过是用于对象类型的，表示一个非拥有(unretained)的，同时也不会在对象被销毁时置为nil的(unsafe)关系。 讲下自动释放池 Autorelease Pool 提供了一种可以允许你向一个对象延迟发送release消息的机制,当你想要释放一个对象时,只需要将这个对象放入到Autorelease Pool中,系统会在Autorelease Pool被销毁时,向池中所有的对象发送release消息。 所谓的延迟发送release消息指的是，当我们把一个对象标记为autorelease时: NSString* str = [[[NSString alloc] initWithString:@\"hello\"] autorelease]; 这个对象的 retainCount 会 +1,但是并不会立即release,而是当这段语句所处的autoreleasepool被销毁时,所有标记了autorelease的对象才会被release。 Autorelease Pool的实现原理 Autorelease Pool的本质上是一个双向链表。双向链表中每一页为一个AutoreleasePoolPage，AutoreleasePoolPage最大为4096B，每当AutoreleasePoolPage中因为存储变量总大小超过4096B之后，就会分配一个新的AutoreleasePoolPage objc_autoreleasePoolPush() 每个 AutoreleasePoolPage 对象会开启 4096字节（4kb）内存，除了自身实例变量所占空间，剩下的空间全部拿来存储 autorelease 对象的地址。 每当进行一次 objc_autoreleasePoolPush 调用时，runtime 都会向当前的 AutoreleasePoolPage 中添加一个哨兵对象，值为 nil，添加完哨兵对象后，将 next 指针指向下一个添加 Autorelease 对象的位置。当当前 AutoreleasePoolPage 满了，开启一个新的 AutoreleasePoolPage，并更新 child 和 parent 指针，以组成双向链表。 objc_autoreleasePoolPop() objc_autoreleasePoolPush 会有个返回值，这个返回值正是前面提到的哨兵对象。 objc_autoreleasePoolPop() 调用时会把哨兵对象作为入参。之后根据传入的哨兵对象地址找到哨兵对象对应的 AutoreleaseP","date":"2023-11-01","objectID":"/ios-interview/:2:4","tags":["ios"],"title":"iOS面试题","uri":"/ios-interview/"},{"categories":["移动端"],"content":"runtime 什么是Runtime，有什么作用？常用在什么地方 定义：RunTime实际上是一个库，这个库使我们可以在程序运行时动态的创建对象、检查对象，修改类和对象的方法。他的作用其实就是在程序运行时做一些事情。 方法交换 Person *person = [[Person alloc] init]; Method m1 = class_getInstanceMethod(person.class, @selector(eat)); Method m2 = class_getInstanceMethod(person.class, @selector(run)); method_exchangeImplementations(m1, m2); 特别是交换系统自带的方法，可以在不改变原有代码的基础上，给系统自带的方法添加一些功能，比如给ViewController添加一个swiviewDidLoad:方法，替换系统方法并且不影响原系统方法 #import \u003cobjc/runtime.h\u003e @interface ViewController () @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; NSLog(@\"原方法\"); } @end @implementation UIViewController (SwizzleViewDidLoad) + (void)load { static dispatch_once_t onceToken; dispatch_once(\u0026onceToken, ^{ Class class = [self class]; SEL originalSelector = @selector(viewDidLoad); SEL swizzledSelector = @selector(swiviewDidLoad); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); if (didAddMethod) { class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } }); } - (void)swiviewDidLoad { NSLog(@\"替换的方法,%@\",[self class]); [self swiviewDidLoad]; } @end 动态添加方法 - (void)eat { NSLog(@\"eat\"); } // 这里利用动态方法解析，给Person类添加一个run方法 + (BOOL)resolveInstanceMethod:(SEL)sel { if (sel == @selector(eat)) { class_addMethod(self, sel, class_getMethodImplementation(self, @selector(run)), \"v@:\"); } return [super resolveInstanceMethod:sel]; } - (void)run { NSLog(@\"run\"); } 动态添加属性 // 这里利用关联对象，给类添加一个name属性 - (void)setName:(NSString *)name { objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC); } - (NSString *)name { return objc_getAssociatedObject(self, _cmd); } 字典转模型 + (instancetype)modelWithDict:(NSDictionary *)dict { id objc = [[self alloc] init]; unsigned int count = 0; Ivar *ivarList = class_copyIvarList(self, \u0026count); for (int i = 0; i \u003c count; i++) { Ivar ivar = ivarList[i]; NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)]; NSString *key = [ivarName substringFromIndex:1]; id value = dict[key]; if (value) { [objc setValue:value forKey:key]; } } return objc; } 常用的方法 方法 说明 objc_msgSend 向一个对象发送消息 class_getName 获取类名 class_getSuperclass 获取父类 class_getInstanceSize 获取实例大小 class_getInstanceVariable 获取实例变量 class_getClassVariable 获取类变量 class_getInstanceMethod 获取实例方法 class_getClassMethod 获取类方法 class_addMethod 添加方法 class_copyMethodList 获取方法列表 class_replaceMethod 替换方法 class_getMethodImplementation 获取方法实现 class_respondsToSelector 判断类是否实现了某个方法 objc_getAssociatedObject 获取关联对象 objc_setAssociatedObject 设置关联对象 objc_removeAssociatedObjects 移除关联对象 OC消息机制? 消息机制分为两个部分：消息传递 和 消息转发 消息传递: 首先了解下OC中对象等的底层结构： //对象 struct objc_object { Class isa OBJC_ISA_AVAILABILITY; }; //类 struct objc_class { Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; //方法列表 struct objc_method_list { struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE; #ifdef __LP64__ int space OBJC2_UNAVAILABLE; #endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE; } OBJC2_UNAVAILABLE; //方法 struct objc_method { SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE; } OC中的方法调用其实都是转换成了objc_msgSend函数的调用，objc_msgSend函数的定义如下： id objc_msgSend(id self, SEL op, ...) objc_msgS","date":"2023-11-01","objectID":"/ios-interview/:2:5","tags":["ios"],"title":"iOS面试题","uri":"/ios-interview/"},{"categories":["移动端"],"content":"runloop 什么是runloop？ 定义: Runloop是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行Event Loop的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-\u003e等待-\u003e处理” 的循环中，直到这个循环结束（比如传入quit的消息），函数返回。 EventLoop 没有消息需要被处理时, 系统会将当前线程所有权转化为内核态, 当有消息需要处理时, 系统会将当前线程的状态切换回用户态. 所以RunLoop的循环并不是一个单纯的死循环, 而是通过状态切换, 达到没有消息时休眠, 有消息时唤醒的这样一个事件循环机制. 作用: 保持程序的持续运行，处理App中的各种事件（比如触摸事件、定时器事件、Selector事件、Source事件），同时也负责调用开发者提供的代码。 结构: 在 OC 中实际提供了两个 RunLoop 的。 一个是 NSRunLoop，一个是 CFRunLoop。 NSRunLoop 是对 CFRunLoop 的封装，提供了一些面向对象的 API。 NSRunLoop 是位于 Foundation 当中的，CFRunLoop 位于 CoreFoundation 当中的。 runloop的数据结构主要有三个: CFRunLoop CFRunLoopMode Source/Timer/Observer CFRunLoop: //源码 struct __CFRunLoop { pthread_t _pthread; // runloop所在线程,一一对应(RunLoop和线程的关系) CFMutableSetRef _commonModes; // 存放的是NSRunLoopCommonModes表示的mode,我们也可以添加自定义mode到这个set里面 CFMutableSetRef _commonModeItems; // 存放的是添加到NSRunLoopCommonModes表示的mode里面的item(source/timer/observer) CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // 改runloop包含的mode ... }; 由此可以看出，CFRunLoop是一个结构体，里面含有很多属性。看一下这个结构体里面我们需要关注的几个参数。每一个RunLoop都有自己的模式（Mode），而且不止一个模式。模式（Mode）里面存储的是RunLoop要处理的事件源，事件源有三种，Source、Timer、Observer这三种，下面会有详细介绍。RunLoop有很多模式，但是某一个时刻只能有一个确定的Mode，就是_currentMode，下面第二条讲述的就是RunLoop 的Mode，在RunLoop结构体里面几个与模式（Mode）相关的参数 ： _currentMode,，表示该RunLoop当前所处的模式； _modes表示该RunLoop中所有的模式； 另外RunLoop里面有一个Mode是NSRunLoopCommonModes，这个Mode并没有什么含义，它只是对几个模式（Mode）进行标记的一个集合； _commonModes表示NSRunLoopCommonModes这个模式下保存的Mode，我们也可以将自定义的Mode添加到这个set里面； _commonModeItem表示添加到NSRunLoopCommonModes里面的Source/Timer等； CFRunLoopMode: struct __CFRunLoopMode { CFStringRef _name; // Mode Name, 例如 @\"kCFRunLoopDefaultMode\" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ... }; Source/Timer/Observer: CFRunLoopSource 在 CF 框架当中官方名称叫 CFRunLoopSource ，有两种 source0 和 source1 唤醒线程就是从内核态切换到用户态 Source0:非基于Port的，用于用户主动唤醒RunLoop，例如：performSelector:onThread:方法就是通过向对应线程的RunLoop的Source0发送消息来唤醒对应线程的RunLoop的。只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。 Source1:基于Port的，用于系统内核事件的接收，例如：点击事件、触摸事件、Selector事件、Source事件等。包含了一个 mach_port和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程 CFRunLoopTimer CFRunLoopTimer 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含了一个时间长度和一个回调（函数指针），当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserver 观察者，能够监听RunLoop的状态改变，比如即将进入Loop、即将处理 Timer、即将处理 Source0、即将处理 Source1、即将休眠等。 runloop在运行过程中有以下几种状态： typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) { kCFRunLoopEntry = (1UL \u003c\u003c 0), // 即将进入Loop：1 kCFRunLoopBeforeTimers = (1UL \u003c\u003c 1), // 即将处理 Timer：2 kCFRunLoopBeforeSources = (1UL \u003c\u003c 2), // 即将处理 Source：4 kCFRunLoopBeforeWaiting = (1UL \u003c\u003c 5), // 即将进入休眠：32 kCFRunLoopAfterWaiting = (1UL \u003c\u003c 6), // 刚从休眠中唤醒：64 kCFRunLoopExit = (1UL \u003c\u003c 7), // 即将退出Loop：128 kCFRunLoopAllActivities = 0x0FFFFFFFU // 监听全部状态改变 }; 可以给一个RunLoop添加观察。通过监测RunLoop的状态判断是否出现卡顿。创建一个Observer观察者，将创建好的观察者添加到主线程RunLoop的CommonMode模式下观察，创建一个持续的子线程专门用来监控主线程的RunLoop状态，一旦发现进入睡眠前的KCFRunLoopBeforeSource状态，或者唤醒后的状态KCFRunLoopAfterWaiting，在设置的时间阈值内一直没有变化，即可判断为卡顿，dump出堆栈的信息，从而进一步分析出具体是哪个方法的执行时间长。 runLoop中的Mode kCFRunLoopDefaultMode:App的默认Mode，通常主线程是在这个Mode下运行的。 UITrackingRunLoopMode:界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响。 UIInitializationRunLoopMode:在刚启动App时第进入的第一个Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode:接受系统事件的内部Mode，通常用不到。 kCFRunLoopCommonModes:这是一个占位的Mode，没有实际作用。 RunLoop启动的时候只能选择其中一个Mode，作为currentMode，如果需要切换Mode，只能退出当前Mode，再重新选择一个Mode进入。 到这里，基于以上CFRunLoop和CFRunLoopMode的理解，RunLoop中保存的是RunLoopMode，而RunLoopMode中保存的才是实际执行的任务。 ","date":"2023-11-01","objectID":"/ios-interview/:2:6","tags":["ios"],"title":"iOS面试题","uri":"/ios-interview/"},{"categories":["移动端"],"content":"多线程 iOS中常见的多线程方案? 方案 简介 语言 线程生命周期 使用频率 pthread 一套通用的多线程api,适用Unix\\Linux\\Windows等系统,跨平台,可移植,但是使用难度大 C 需要自己管理 低 NSThread 面向对象的多线程api OC 需要自己管理 低 GCD 基于C语言的一套多线程api,替代NSThread等线程技术,充分利用系统的多核 C 自动管理 高 NSOperation 基于GCD的面向对象的多线程api OC 自动管理 高 GCD并行 串行, 同步 异步? 并行和串行:任务的执行方式 并发:多个任务同时执行 串行:一个任务执行完毕后,再执行下一个任务 同步和异步的主要区别:能不能开启新的线程 同步:在当前线程中执行任务,不具备开启新线程的能力 异步:在新的线程中执行任务,具备开启新线程的能力 各种队列的执行情况: 并发队列 串行队列 主队列 同步(sync) 没有开启新线程,串行执行任务 没有开启新线程,串行执行任务 主线程调用:死锁卡住不执行,其他线程调用:没有开启新线程,串行执行任务 异步(async) 有开启新线程,并发执行任务 有开启新线程,串行执行任务 没有开启新线程,串行执行任务 使用sync函数往当前串行队列中添加任务,会卡住当前的串行队列,导致后面的任务无法执行,造成死锁. 主队列是GCD自带的一种特殊的串行队列,放在主队列中的任务,都会放到主线程中执行. // 主队列使用sync函数添加任务,会卡住主线程,导致后面的任务无法执行,造成死锁 dispatch_sync(dispatch_get_main_queue(), ^{ NSLog(@\"同步执行任务\"); }); // 主队列比较特殊实用async函数添加任务,不会开启新线程,任务串行执行 dispatch_async(dispatch_get_main_queue(), ^{ NSLog(@\"异步执行任务\"); }); 异步并发执行任务1、任务2，等任务1、任务2都执行完毕后，再回到主线程执行任务3怎么实现？ // 创建一个队列组 dispatch_group_t group = dispatch_group_create(); // 创建一个并发队列 dispatch_queue_t queue = dispatch_queue_create(\"com.andy90s\", DISPATCH_QUEUE_CONCURRENT); // 将任务1添加到队列组中 dispatch_group_async(group, queue, ^{ NSLog(@\"任务1\"); }); // 将任务2添加到队列组中 dispatch_group_async(group, queue, ^{ NSLog(@\"任务2\"); }); // 将队列组中的任务都执行完毕后,回到主线程执行任务3 dispatch_group_notify(group, dispatch_get_main_queue(), ^{ NSLog(@\"任务3\"); }); 自旋锁和互斥锁的区别？递归锁，条件锁是什么？ 自旋锁: 自旋锁是指当一个线程尝试获取某个锁时，如果该锁已被其他线程占用，就一直循环检测锁是否被释放，而不是进入线程挂起或睡眠状态,也就是忙等。因为不会引起调用者睡眠,所以效率高于互斥锁。 互斥锁: 互斥锁是一种常用的线程同步机制，它保证了在任何时刻，只有一个线程访问某个特定的数据。互斥锁是一种“悲观锁”，它假设最坏的情况，即每次访问数据时都会发生冲突。因此，它每次都会进行加锁和解锁操作，这样就会带来一些额外的开销。 递归锁: 递归锁是一种特殊的互斥锁，它可以被同一个线程多次获取。如果使用普通的互斥锁，当一个线程试图对一个已经由它自己持有的互斥锁加锁时，这种情况称为死锁。而递归锁则允许线程对由它自己持有的互斥锁再次加锁，这种情况下，会将该锁的计数器加1。只有所有的加锁操作全部完成后，才能进行解锁。 条件锁: 条件锁是一种特殊的互斥锁，它允许线程在满足特定条件时才进行加锁。条件锁需要和条件变量配合使用。条件变量是一种线程间的通信机制，它可以使线程在满足特定条件时才进行加锁。条件变量可以和互斥锁配合使用，也可以单独使用。 iOS中的锁有哪些? @synchronized NSLock NSRecursiveLock NSCondition NSConditionLock pthread_mutex dispatch_semaphore OSSpinLock(iOS10后已废弃) os_unfair_lock ","date":"2023-11-01","objectID":"/ios-interview/:2:7","tags":["ios"],"title":"iOS面试题","uri":"/ios-interview/"},{"categories":["移动端"],"content":"前言 记录flutter运行遇到的问题 ","date":"2023-10-31","objectID":"/flutter-running-error/:1:0","tags":["flutter"],"title":"Flutter运行问题","uri":"/flutter-running-error/"},{"categories":["移动端"],"content":"无法打开iproxy ","date":"2023-10-31","objectID":"/flutter-running-error/:2:0","tags":["flutter"],"title":"Flutter运行问题","uri":"/flutter-running-error/"},{"categories":["移动端"],"content":"问题描述 无法打开`iproxy` ","date":"2023-10-31","objectID":"/flutter-running-error/:2:1","tags":["flutter"],"title":"Flutter运行问题","uri":"/flutter-running-error/"},{"categories":["移动端"],"content":"解决方案 sudo xattr -d com.apple.quarantine /Users/xxx/flutter/bin/cache/artifacts/usbmuxd/iproxy 注意 其中/Users/xxx/flutter/bin 替换自己的flutter安装目录 终端输入which flutter查看目录 ","date":"2023-10-31","objectID":"/flutter-running-error/:2:2","tags":["flutter"],"title":"Flutter运行问题","uri":"/flutter-running-error/"},{"categories":["移动端"],"content":"前言 关于设备信息,苹果提供的API并不多,但是我们可以通过一些开源库来获取更多的信息,比如设备型号,屏幕尺寸,系统版本等等.比如获取当前设备是否是刘海屏,如果用安全距离来判断,因为window有可能是nil,可能会导致判断错误 ","date":"2023-10-30","objectID":"/uidevice/:1:0","tags":["iOS"],"title":"UIDevice","uri":"/uidevice/"},{"categories":["移动端"],"content":"DeviceKit ","date":"2023-10-30","objectID":"/uidevice/:2:0","tags":["iOS"],"title":"UIDevice","uri":"/uidevice/"},{"categories":["移动端"],"content":"地址 【DeviceKit】 ","date":"2023-10-30","objectID":"/uidevice/:2:1","tags":["iOS"],"title":"UIDevice","uri":"/uidevice/"},{"categories":["移动端"],"content":"使用 比如判断是否是刘海屏等: import DeviceKit let device = Device.current // 判断是否是iphone if device.isPhone { // 判断是否是刘海屏 if device.hasRoundedDisplayCorners { // 判断是否是iphoneX if device == .iPhoneX { // ... } } } ","date":"2023-10-30","objectID":"/uidevice/:2:2","tags":["iOS"],"title":"UIDevice","uri":"/uidevice/"},{"categories":["移动端"],"content":"前言 keyWindow是iOS系统中的一个概念,它是一个全局的变量,代表当前显示在屏幕最上面的window,它是一个UIWindow对象,每个应用程序都有一个keyWindow,它是一个全局的变量,可以通过UIApplication的keyWindow属性获取,但是由于 iOS系统的不断迭代,导致获取keywindow的方法也在不断变化,这里记录一下获取keywindow的方法 ","date":"2023-10-30","objectID":"/keywindow/:1:0","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"获取keywindow ","date":"2023-10-30","objectID":"/keywindow/:2:0","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"iOS13之前 UIApplication.shared.keyWindow ","date":"2023-10-30","objectID":"/keywindow/:2:1","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"iOS13之后 UIApplication.shared.windows.filter {$0.isKeyWindow}.first ","date":"2023-10-30","objectID":"/keywindow/:2:2","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"iOS16之后 UIApplication.shared.connectedScenes .filter {$0.activationState == .foregroundActive} .map {$0 as? UIWindowScene} .compactMap {$0} .first?.windows .filter {$0.isKeyWindow}.first 技巧 获取逻辑: 多个场景 -\u003e 筛选出前台激活的场景 -\u003e 转换为UIWindowScene -\u003e 去除nil -\u003e 取第一个场景 -\u003e 获取场景中的窗口 -\u003e 筛选出keywindow -\u003e 取第一个窗口 ","date":"2023-10-30","objectID":"/keywindow/:2:3","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"适配所有版本 由于新的api已经兼容到了13.0,所以只需要兼容到13.0就可以了,这里使用#available来判断版本,如果版本大于13.0,则使用新的api,否则使用旧的api extension UIApplication { /// 获取keywindow static var currentKeyWindow: UIWindow? { if #available(iOS 13.0, *) { return UIApplication.shared.connectedScenes .filter {$0.activationState == .foregroundActive} .compactMap {$0 as? UIWindowScene} .first?.windows .filter {$0.isKeyWindow}.first } else { return UIApplication.shared.keyWindow } } } 注意 需要注意的是 1\u003e当程序处于启动状态时,keyWindow可能为nil,因为此时程序还没有显示出来,13系统以后苹果推荐使用Scene来管理窗口 2\u003e当程序处于后台时,keyWindow可能为nil,因为此时程序已经被挂起,不再显示 3\u003e程序启动过程中,keyWindow可能会发生变化,也可能是nil,因为程序启动过程中,可能会创建多个窗口,最后显示的窗口才是keyWindow 具体表现是,在root的控制器中分别在viewDidload和viewDidAppear打印keyWindow: \"viewDidLoad = nil\" \"viewDidAppear = Optional(\u003cUIWindow: 0x100b095a0; frame = (0 0; 414 896);gestureRecognizers = \u003cNSArray: 0x281662b50\u003e; layer = \u003cUIWindowLayer: 0x281662ac0\u003e\u003e)\" 上面的方法我已经分别在包含Scene和不包含两种工程中测试,都已经通过,如果有问题,欢迎指出 ","date":"2023-10-30","objectID":"/keywindow/:2:4","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"前言 很多场景需要获取当前显示的控制器，比如弹窗，需要获取当前显示的控制器，才能弹出来，否则会出现问题。这里记录一下获取当前显示的控制器的方法。 ","date":"2023-10-30","objectID":"/top-viewcontroller/:1:0","tags":["iOS"],"title":"获取当前显示的ViewController","uri":"/top-viewcontroller/"},{"categories":["移动端"],"content":"获取当前显示的控制器 ","date":"2023-10-30","objectID":"/top-viewcontroller/:2:0","tags":["iOS"],"title":"获取当前显示的ViewController","uri":"/top-viewcontroller/"},{"categories":["移动端"],"content":"首先获取当前显示的window extension UIApplication { /// 获取keywindow static var currentKeyWindow: UIWindow? { if #available(iOS 13.0, *) { return UIApplication.shared.connectedScenes .filter {$0.activationState == .foregroundActive} .compactMap {$0 as? UIWindowScene} .first?.windows .filter {$0.isKeyWindow}.first } else { return UIApplication.shared.keyWindow } } } 技巧 关于keyWindow可以看这里 获取keyWindow ","date":"2023-10-30","objectID":"/top-viewcontroller/:2:1","tags":["iOS"],"title":"获取当前显示的ViewController","uri":"/top-viewcontroller/"},{"categories":["移动端"],"content":"获取当前显示的控制器 extension UIApplication { /// 获取当前显示的控制器 /// - Parameter base: 基础控制器 /// - Returns: 当前显示的控制器 class func topViewController(base: UIViewController? = UIApplication.currentKeyWindow?.rootViewController) -\u003e UIViewController? { if let nav = base as? UINavigationController { return topViewController(base: nav.visibleViewController) } if let tab = base as? UITabBarController { if let selected = tab.selectedViewController { return topViewController(base: selected) } } if let presented = base?.presentedViewController { return topViewController(base: presented) } return base } class var topViewController: UIViewController? { return topViewController() } } 建议 建议不要在viewDidLoad中使用topViewController，因为此时view还没有加载完成，会导致获取到的控制器不正确。 ","date":"2023-10-30","objectID":"/top-viewcontroller/:2:2","tags":["iOS"],"title":"获取当前显示的ViewController","uri":"/top-viewcontroller/"},{"categories":["工具"],"content":"前言 有时候需要下载app的ipa包 ","date":"2023-10-27","objectID":"/download-ipa/:1:0","tags":["网站","ipa"],"title":"下载ipa","uri":"/download-ipa/"},{"categories":["工具"],"content":"【decrypt】 【decrypt】","date":"2023-10-27","objectID":"/download-ipa/:2:0","tags":["网站","ipa"],"title":"下载ipa","uri":"/download-ipa/"},{"categories":["移动端"],"content":"前言 底部弹框,类似微信的分享功能,动画效果有两个: 从底部弹出内容 从底部弹出内容,并且背景变暗 ","date":"2023-10-25","objectID":"/popup-slide/:1:0","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"效果 弹框效果 ","date":"2023-10-25","objectID":"/popup-slide/:2:0","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"思路 直接模态一个控制器,自定义转场动画,并且给内容view添加一个改变frame的动画就可以了 ","date":"2023-10-25","objectID":"/popup-slide/:3:0","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"代码 ","date":"2023-10-25","objectID":"/popup-slide/:4:0","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"转场动画 class CustomPresentAnimator: NSObject, UIViewControllerAnimatedTransitioning { private var duration: TimeInterval = 0.3 private var maskColor: UIColor = UIColor.black private var maskAlpha: CGFloat = 0.6 private var present = true convenience init(_ present: Bool = true, maskColor: UIColor? = nil, maskAlpha: CGFloat? = nil, duration: TimeInterval? = nil) { self.init() if let maskColor = maskColor { self.maskColor = maskColor } if let maskAlpha = maskAlpha { self.maskAlpha = maskAlpha } if let duration = duration { self.duration = duration } self.present = present } func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -\u003e TimeInterval { return duration } func animateTransition(using transitionContext: UIViewControllerContextTransitioning) { guard let toVC = transitionContext.viewController(forKey: .to) else {return} guard let fromVC = transitionContext.viewController(forKey: .from) else {return} let containerView = transitionContext.containerView if present { containerView.addSubview(toVC.view) toVC.view.alpha = 0.0 toVC.view.backgroundColor = .clear UIView.animate(withDuration: duration, animations: {[weak self] in guard let wself = self else { return } toVC.view.alpha = 1.0 toVC.view.backgroundColor = wself.maskColor.withAlphaComponent(wself.maskAlpha) }, completion: { finished in transitionContext.completeTransition(finished) }) } else { UIView.animate(withDuration: duration, animations: { fromVC.view.alpha = 0.0 fromVC.view.backgroundColor = .clear }, completion: { finished in transitionContext.completeTransition(finished) }) } } } ","date":"2023-10-25","objectID":"/popup-slide/:4:1","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"弹框控制器 class CommonModalController: UIViewController,UIViewControllerTransitioningDelegate { let contentView = UIView() let pageBottomPadding = -34 // 需要减去底部安全区域的高度,这里省略机型判断,默认是iPhoneX以上机型 private var contentSize: CGSize = .zero private var touchView: UIView = UIView() convenience init(contentSize: CGSize) { self.init() self.modalPresentationStyle = .custom self.transitioningDelegate = self self.contentSize = contentSize self.contentView.frame = CGRectMake(0, self.view.bounds.size.height, self.view.bounds.size.width, self.contentSize.height - pageBottomPadding) self.touchView.frame = CGRectMake(0, 0, self.view.bounds.size.width, self.view.bounds.size.height - self.contentSize.height + pageBottomPadding) } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) UIView.animate(withDuration: 0.3,delay: 0) {[weak self] in guard let wself = self else { return } wself.contentView.frame = CGRectMake(0, wself.view.bounds.size.height - wself.contentSize.height + pageBottomPadding, wself.view.bounds.size.width, wself.contentSize.height - pageBottomPadding) } } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) UIView.animate(withDuration: 0.3,delay: 0) {[weak self] in guard let wself = self else { return } wself.contentView.frame = CGRectMake(0, wself.view.bounds.size.height, wself.view.bounds.size.width, wself.contentSize.height - pageBottomPadding) } } override func viewDidLoad() { super.viewDidLoad() self.contentView.backgroundColor = .white self.contentView.layer.cornerRadius = 18 self.contentView.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner] let tap = UITapGestureRecognizer(target: self, action: #selector(dismissView)) self.touchView.addGestureRecognizer(tap) self.view.addSubview(touchView) self.view.addSubview(contentView) } @objc func dismissView() { self.dismiss(animated: true) } func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -\u003e UIViewControllerAnimatedTransitioning? { return CustomPresentAnimator() } func animationController(forDismissed dismissed: UIViewController) -\u003e UIViewControllerAnimatedTransitioning? { return CustomPresentAnimator(false) } deinit { debugPrint(\"\\(self)\\(#function)\") } } ","date":"2023-10-25","objectID":"/popup-slide/:4:2","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"使用 let vc = CommonModalController(contentSize: CGSizeMake(self.view.bounds.size.width, 200)) self.present(vc, animated: true) 这里只是简单的实现了一个底部弹框,如果需要更多的动画效果,可以自己去实现,这里只是提供一个思路 ","date":"2023-10-25","objectID":"/popup-slide/:4:3","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["工具"],"content":"前言 Mac 版 Chrome 自带双指手势前进后退功能,这个功能叫做Overscroll history navigation,但是这个功能很不好用，经常会误触，所以需要禁用。 这个功能是根据MAC系统的设置来开启的,在MAC中这个功能叫做在页面之间轻扫，默认是开启的。 下面就来介绍两种禁用方法。 ","date":"2023-10-23","objectID":"/chrome-overscoll/:1:0","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"系统设置 ","date":"2023-10-23","objectID":"/chrome-overscoll/:2:0","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"触控板设置 「系统偏好设置」 → 「触控板」 → 「更多手势」中的「在页面之间轻扫」,取消勾选。 触摸板轻扫 ","date":"2023-10-23","objectID":"/chrome-overscoll/:2:1","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"鼠标设置 「系统偏好设置」 → 「鼠标」 → 「更多手势」中的「在页面之间轻扫」,取消勾选。 鼠标轻扫 ","date":"2023-10-23","objectID":"/chrome-overscoll/:2:2","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"Chrome设置 上面系统设置会禁用所有的轻扫手势，如果只想禁用Chrome浏览器的轻扫手势，可以通过以下命令禁用： ","date":"2023-10-23","objectID":"/chrome-overscoll/:3:0","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"禁用鼠标手势 defaults write com.google.Chrome AppleEnableMouseSwipeNavigateWithScrolls -bool false ","date":"2023-10-23","objectID":"/chrome-overscoll/:3:1","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"禁用触控板手势 defaults write com.google.Chrome AppleEnableSwipeNavigateWithScrolls -bool false ","date":"2023-10-23","objectID":"/chrome-overscoll/:3:2","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["移动端"],"content":"布局从右到左 ","date":"2023-10-13","objectID":"/uicollectionview/:1:0","tags":["iOS"],"title":"UICollectionView","uri":"/uicollectionview/"},{"categories":["移动端"],"content":"方式1 数据会从右到左排列 if #available(iOS 9.0, *) { collectionView.semanticContentAttribute = .forceRightToLeft } if (@available(iOS 9.0, *)) { _collectionView.semanticContentAttribute = UISemanticContentAttributeForceRightToLeft; } ","date":"2023-10-13","objectID":"/uicollectionview/:1:1","tags":["iOS"],"title":"UICollectionView","uri":"/uicollectionview/"},{"categories":["移动端"],"content":"方式2 数据会从右到左排列 if #available(iOS 9.0, *) { collectionView.transform = CGAffineTransform(scaleX: -1.0, y: 1.0) } if (@available(iOS 9.0, *)) { _collectionView.transform = CGAffineTransformMakeScale(-1.0, 1.0); } cell中的内容也需要做相应的变换 cell.transform = CGAffineTransform(scaleX: -1.0, y: 1.0) cell.transform = CGAffineTransformMakeScale(-1.0, 1.0); ","date":"2023-10-13","objectID":"/uicollectionview/:1:2","tags":["iOS"],"title":"UICollectionView","uri":"/uicollectionview/"},{"categories":["移动端"],"content":"方式3 自定义UICollectionViewFlowLayout,这种方式不会改变数据的排列方向，只是改变了cell的布局方向 比如一行有4个cell，那么第一个cell的x坐标为0，第二个cell的x坐标为第一个cell的x坐标加上第一个cell的宽度，以此类推，第四个cell的x坐标为第三个cell的x坐标加上第三个cell的宽度，这样就可以实现从右到左的布局 示例代码如下： class RTLCollectionViewFlowLayout: UICollectionViewFlowLayout { override func layoutAttributesForElements(in rect: CGRect) -\u003e [UICollectionViewLayoutAttributes]? { guard let attributesArray = super.layoutAttributesForElements(in: rect) else { return nil } var newAttributesArray = [UICollectionViewLayoutAttributes]() // 获取余数 let remainder = attributesArray.count % 4 // 获取collectionView的宽度 let collectionViewWidth = collectionViewContentSize.width var currentX: CGFloat = sectionInset.left if attributesArray.count \u003c 4 { // 只有一行 currentX = collectionViewWidth - sectionInset.right - CGFloat(remainder) * (itemSize.width + minimumInteritemSpacing) } var currentY: CGFloat = sectionInset.top for (index,attributes) in attributesArray.enumerated() { let newAttributes = attributes.copy() as! UICollectionViewLayoutAttributes if newAttributes.frame.origin.y == currentY { // 在同一行 newAttributes.frame.origin.x = currentX } else { // 开始新的一行 currentY = newAttributes.frame.origin.y let last = attributesArray.count - index if last \u003c 4 { let count = last % 4 currentX = collectionViewContentSize.width - sectionInset.right - CGFloat(count) * itemSize.width - CGFloat(count - 1) * minimumInteritemSpacing } else { currentX = sectionInset.left } newAttributes.frame.origin.x = currentX } currentX += newAttributes.frame.size.width + minimumInteritemSpacing newAttributesArray.append(newAttributes) } return newAttributesArray } } @implementation RTLCollectionViewFlowLayout - (NSArray\u003cUICollectionViewLayoutAttributes *\u003e *)layoutAttributesForElementsInRect:(CGRect)rect { NSArray *attributesArray = [super layoutAttributesForElementsInRect:rect]; NSMutableArray *newAttributesArray = [NSMutableArray array]; // 获取余数 NSInteger remainder = attributesArray.count % 4; // 获取collectionView的宽度 CGFloat collectionViewWidth = self.collectionViewContentSize.width; CGFloat currentX = self.sectionInset.left; if (attributesArray.count \u003c 4) { // 只有一行 currentX = collectionViewWidth - self.sectionInset.right - remainder * (self.itemSize.width + self.minimumInteritemSpacing); } CGFloat currentY = self.sectionInset.top; for (NSInteger index = 0; index \u003c attributesArray.count; index++) { UICollectionViewLayoutAttributes *attributes = attributesArray[index]; UICollectionViewLayoutAttributes *newAttributes = [attributes copy]; if (newAttributes.frame.origin.y == currentY) { // 在同一行 newAttributes.frame.origin.x = currentX; } else { // 开始新的一行 currentY = newAttributes.frame.origin.y; NSInteger last = attributesArray.count - index; if (last \u003c 4) { NSInteger count = last % 4; currentX = collectionViewWidth - self.sectionInset.right - count * self.itemSize.width - (count - 1) * self.minimumInteritemSpacing; } else { currentX = self.sectionInset.left; } newAttributes.frame.origin.x = currentX; } currentX += newAttributes.frame.size.width + self.minimumInteritemSpacing; [newAttributesArray addObject:newAttributes]; } return newAttributesArray; } @end ","date":"2023-10-13","objectID":"/uicollectionview/:1:3","tags":["iOS"],"title":"UICollectionView","uri":"/uicollectionview/"},{"categories":["后端"],"content":"命令行进入Django项目交互环境 python manage.py shell ","date":"2023-09-18","objectID":"/django-interactive-environment/:1:0","tags":[],"title":"Django项目交互环境","uri":"/django-interactive-environment/"},{"categories":["工具"],"content":"抓包工具 Windows平台有finder Mac平台有Charles 都是比较常用的,因为我是mac刚开始用的也是Charles,但是因为公司路由器等原因,经常性的无法抓包,这里分享另一个开源工具 【Whistle】 ","date":"2023-09-14","objectID":"/whistle/:1:0","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"1.安装 npm install -g whistle ","date":"2023-09-14","objectID":"/whistle/:1:1","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"2.启动 w2 start 默认是8899端口,如果需要修改端口,可以在启动命令后面加上端口号,比如 w2 start -p 8888 启动之后可以在浏览器中输入终端提示链接打开抓包工具 启动 ","date":"2023-09-14","objectID":"/whistle/:1:2","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"3.停止 w2 stop ","date":"2023-09-14","objectID":"/whistle/:1:3","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"3.手机配置 手机连接电脑,打开wifi,选择电脑的wifi 手机设置代理,代理地址填写电脑的ip地址,端口号填写8899 手机用safari输入rootca.pro下载证书,安装证书,也可以到网页设置页面扫码安装如下图 到手机的设置中,找到通用-\u003e关于本机-\u003e证书信任设置,找到刚才安装的证书,打开信任开关 电脑打开http://localhost:8899/点击左侧network-\u003eenable开启抓包 扫码安装证书 抓包 技巧 如果证书配置成功,但是抓包不成功,并且网络也正常,但是手机却无法访问网络,这时候可以尝试关闭电脑的wifi,然后再打开,这样手机就可以访问网络了 ","date":"2023-09-14","objectID":"/whistle/:1:4","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"MOCK数据 mock数据 ","date":"2023-09-14","objectID":"/whistle/:1:5","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"安装 brew install --cask docker ","date":"2023-08-08","objectID":"/install-docker/:1:0","tags":[],"title":"Mac电脑安装Docker","uri":"/install-docker/"},{"categories":["工具"],"content":"查看版本 docker --version ","date":"2023-08-08","objectID":"/install-docker/:2:0","tags":[],"title":"Mac电脑安装Docker","uri":"/install-docker/"},{"categories":["工具"],"content":"安装完毕打开客户端 在应用程序中找到Docker图标，双击打开，会出现如下界面，点击右上角的鲸鱼图标，选择preferences，进入设置界面，选择resources，设置内存大小，推荐设置为4G，然后点击apply \u0026 restart，重启docker，这样就可以了。 Docker 默认的Setting 这里我运行开源项目 【Misago】截图 docker compose up 【Misago】 ","date":"2023-08-08","objectID":"/install-docker/:3:0","tags":[],"title":"Mac电脑安装Docker","uri":"/install-docker/"},{"categories":["工具"],"content":"清理 默认docker占用磁盘60G，如果不清理，会占用很多磁盘空间，可以通过如下命令清理 docker system prune -a ","date":"2023-08-08","objectID":"/install-docker/:4:0","tags":[],"title":"Mac电脑安装Docker","uri":"/install-docker/"},{"categories":["工具"],"content":"参考 【Docker 入门到实践】","date":"2023-08-08","objectID":"/install-docker/:5:0","tags":[],"title":"Mac电脑安装Docker","uri":"/install-docker/"},{"categories":["移动端"],"content":"M系列电脑运行MAC(Designed for iPad)或者MAC(Designed for iPhone)项目报错 ","date":"2023-07-12","objectID":"/xcode-error/:1:0","tags":[],"title":"Xcode运行项目报错","uri":"/xcode-error/"},{"categories":["移动端"],"content":"报错信息 The app's bundle identifier \"com.xxx.xxx.xxx\" is being used by another running app. macOS does not support running iOS or Mac Catalyst apps concurrently with other apps using the same bundle identifier. Please try again after terminating all other processes using the same bundle identifier or changing the bundle identifier of your app. ","date":"2023-07-12","objectID":"/xcode-error/:1:1","tags":[],"title":"Xcode运行项目报错","uri":"/xcode-error/"},{"categories":["移动端"],"content":"分析原因 电脑上有同名应用 ","date":"2023-07-12","objectID":"/xcode-error/:1:2","tags":[],"title":"Xcode运行项目报错","uri":"/xcode-error/"},{"categories":["移动端"],"content":"解决方案 检查当前电脑应用是否有同名应用，如果有，关闭同名应用 重启Xcode 上面不行直接施展重启大法: 重启电脑 ","date":"2023-07-12","objectID":"/xcode-error/:1:3","tags":[],"title":"Xcode运行项目报错","uri":"/xcode-error/"},{"categories":["工具"],"content":"MySQL是一种流行的关系型数据库管理系统，本文将介绍如何在Mac上安装MySQL并创建数据库和表格。","date":"2023-07-11","objectID":"/install-mysql/","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"前言 最近在学习MySQL，需要在Mac上安装MySQL，记录一下安装使用过程。 ","date":"2023-07-11","objectID":"/install-mysql/:1:0","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"安装 ","date":"2023-07-11","objectID":"/install-mysql/:2:0","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"1.通过brew安装 brew install mysql ","date":"2023-07-11","objectID":"/install-mysql/:2:1","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"2.启动MySQL brew services start mysql ","date":"2023-07-11","objectID":"/install-mysql/:2:2","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"3.设置密码 mysql_secure_installation ","date":"2023-07-11","objectID":"/install-mysql/:2:3","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"4.登录MySQL mysql -uroot -p ","date":"2023-07-11","objectID":"/install-mysql/:2:4","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"5.修改密码 ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password'; ","date":"2023-07-11","objectID":"/install-mysql/:2:5","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"6.退出MySQL exit ","date":"2023-07-11","objectID":"/install-mysql/:2:6","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"7.重启MySQL brew services restart mysql ","date":"2023-07-11","objectID":"/install-mysql/:2:7","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"8.登录MySQL mysql -uroot -p ","date":"2023-07-11","objectID":"/install-mysql/:2:8","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"9.创建数据库 create database test; ","date":"2023-07-11","objectID":"/install-mysql/:2:9","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"10.查看数据库 show databases; ","date":"2023-07-11","objectID":"/install-mysql/:2:10","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"11.删除数据库 drop database test; ","date":"2023-07-11","objectID":"/install-mysql/:2:11","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"12.MySQL 服务器管理命令 brew services start mysql #: 启动 MySQL 服务器，并设置为自启动。 brew services stop mysql #: 停止 MySQL 服务器，并设置为不自启动。 brew services run mysql #: 只启动 MySQL 服务器。 mysql.server start #: 启动 MySQL 服务器。 mysql.server stop #: 停止 MySQL 服务器 ","date":"2023-07-11","objectID":"/install-mysql/:2:12","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"使用(以mysite为例) 执行上面的安装和启动后，就可以使用MySQL了。 ","date":"2023-07-11","objectID":"/install-mysql/:3:0","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 登录MySQL mysql -uroot -p ","date":"2023-07-11","objectID":"/install-mysql/:3:1","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 创建数据库 create database mysite DEFAULT CHARSET utf8 COLLATE utf8_general_ci; ","date":"2023-07-11","objectID":"/install-mysql/:3:2","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 查看数据库 show databases; ","date":"2023-07-11","objectID":"/install-mysql/:3:3","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 选择数据库 use mysite; ","date":"2023-07-11","objectID":"/install-mysql/:3:4","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 创建表 CREATE TABLE `app_userinfo` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `password` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `is_active` tinyint(1) NOT NULL, `is_staff` tinyint(1) NOT NULL, `is_superuser` tinyint(1) NOT NULL, `date_joined` datetime NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`), UNIQUE KEY `email` (`email`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; ","date":"2023-07-11","objectID":"/install-mysql/:3:5","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 查看表 desc app_userinfo; ","date":"2023-07-11","objectID":"/install-mysql/:3:6","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"参考 【Mac安装MySQL】","date":"2023-07-11","objectID":"/install-mysql/:4:0","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"fastlane简介 fastlane是一个用来自动化打包和发布的工具,可以用来自动化打包,上传到App Store或者TestFlight,也可以用来自动化发布到fir或者蒲公英等平台,还可以用来自动化生成icon和splash等等,总之,fastlane是一个非常强大的工具,可以大大提高开发效率,减少出错的概率,下面就来介绍一下fastlane的使用 ","date":"2023-07-04","objectID":"/fastlane-package/:1:0","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["工具"],"content":"使用 ","date":"2023-07-04","objectID":"/fastlane-package/:2:0","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["工具"],"content":"安装 使用brew安装 brew install fastlane ","date":"2023-07-04","objectID":"/fastlane-package/:2:1","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["工具"],"content":"初始化 在项目根目录下执行 fastlane init 然后选择2来初始化fastlane配置文件,这样就会在项目根目录下生成一个fastlane文件夹,里面有一个Fastfile文件,这个文件就是fastlane的配置文件,我们可以在这个文件中配置自动化打包的一些参数,比如bundleId等等,也可以在这个文件中配置自动化上传到App Store或者TestFlight等等,具体的配置可以参考fastlane官方文档 ","date":"2023-07-04","objectID":"/fastlane-package/:2:2","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["工具"],"content":"以下是我自己上传到蒲公英的脚本 工程自动签名: ENV[\"FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT\"] = \"120\" # 设置超时时间,不然会报超时错误 default_platform(:ios) platform :ios do desc \"Description of what the lane does\" lane :beta do gym( export_method: \"ad-hoc\", scheme: \"XXX\", # 项目的scheme configuration: \"Release\" ) pgyer(api_key: \"xxx\") # 蒲公英的api_key,可到蒲公英网站查看 end end 工程手动签名: ENV[\"FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT\"] = \"120\" # 设置超时时间,不然会报超时错误 default_platform(:ios) platform :ios do desc \"Description of what the lane does\" lane :beta do increment_build_number gym( output_directory: \"./fastlane/\", # 打包后的ipa文件存放的路径 export_method: \"ad-hoc\", scheme: \"XXX\", # 项目的scheme export_options: { provisioningProfiles: { \"包名\" =\u003e \"描述文件名称\" } }, configuration: \"Release\" ) pgyer(api_key: \"蒲公英的api_key\") end end 打包的时候到项目根目录执行: fastlane beta ","date":"2023-07-04","objectID":"/fastlane-package/:3:0","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["工具"],"content":"二次签名 准备好需要二次签名的ipa文件,然后执行以下命令: fastlane sigh resign --signing_identity \"iPhone Distribution: XXXX\" --provisioning_profile \"描述文件名称.mobileprovision\" --ipa \"需要二次签名的ipa文件路径\" --entitlements \"entitlements.plist\" --display_name \"显示名称\" --bundle_id \"包名\" --output_path \"输出路径\" 其中signing_identity是证书的名称,可以在钥匙串中查看,provisioning_profile是描述文件的名称,可以在~/Library/MobileDevice/Provisioning Profiles目录下查看,ipa是需要二次签名的ipa文件路径,entitlements是entitlements文件的路径,display_name是显示名称,bundle_id是包名,output_path是输出路径 ","date":"2023-07-04","objectID":"/fastlane-package/:4:0","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["前端"],"content":"升级electron到最新版本 sudo npm install electron@latest 升级electron-packager到最新版本 sudo npm install electron-packager@latest 升级electron-builder到最新版本 sudo npm install electron-builder@latest ","date":"2023-06-08","objectID":"/electron/:0:0","tags":[],"title":"Electron","uri":"/electron/"},{"categories":["前端"],"content":"问题 当文本是链接时候,会超出组件显示,如下图,红色为text组件: 超出组件 ","date":"2023-05-31","objectID":"/text-word-break/:1:0","tags":["uniapp","vue"],"title":"Text组件显示链接文本超出组件","uri":"/text-word-break/"},{"categories":["前端"],"content":"解决 /* 单词换行 */ word-break: break-all; ","date":"2023-05-31","objectID":"/text-word-break/:2:0","tags":["uniapp","vue"],"title":"Text组件显示链接文本超出组件","uri":"/text-word-break/"},{"categories":["前端"],"content":"uni小程序弹出组件滑动穿透问题解决方案 示例: @touchmove.stop.prevent=\"moveStop\" \u003cview @touchmove.stop.prevent=\"moveStop\"\u003e \u003cu-popup :show=\"show\" class=\"approval-popup\" mode=\"bottom\" :round=\"18\" @close=\"close\"\u003e \u003c/u-popup\u003e \u003c/view\u003e const moveStop = (e) =\u003e { e.stopPropagation(); }; ","date":"2023-05-18","objectID":"/uni-popup-sliding-penetration/:1:0","tags":["uniapp","vue"],"title":"Uni Popup等弹出组件滑动穿透问题","uri":"/uni-popup-sliding-penetration/"},{"categories":["前端"],"content":"uni-popup 带圆角的情况下，底部安全区域问题 官方自带了一个popup组件，但是在ios手机上，如果popup组件带圆角，会出现底部安全区域问题，如下图所示： 底部安全区域问题 ","date":"2023-05-18","objectID":"/uni-popup-safearea/:1:0","tags":["uniapp","vue"],"title":"Uni Popup组件底部安全区域问题","uri":"/uni-popup-safearea/"},{"categories":["前端"],"content":"解决方案 :safeArea=false \u003cuni-popup type=\"bottom\" :safeArea=false\u003e \u003cview class=\"content\"\u003e \u003cview\u003e标题\u003c/view\u003e \u003cview\u003e内容\u003c/view\u003e \u003c/view\u003e \u003c/uni-popup\u003e .content { background-color: #fff; border-radius: 20upx 20upx 0 0; /*兼容 IOS\u003c11.2*/ padding-bottom: constant(safe-area-inset-bottom); /*兼容 IOS\u003e11.2*/ padding-bottom: env(safe-area-inset-bottom); } ","date":"2023-05-18","objectID":"/uni-popup-safearea/:2:0","tags":["uniapp","vue"],"title":"Uni Popup组件底部安全区域问题","uri":"/uni-popup-safearea/"},{"categories":["移动端"],"content":"退到后台通知引起的崩溃 不排除是特定版本的iOS系统bug ","date":"2023-05-17","objectID":"/background-crash/:1:0","tags":["iOS"],"title":"退到后台通知引起的崩溃","uri":"/background-crash/"},{"categories":["移动端"],"content":"解决 @objc func appDidEnterBackground() { // 要判断当前应用程序状态是否为后台状态 guard UIApplication.shared.applicationState == .background else { return } // todo something } ","date":"2023-05-17","objectID":"/background-crash/:2:0","tags":["iOS"],"title":"退到后台通知引起的崩溃","uri":"/background-crash/"},{"categories":["前端"],"content":"异步函数调用this找不到方法 that 一下; const that = this; promise { then(res =\u003e { that.xxx(); }) } ","date":"2023-05-10","objectID":"/uniapp-this/:1:0","tags":["uniapp","vue"],"title":"异步函数调用this找不到方法","uri":"/uniapp-this/"},{"categories":["前端"],"content":"Uni页面撑满整个view 设置了父元素高度100%后,没有撑满整个view,如下图所示: 示例 ","date":"2023-05-08","objectID":"/uniapp-full-view/:1:0","tags":["uniapp","vue"],"title":"Uni页面撑满整个view","uri":"/uniapp-full-view/"},{"categories":["前端"],"content":"解决方法 增加如下样式代码,uni-page-body,html,body{height:100%}: \u003cstyle lang=\"scss\" scoped\u003e uni-page-body,html,body{height:100%} .page { display: flex; background-color: #FFFFFF; height: 100%; } \u003c/style\u003e ","date":"2023-05-08","objectID":"/uniapp-full-view/:2:0","tags":["uniapp","vue"],"title":"Uni页面撑满整个view","uri":"/uniapp-full-view/"},{"categories":["前端"],"content":"效果 效果 ","date":"2023-05-08","objectID":"/uniapp-full-view/:3:0","tags":["uniapp","vue"],"title":"Uni页面撑满整个view","uri":"/uniapp-full-view/"},{"categories":["前端"],"content":"v-show在微信小程序中不生效 \u003cstyle lang=\"scss\" scoped\u003e /* #ifdef MP-WEIXIN */ view[hidden] { display: none !important; } /* #endif */ \u003c/style\u003e 【具体原因】","date":"2023-05-08","objectID":"/uniapp-v-show/:1:0","tags":["uniapp","vue"],"title":"v-show在微信小程序中不生效","uri":"/uniapp-v-show/"},{"categories":["前端"],"content":"v-show在微信小程序中不生效 【v-show在微信小程序中不生效】 ","date":"2023-05-08","objectID":"/uniapp-question/:1:0","tags":["uniapp","vue"],"title":"Uni开发遇到的一些问题汇总","uri":"/uniapp-question/"},{"categories":["前端"],"content":"Uni页面撑满整个view,设置高度100%无效 【Uni页面撑满整个view,设置高度100%无效】 ","date":"2023-05-08","objectID":"/uniapp-question/:2:0","tags":["uniapp","vue"],"title":"Uni开发遇到的一些问题汇总","uri":"/uniapp-question/"},{"categories":["移动端"],"content":"iOS原生API录音功能","date":"2023-04-23","objectID":"/ios-recorder/","tags":["iOS","AVFoundation"],"title":"iOS录音功能","uri":"/ios-recorder/"},{"categories":["移动端"],"content":"前言 iOS原生API录音功能 ","date":"2023-04-23","objectID":"/ios-recorder/:1:0","tags":["iOS","AVFoundation"],"title":"iOS录音功能","uri":"/ios-recorder/"},{"categories":["移动端"],"content":"代码 import AVFoundation class Recorder { var recorder: AVAudioRecorder? func startRecord() { let session = AVAudioSession.sharedInstance() do { try session.setCategory(.playAndRecord, mode: .default, options: []) try session.setActive(true, options: []) session.requestRecordPermission { [unowned self] allowed in DispatchQueue.main.async { if allowed { self.startRecording() } else { // failed to record! } } } } catch { // failed to record! } } func startRecording() { // 输出mav格式 let audioFilename = getDocumentsDirectory().appendingPathComponent(\"recording.wav\") let settings = [ AVFormatIDKey: Int(kAudioFormatLinearPCM), AVSampleRateKey: 44100, AVNumberOfChannelsKey: 2, AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue ] do { recorder = try AVAudioRecorder(url: audioFilename, settings: settings) recorder?.record() } catch { finishRecording(success: false) } } func finishRecording(success: Bool) { recorder?.stop() recorder = nil if success { print(\"Finished recording\") } else { print(\"Failed recording\") } } func getDocumentsDirectory() -\u003e URL { let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask) return paths[0] } func stopRecord() { finishRecording(success: true) } } ","date":"2023-04-23","objectID":"/ios-recorder/:2:0","tags":["iOS","AVFoundation"],"title":"iOS录音功能","uri":"/ios-recorder/"},{"categories":["移动端"],"content":"使用 let recorder = Recorder() // 初始化 recorder.startRecord() // 开始录音 recorder.stopRecord() // 结束录音 ","date":"2023-04-23","objectID":"/ios-recorder/:3:0","tags":["iOS","AVFoundation"],"title":"iOS录音功能","uri":"/ios-recorder/"},{"categories":["移动端"],"content":"使用form-data上传 private func recordComplete() { // 1. 获取录音文件 let filePath = recorder.getDocumentsDirectory().appendingPathComponent(\"recording.wav\") // 2. 上传录音文件地址 let uploadUrl = \"http://xxx.com/upload\" // 3. 设置请求头 let headers: HTTPHeaders = [ \"Content-type\": \"multipart/form-data\", \"Accept\": \"application/json\", ] // 4. 使用alamofire上传 AF.upload(multipartFormData: { (multipartFormData) in multipartFormData.append(filePath, withName: \"file\", fileName: \"recoding.wav\", mimeType: \"audio/wav\") }, to: uploadUrl, method: .post, headers: headers).responseJSON { (response) in switch response.result { case .success(let value): print(value) case .failure(let error): print(\"error: \\(error)\") } } } ","date":"2023-04-23","objectID":"/ios-recorder/:4:0","tags":["iOS","AVFoundation"],"title":"iOS录音功能","uri":"/ios-recorder/"},{"categories":["工具"],"content":"收集一些AI生产力工具，方便自己和大家使用。","date":"2023-04-14","objectID":"/ai/","tags":["AI"],"title":"AI生产力工具","uri":"/ai/"},{"categories":["工具"],"content":"AI语言 【Poe】(chatgpt-4部分收费其他免费) ","date":"2023-04-14","objectID":"/ai/:1:0","tags":["AI"],"title":"AI生产力工具","uri":"/ai/"},{"categories":["工具"],"content":"AI编程 【Copilot】(收费) ","date":"2023-04-14","objectID":"/ai/:2:0","tags":["AI"],"title":"AI生产力工具","uri":"/ai/"},{"categories":["工具"],"content":"AI抠图 【lama-cleaner】(开源)","date":"2023-04-14","objectID":"/ai/:3:0","tags":["AI"],"title":"AI生产力工具","uri":"/ai/"},{"categories":["移动端"],"content":"前言 记录Xcode等相关的问题 ","date":"2023-04-03","objectID":"/xocde14.3-error/:1:0","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["移动端"],"content":"Xcode14.3 报错 ","date":"2023-04-03","objectID":"/xocde14.3-error/:2:0","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["移动端"],"content":"更新后先重置下pod文件 在podfile文件中增加如下: post_install do |installer| installer.generated_projects.each do |project| project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '11.0' end end end end 然后依次执行: pod deintegrate pod install 编译看是否报错? 其他报错看下面继续: ","date":"2023-04-03","objectID":"/xocde14.3-error/:2:1","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["移动端"],"content":"Xcode14.3 编译报错(手动修改为11.0) pod第三方库的支持版本改为11.0以上 设置版本 ","date":"2023-04-03","objectID":"/xocde14.3-error/:2:2","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["移动端"],"content":"Xcode14.3 打包报错command phasescriptexecution failed with a nonzero exit code 如图脚本文件增加 -f 示例 更新: 新版本cocoapods已修复此问题, 无需手动修改 ","date":"2023-04-03","objectID":"/xocde14.3-error/:2:3","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["移动端"],"content":"iOS13系统闪退问题 最新发现, 已退回14.2 , 坑! 崩溃日志: Date/Time: 2023-04-06 10:25:29.5699 +0800 Launch Time: 2023-04-06 10:25:29.5246 +0800 OS Version: iPhone OS 13.7 (17H35) Release Type: User Baseband Version: 7.70.01 Report Version: 104 Exception Type: EXC_CRASH (SIGABRT) Exception Codes: 0x0000000000000000, 0x0000000000000000 Exception Note: EXC_CORPSE_NOTIFY Termination Description: DYLD, Assertion failed: (gotLocation), function applyFixupsToImage_block_invoke_3, file /Library/Caches/com.apple.xbs/Sources/dyld/dyld-750.4.2/dyld3/Loading.cpp, line 779. Highlighted by Thread: 0 Backtrace not available Unknown thread crashed with ARM Thread State (64-bit): x0: 0x0000000000000006 x1: 0x0000000000000009 x2: 0x000000016d117e70 x3: 0x0000000000000014 x4: 0x000000016d117a70 x5: 0x0000000000000000 x6: 0x000000016d1187f0 x7: 0x000000016d118908 x8: 0x0000000000000020 x9: 0x0000000000000009 x10: 0x2e342e3035372d64 x11: 0x2f33646c79642f32 x12: 0x2f33646c79642f32 x13: 0x2e676e6964616f4c x14: 0x6e696c202c707063 x15: 0x000a2e3937372065 x16: 0x0000000000000209 x17: 0x0000000000000000 x18: 0x0000000000000000 x19: 0x0000000000000000 x20: 0x000000016d117a70 x21: 0x0000000000000014 x22: 0x000000016d117e70 x23: 0x0000000000000009 x24: 0x0000000000000006 x25: 0x0000000000000392 x26: 0x000000000000030a x27: 0x000000010758ac70 x28: 0x0000000000117cf0 fp: 0x000000016d117a40 lr: 0x000000010784fee8 sp: 0x000000016d117a00 pc: 0x0000000107848f68 cpsr: 0x40000000 esr: 0x00000000 Address size fault Binary images description not available Error Formulating Crash Report: Failed to create CSSymbolicatorRef - corpse still valid ¯\\_(ツ)_/¯ EOF ","date":"2023-04-03","objectID":"/xocde14.3-error/:2:4","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["工具"],"content":"前言 习惯了用MAC电脑进行工作开发,搬砖的辅助生产工具也是必不可少,根据自己的经验分享一些常用的软件或者技巧,提升开发效率. ","date":"2023-03-16","objectID":"/mac-environment/:1:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"终端 【iterm2】 ","date":"2023-03-16","objectID":"/mac-environment/:2:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"iterm2快捷键 快捷键组合 说明 ctrl + a 到行首 ctrl + e 行末 ctrl + u 删除一行 ⌘ + r（ctrl + l） 清屏，其实是滚到新的一屏，并没有清空。 ctrl + r 搜索命令历史，这个大家都应该很熟悉了 ctrl + d 删除当前字符 ctrl + h 删除之前的字符 ctrl + w 删除光标前的单词 ctrl + k 删除到文本末尾 ctrl + t 交换光标处文本 ⌘ + —/+/0 调整字体大小 ctrl + f/b 前进后退，相当于左右方向键，但是显然比移开手按方向键更快 ctrl + p 上一条命令，相当于方向键上 ","date":"2023-03-16","objectID":"/mac-environment/:2:1","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"窗口操作 新建窗口： shift + command + d（横向）command + d（竖向） 关闭窗口： shift + command + w 前一个窗口： command + ` 后一个窗口： command + ~ 进入窗口 1,2,3： option + command + 编号 ","date":"2023-03-16","objectID":"/mac-environment/:2:2","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"标签页操作 新建标签页: Command + T 关闭标签页: Command + W 前一个标签页: Command + 左方向键，Shift + Command + [ 后一个标签页: Command + 右方向键，Shitf + Command + ] 进入标签页1，2，3…: Command + 标签页编号 Expose 标签页: Option + Command + E（将标签页打撒到全屏，并可以全局搜索所有的标签页） ","date":"2023-03-16","objectID":"/mac-environment/:2:3","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"面板操作 垂直分割: Command + D 水平分割: Shift + Command + D 前一个面板: Command + [ 后一个面板: Command + ] 切换到上/下/左/右面板: Option + Command + 上下左右方向键 ","date":"2023-03-16","objectID":"/mac-environment/:2:4","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"tree brew install tree tree ","date":"2023-03-16","objectID":"/mac-environment/:3:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"oh-my-zsh curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 打开 .zshrc文件 修改插件配置(自带插件) plugins=(colored-man-pages pod git git-flow ruby gem python pip node npm bower sublime) ","date":"2023-03-16","objectID":"/mac-environment/:4:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"新增其他插件,比如zsh-syntax-highlighting高亮插件 cd ~/.oh-my-zsh/custom/plugins git clone https://github.com/zsh-users/zsh-syntax-highlighting.git 再次修改.zshrc文件插件配置 在sublime后面加上zsh-syntax-highlighting 然后执行 source ~/.zshrc 比如执行 pod install pod install ","date":"2023-03-16","objectID":"/mac-environment/:4:1","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"Go2Shell 快捷打开当前文件路径的终端,并且支持iterm2 【官网】 效果如下: Go2Shell ","date":"2023-03-16","objectID":"/mac-environment/:5:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"Xcodes 【Xcodes】 非常方便的管理Xcode的工具,优点: 不必等苹果商店更新 可安装测试版本 多版本安装 下载快,不会卡99% Xcodes ","date":"2023-03-16","objectID":"/mac-environment/:6:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"MAC自带邮箱增加QQ邮箱 首先登录网页端QQ邮箱,然后到设置中生成授权码,在mac中添加QQ邮箱时密码填授权码即可. 授权码 ","date":"2023-03-16","objectID":"/mac-environment/:7:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"超级右键lite 超级右键 ","date":"2023-03-16","objectID":"/mac-environment/:8:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"Snipaste 超好用的截图贴板工具 【Snipaste】 snipaste ","date":"2023-03-16","objectID":"/mac-environment/:9:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"抓包工具 Windows平台有finder Mac平台有Charles 都是比较常用的,因为我是mac刚开始用的也是Charles,但是因为公司路由器等原因,经常性的无法抓包,这里分享另一个开源工具 【Whistle】 ","date":"2023-03-16","objectID":"/mac-environment/:10:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"1.安装 npm install -g whistle ","date":"2023-03-16","objectID":"/mac-environment/:10:1","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"2.启动 w2 start 默认是8899端口,如果需要修改端口,可以在启动命令后面加上端口号,比如 w2 start -p 8888 启动之后可以在浏览器中输入终端提示链接打开抓包工具 启动 ","date":"2023-03-16","objectID":"/mac-environment/:10:2","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"3.停止 w2 stop ","date":"2023-03-16","objectID":"/mac-environment/:10:3","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"3.手机配置 手机连接电脑,打开wifi,选择电脑的wifi 手机设置代理,代理地址填写电脑的ip地址,端口号填写8899 手机用safari输入rootca.pro下载证书,安装证书,也可以到网页设置页面扫码安装如下图 到手机的设置中,找到通用-\u003e关于本机-\u003e证书信任设置,找到刚才安装的证书,打开信任开关 电脑打开http://localhost:8899/点击左侧network-\u003eenable开启抓包 扫码安装证书 抓包 技巧 如果证书配置成功,但是抓包不成功,并且网络也正常,但是手机却无法访问网络,这时候可以尝试关闭电脑的wifi,然后再打开,这样手机就可以访问网络了 ","date":"2023-03-16","objectID":"/mac-environment/:10:4","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"4.mock数据 mock数据 ","date":"2023-03-16","objectID":"/mac-environment/:10:5","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"markdown工具 ","date":"2023-03-16","objectID":"/mac-environment/:11:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"Typora 【Typora】 优点: 支持实时预览 支持导出多种格式 图片资源管理,解决了markdown图片资源管理的痛点 ","date":"2023-03-16","objectID":"/mac-environment/:11:1","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["移动端"],"content":"前言 在阅读Telegram源码的过程中,抽出业务代码,留下有用的代码,同时也修改或总结一些自己遇到的好用的方法. ","date":"2023-02-21","objectID":"/string-extension/:1:0","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"货币字符串 ","date":"2023-02-21","objectID":"/string-extension/:2:0","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"数字格式化 去除其他字符,只留数字 public func numeralFormat() -\u003e String { return replacingOccurrences(of:\"[^0-9]\", with: \"\", options: .regularExpression) } ","date":"2023-02-21","objectID":"/string-extension/:2:1","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"判断是否是表示0的字符串 比如 “0”,“0.0” 字符串表示的值都是0 public var representsZero: Bool { return numeralFormat().replacingOccurrences(of: \"0\", with: \"\").count == 0 } ","date":"2023-02-21","objectID":"/string-extension/:2:2","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"是否包含数字 public var hasNumbers: Bool { return numeralFormat().count \u003e 0 } ","date":"2023-02-21","objectID":"/string-extension/:2:3","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"字符串最后的索引到最后一个数字的偏移 从结束索引到字符串最后一个数字之后的索引的偏移量。 例如，对于字符串\"123some\"，最后一个数字位置是4，因为从字符串结束索引到3的索引 偏移量为4，“e, m, o and s” public var lastNumberOffsetFromEnd: Int? { guard let indexOfLastNumber = lastIndex(where: { $0.isNumber }) else { return nil } let indexAfterLastNumber = index(after: indexOfLastNumber) return distance(from: endIndex, to: indexAfterLastNumber) } ","date":"2023-02-21","objectID":"/string-extension/:2:4","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"更新货币字符串的十进制分隔符位置 decimalDigits:货币格式化字符串的小数位数 mutating public func updateDecimalSeparator(decimalDigits: Int) { guard decimalDigits != 0 \u0026\u0026 count \u003e= decimalDigits else { return } let decimalsRange = index(endIndex, offsetBy: -decimalDigits)..\u003cendIndex let decimalChars = self[decimalsRange] replaceSubrange(decimalsRange, with: \".\" + decimalChars) } ","date":"2023-02-21","objectID":"/string-extension/:2:5","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"补齐字符串 ","date":"2023-02-21","objectID":"/string-extension/:3:0","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"十六进制对齐 右对齐 func rightJustified(width: Int, pad: String = \" \", truncate: Bool = false) -\u003e String { guard width \u003e count else { return truncate ? String(suffix(width)) : self } return String(repeating: pad, count: width - count) + self } 左对齐 func leftJustified(width: Int, pad: String = \" \", truncate: Bool = false) -\u003e String { guard width \u003e count else { return truncate ? String(prefix(width)) : self } return self + String(repeating: pad, count: width - count) } 例如联动 Color的十六进制字符串 以黑色(#000000)为例: String(UIColor.black.rgb, radix: 16) // print 0 String(UIColor.black.rgb, radix: 16, uppercase: false).rightJustified(width: 6,pad: \"0\") // print 000000 ","date":"2023-02-21","objectID":"/string-extension/:3:1","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":[],"content":"脚本配置Xray 配置xray ","date":"2023-02-15","objectID":"/tools/:1:0","tags":[],"title":"工具","uri":"/tools/"},{"categories":["移动端"],"content":"UIColor的一些功能扩展,获取属性值以及初始化等方法","date":"2023-02-02","objectID":"/uicolor-extension/","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"前言 在阅读Telegram源码的过程中,抽出业务代码,留下有用的代码,同时也修改或总结一些自己遇到的好用的方法. ","date":"2023-02-02","objectID":"/uicolor-extension/:1:0","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"颜色 wiki 红绿蓝三原色 (RGB) 发光的媒体（比如电视机）使用红、绿 和蓝加色的三元色，每种光尽可能只刺激针对它们的锥状细胞而不刺激其它的锥状细胞。这个系统的色域占人可以感受到的色彩空间的大部分，因此电视机和电脑萤幕使用这个系统。 理论上我们也可以使用其他颜色作为元色，但使用红、绿和蓝我们可以最大地达到人的色彩空间。遗憾的是对于红、绿和蓝色没有固定的波长的定义，因此不同的技术仪器可能使用不同的波长从而在萤幕上产生稍微不同的颜色。 色相、色度和明度系统 (HSB) 在制作计算机图像时人们往往使用另一种颜色系统。这个颜色系统使用三项分类，分别叫做色相（hue）、色度（saturation）和明度（brightness）的系数。色调决定到底哪一种颜色被使用，色度决定颜色的纯度，亮度决定颜色的明暗程度 参考wiki ","date":"2023-02-02","objectID":"/uicolor-extension/:2:0","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"UIColor初始化扩展 rgb argb hex数值或者字符串颜色值的初始化 convenience init(rgb: UInt64) { self.init(red: CGFloat((rgb \u003e\u003e 16) \u0026 0xff) / 255.0, green: CGFloat((rgb \u003e\u003e 8) \u0026 0xff) / 255.0, blue: CGFloat(rgb \u0026 0xff) / 255.0, alpha: 1.0) } convenience init(rgb: UInt64, alpha: CGFloat) { self.init(red: CGFloat((rgb \u003e\u003e 16) \u0026 0xff) / 255.0, green: CGFloat((rgb \u003e\u003e 8) \u0026 0xff) / 255.0, blue: CGFloat(rgb \u0026 0xff) / 255.0, alpha: alpha) } convenience init(argb: UInt64) { self.init(red: CGFloat((argb \u003e\u003e 16) \u0026 0xff) / 255.0, green: CGFloat((argb \u003e\u003e 8) \u0026 0xff) / 255.0, blue: CGFloat(argb \u0026 0xff) / 255.0, alpha: CGFloat((argb \u003e\u003e 24) \u0026 0xff) / 255.0) } convenience init?(hex: String) { let scanner = Scanner(string: hex) if hex.hasPrefix(\"#\") { scanner.scanLocation = 1 } var value: UInt64 = 0 if scanner.scanHexInt64(\u0026value) { if hex.count \u003e 7 { self.init(argb: value) } else { self.init(rgb: value) } } else { return nil } } 位移运算 左移:\u003c\u003c,右移:\u003e\u003e 对一个数进行按位左移或按位右移，相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位，等价于将这个数乘以 2，同样地，将一个整数右移一位，等价于将这个数除以 2。 十六进制一个字符4位,例如 #AABBCC AA代表红,BB代表绿,CC代表蓝,三个值分别都以255为基数,要得到AA的值,可以按位与\u00260xFF0000 取反再右移16位的到0xAA即十进制170. ","date":"2023-02-02","objectID":"/uicolor-extension/:3:0","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"属性扩展 ","date":"2023-02-02","objectID":"/uicolor-extension/:4:0","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"alpha透明度 var alpha: CGFloat { var alpha: CGFloat = 0.0 if self.getRed(nil, green: nil, blue: nil, alpha: \u0026alpha) { return alpha } else if self.getWhite(nil, alpha: \u0026alpha) { return alpha } else { return 0.0 } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:1","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"RGB值 var rgb: UInt64 { var red: CGFloat = 0.0 var green: CGFloat = 0.0 var blue: CGFloat = 0.0 if self.getRed(\u0026red, green: \u0026green, blue: \u0026blue, alpha: nil) { return (UInt64(max(0.0, red) * 255.0) \u003c\u003c 16) | (UInt64(max(0.0, green) * 255.0) \u003c\u003c 8) | (UInt64(max(0.0, blue) * 255.0)) } else if self.getWhite(\u0026red, alpha: nil) { return (UInt64(max(0.0, red) * 255.0) \u003c\u003c 16) | (UInt64(max(0.0, red) * 255.0) \u003c\u003c 8) | (UInt64(max(0.0, red) * 255.0)) } else { return 0 } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:2","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"ARGB值 var argb: UInt64 { var red: CGFloat = 0.0 var green: CGFloat = 0.0 var blue: CGFloat = 0.0 var alpha: CGFloat = 0.0 if self.getRed(\u0026red, green: \u0026green, blue: \u0026blue, alpha: \u0026alpha) { return (UInt64(alpha * 255.0) \u003c\u003c 24) | (UInt64(max(0.0, red) * 255.0) \u003c\u003c 16) | (UInt64(max(0.0, green) * 255.0) \u003c\u003c 8) | (UInt64(max(0.0, blue) * 255.0)) } else if self.getWhite(\u0026red, alpha: \u0026alpha) { return (UInt64(max(0.0, alpha) * 255.0) \u003c\u003c 24) | (UInt64(max(0.0, red) * 255.0) \u003c\u003c 16) | (UInt64(max(0.0, red) * 255.0) \u003c\u003c 8) | (UInt64(max(0.0, red) * 255.0)) } else { return 0 } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:3","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"HSB值 var hsb: (h: CGFloat, s: CGFloat, b: CGFloat) { var hue: CGFloat = 0.0 var saturation: CGFloat = 0.0 var brightness: CGFloat = 0.0 if self.getHue(\u0026hue, saturation: \u0026saturation, brightness: \u0026brightness, alpha: nil) { return (hue, saturation, brightness) } else { return (0.0, 0.0, 0.0) } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:4","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"明度值 var lightness: CGFloat { var red: CGFloat = 0.0 var green: CGFloat = 0.0 var blue: CGFloat = 0.0 if self.getRed(\u0026red, green: \u0026green, blue: \u0026blue, alpha: nil) { return 0.2126 * red + 0.7152 * green + 0.0722 * blue } else if self.getWhite(\u0026red, alpha: nil) { return red } else { return 0.0 } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:5","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"HEX字符串 var hexString: String { return String(rgb, radix: 16, uppercase: false).rightJustified(width: 6, pad: \"0\") } rightJustified extension String { func rightJustified(width: Int, pad: String = \" \", truncate: Bool = false) -\u003e String { guard width \u003e count else { return truncate ? String(suffix(width)) : self } return String(repeating: pad, count: width - count) + self } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:6","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"方法扩展 ","date":"2023-02-02","objectID":"/uicolor-extension/:5:0","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"改变亮度明度(根据传入系数使亮度明度乘积得到新颜色) func withMultipliedBrightnessBy(_ factor: CGFloat) -\u003e UIColor { var hue: CGFloat = 0.0 var saturation: CGFloat = 0.0 var brightness: CGFloat = 0.0 var alpha: CGFloat = 0.0 self.getHue(\u0026hue, saturation: \u0026saturation, brightness: \u0026brightness, alpha: \u0026alpha) return UIColor(hue: hue, saturation: saturation, brightness: max(0.0, min(1.0, brightness * factor)), alpha: alpha) } 如下调整.red红色亮度比例从左到右分别为0.3,0.6,1(不改变) override func viewDidLoad() { super.viewDidLoad() let bgView1 = UIView(frame: CGRectMake(17, 100, 100, 100)) bgView1.backgroundColor = .red.withMultipliedBrightnessBy(0.3) self.view.addSubview(bgView1) let bgView2 = UIView(frame: CGRectMake(127, 100, 100, 100)) bgView2.backgroundColor = .red.withMultipliedBrightnessBy(0.6) self.view.addSubview(bgView2) let bgView3 = UIView(frame: CGRectMake(237, 100, 100, 100)) bgView3.backgroundColor = .red.withMultipliedBrightnessBy(1) self.view.addSubview(bgView3) } withMultipliedBrightnessBy ","date":"2023-02-02","objectID":"/uicolor-extension/:5:1","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"改变HSB值 func withMultiplied(hue: CGFloat, saturation: CGFloat, brightness: CGFloat) -\u003e UIColor { var hueValue: CGFloat = 0.0 var saturationValue: CGFloat = 0.0 var brightnessValue: CGFloat = 0.0 var alphaValue: CGFloat = 0.0 self.getHue(\u0026hueValue, saturation: \u0026saturationValue, brightness: \u0026brightnessValue, alpha: \u0026alphaValue) return UIColor(hue: max(0.0, min(1.0, hueValue * hue)), saturation: max(0.0, min(1.0, saturationValue * saturation)), brightness: max(0.0, min(1.0, brightnessValue * brightness)), alpha: alphaValue) } 如下调整.red颜色HSB值 private func setupViews2() { let bgView1 = UIView(frame: CGRectMake(17, 100, 100, 100)) bgView1.backgroundColor = .red.withMultiplied(hue: 1.034, saturation: 0.819, brightness: 0.633) self.view.addSubview(bgView1) let bgView2 = UIView(frame: CGRectMake(127, 100, 100, 100)) bgView2.backgroundColor = .red.withMultiplied(hue: 1.029, saturation: 0.77, brightness: 0.332) self.view.addSubview(bgView2) let bgView3 = UIView(frame: CGRectMake(237, 100, 100, 100)) bgView3.backgroundColor = .red.withMultiplied(hue: 1.034, saturation: 0.583, brightness: 1.234) self.view.addSubview(bgView3) } withMultiplied ","date":"2023-02-02","objectID":"/uicolor-extension/:5:2","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"混合颜色(alpha合成) 说明 RGB混合算法目前在常用到的算法是AlphaBlend. 计算公式如下:假设一幅图象是A，另一幅透明的图象是B，那么透过B去看A，看上去的图象C就是B和A的混合图象，设B图象的透明度为alpha(取值为0-1，1为完全透明，0为完全不透明). Alpha混合公式如下： R(C)=(1-alpha)*R(B) + alpha*R(A) G(C)=(1-alpha)*G(B) + alpha*G(A) B(C)=(1-alpha)*B(B) + alpha*B(A) R(x)、G(x)、B(x)分别指颜色x的RGB分量原色值。从上面的公式可以知道，Alpha其实是一个决定混合透明度的数值。 这里只对B图的Alpha进行了处理，但A图本身如果也有透明通道的，也需要进行一样的处理，即 A(C)=(1-alpha)*A(B) + alpha*A(A) 【验证链接】 【wiki】 【参考链接】 mixedWith func mixedWith(_ other: UIColor, alpha: CGFloat) -\u003e UIColor { let alpha = min(1.0, max(0.0, alpha)) let oneMinusAlpha = 1.0 - alpha var r1: CGFloat = 0.0 var r2: CGFloat = 0.0 var g1: CGFloat = 0.0 var g2: CGFloat = 0.0 var b1: CGFloat = 0.0 var b2: CGFloat = 0.0 var a1: CGFloat = 0.0 var a2: CGFloat = 0.0 if self.getRed(\u0026r1, green: \u0026g1, blue: \u0026b1, alpha: \u0026a1) \u0026\u0026 other.getRed(\u0026r2, green: \u0026g2, blue: \u0026b2, alpha: \u0026a2) { let r = r1 * oneMinusAlpha + r2 * alpha let g = g1 * oneMinusAlpha + g2 * alpha let b = b1 * oneMinusAlpha + b2 * alpha let a = a1 * oneMinusAlpha + a2 * alpha return UIColor(red: r, green: g, blue: b, alpha: a) } return self } 示例如下将0.5透明度的黄色覆盖到红色上面,透过上面的黄色看下面的红色,得到的颜色: private func setupViews3() { let bgView1 = UIView(frame: CGRectMake(17, 100, 100, 100)) bgView1.backgroundColor = .red self.view.addSubview(bgView1) let bgView2 = UIView(frame: CGRectMake(127, 100, 100, 100)) bgView2.backgroundColor = .yellow self.view.addSubview(bgView2) let bgView3 = UIView(frame: CGRectMake(237, 100, 100, 100)) bgView3.backgroundColor = .red.mixedWith(.yellow, alpha: 0.5) self.view.addSubview(bgView3) } mixedWith blitOver 和上面的mixedWith方法相反,表示覆盖到另一个颜色上面作为前景色. func blitOver(_ other: UIColor, alpha: CGFloat) -\u003e UIColor { let alpha = min(1.0, max(0.0, alpha)) var r1: CGFloat = 0.0 var r2: CGFloat = 0.0 var g1: CGFloat = 0.0 var g2: CGFloat = 0.0 var b1: CGFloat = 0.0 var b2: CGFloat = 0.0 var a1: CGFloat = 0.0 var a2: CGFloat = 0.0 if self.getRed(\u0026r1, green: \u0026g1, blue: \u0026b1, alpha: \u0026a1) \u0026\u0026 other.getRed(\u0026r2, green: \u0026g2, blue: \u0026b2, alpha: \u0026a2) { let resultingAlpha = max(0.0, min(1.0, alpha * a1)) let oneMinusResultingAlpha = 1.0 - resultingAlpha let r = r1 * resultingAlpha + r2 * oneMinusResultingAlpha let g = g1 * resultingAlpha + g2 * oneMinusResultingAlpha let b = b1 * resultingAlpha + b2 * oneMinusResultingAlpha let a: CGFloat = 1.0 return UIColor(red: r, green: g, blue: b, alpha: a) } return self } ","date":"2023-02-02","objectID":"/uicolor-extension/:5:3","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"调整透明度倍数 func withMultipliedAlpha(_ alpha: CGFloat) -\u003e UIColor { var r1: CGFloat = 0.0 var g1: CGFloat = 0.0 var b1: CGFloat = 0.0 var a1: CGFloat = 0.0 if self.getRed(\u0026r1, green: \u0026g1, blue: \u0026b1, alpha: \u0026a1) { return UIColor(red: r1, green: g1, blue: b1, alpha: max(0.0, min(1.0, a1 * alpha))) } return self } ","date":"2023-02-02","objectID":"/uicolor-extension/:5:4","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"篡改一个颜色到另一个颜色 说明 fraction取值范围为0~1,当为0时,返回当前颜色,当为1时,返回传入颜色. 从0到1的变化既是当前颜色到传入颜色的变化. func interpolateTo(_ color: UIColor, fraction: CGFloat) -\u003e UIColor? { let f = min(max(0, fraction), 1) var r1: CGFloat = 0.0 var r2: CGFloat = 0.0 var g1: CGFloat = 0.0 var g2: CGFloat = 0.0 var b1: CGFloat = 0.0 var b2: CGFloat = 0.0 var a1: CGFloat = 0.0 var a2: CGFloat = 0.0 if self.getRed(\u0026r1, green: \u0026g1, blue: \u0026b1, alpha: \u0026a1) \u0026\u0026 color.getRed(\u0026r2, green: \u0026g2, blue: \u0026b2, alpha: \u0026a2) { let r: CGFloat = CGFloat(r1 + (r2 - r1) * f) let g: CGFloat = CGFloat(g1 + (g2 - g1) * f) let b: CGFloat = CGFloat(b1 + (b2 - b1) * f) let a: CGFloat = CGFloat(a1 + (a2 - a1) * f) return UIColor(red: r, green: g, blue: b, alpha: a) } else { return self } } ","date":"2023-02-02","objectID":"/uicolor-extension/:5:5","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"欧氏距离 说明 很多日常使用的“颜色差异”，是直接通过在一个“设备无关”的色彩空间里，进行欧氏距离的计算得到的。给定一个RGB（红绿蓝）的色彩空间，最简单的差异计算方式就是在这个三维空间里求两个点间的距离. 有不少人尝试将RGB三值加上权重，希望可以让得到的结果更加符合人类感官。一种做法是使用2、4、3： 【wiki】 private var colorComponents: (r: Int64, g: Int64, b: Int64) { var r: CGFloat = 0.0 var g: CGFloat = 0.0 var b: CGFloat = 0.0 if self.getRed(\u0026r, green: \u0026g, blue: \u0026b, alpha: nil) { return (Int64(max(0.0, r) * 255.0), Int64(max(0.0, g) * 255.0), Int64(max(0.0, b) * 255.0)) } else if self.getWhite(\u0026r, alpha: nil) { return (Int64(max(0.0, r) * 255.0), Int64(max(0.0, r) * 255.0), Int64(max(0.0, r) * 255.0)) } return (0, 0, 0) } func distance(to other: UIColor) -\u003e Int64 { let e1 = self.colorComponents let e2 = other.colorComponents let rMean = (e1.r + e2.r) / 2 let r = e1.r - e2.r let g = e1.g - e2.g let b = e1.b - e2.b let a1 = ((512 + rMean) * r * r) \u003e\u003e 8 let b1 = 4 * g * g let c1 = ((767 - rMean) * b * b) \u003e\u003e 8 return a1 + b1 + c1 } ","date":"2023-02-02","objectID":"/uicolor-extension/:5:6","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"平均颜色 static func average(of colors: [UIColor]) -\u003e UIColor { var sr: CGFloat = 0.0 var sg: CGFloat = 0.0 var sb: CGFloat = 0.0 var sa: CGFloat = 0.0 for color in colors { var r: CGFloat = 0.0 var g: CGFloat = 0.0 var b: CGFloat = 0.0 var a: CGFloat = 0.0 color.getRed(\u0026r, green: \u0026g, blue: \u0026b, alpha: \u0026a) sr += r sg += g sb += b sa += a } return UIColor(red: sr / CGFloat(colors.count), green: sg / CGFloat(colors.count), blue: sb / CGFloat(colors.count), alpha: sa / CGFloat(colors.count)) } ","date":"2023-02-02","objectID":"/uicolor-extension/:5:7","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"Swift中的只读属性,像OC一样隐藏set方法","date":"2023-02-01","objectID":"/swift-readonly/","tags":["iOS只读","Swift","OC"],"title":"iOS中的只读属性","uri":"/swift-readonly/"},{"categories":["移动端"],"content":"OC只读,Swift设置set私有private(set) public private(set) var someKey: String 当外部调用set方法时的报错信息: Cannot assign to property: 'somekey' setter is inaccessible OC表示只读readonly: @property (nonatomic, strong, readonly) NSString *someKey; ","date":"2023-02-01","objectID":"/swift-readonly/:1:0","tags":["iOS只读","Swift","OC"],"title":"iOS中的只读属性","uri":"/swift-readonly/"},{"categories":["移动端"],"content":"Telegram开源iOS端代码编译学习记录","date":"2023-01-28","objectID":"/telegram/","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"前言 Telegram开源IM应用,虽然服务器代码不开源,但是可以从客户端的体验来看非常流畅,故下载编译学习记录. ","date":"2023-01-28","objectID":"/telegram/:1:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"创建应用(只编译Xcode工程此步骤不需要看) 打开官网,选择API development tools API development tools 填写自己的电报号码登录,验证码为官方TG给你发条验证消息: TG账号登录 选择API,Getting started下面的Creating an application Creating an application 然后在表单页面填写应用信息,如App名称等,最后提交即可. 注意 如果提交的时候出现报错Error,需要科学上网(全局模式). 生成的应用示例: 示例 ","date":"2023-01-28","objectID":"/telegram/:2:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"源码下载 iOS地址 git clone --recursive -j8 https://github.com/TelegramMessenger/Telegram-iOS.git 提醒 此处加参数是为了拉取子模块,子模块要拉取完整后续才能编译成功. ","date":"2023-01-28","objectID":"/telegram/:3:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"环境设置 打开下载的项目文件夹,找到versions.json文件,并打开: { \"app\": \"9.3\", \"bazel\": \"5.3.1\", \"xcode\": \"14.1\" } 确认到环境为Xcode为14.1版本,bazel要求5.3.1 由于我已经安装Xcode14.2版本,所以这里编辑Xcode版本号为当前电脑已安装Xcode版本. 安装bazel: brew install bazel XXX(版本号) 如果提示没有版本号,可以去官网直接看文档下载安装. 如果你是第一次安装bazel到此环境问题就解决了,安装过的看下面👇🏻 由于bazel我是之前已经安装过(通过homebrew安装),默认为最新版本,需要切换为配置文件版本,不然后续编译会报错 brew tap bazelbuild/tap brew extract bazel bazelbuild/tap --version 5.3.2 brew install bazel@5.3.2 注意 当我执行如上发现brew并没有5.3.1版本,找到历史版本,发现比较接近的有5.3.2,将版本号修改并执行指令(versions.json文件中也修改一致,但是bazel版本不能和官方相差太大,会报错). 如果和我一样之前已经安装了新版本,需要链接到下载的旧版本: brew install bazelbuild/tap/bazel@5.3.2 brew link bazel@5.3.2 ","date":"2023-01-28","objectID":"/telegram/:4:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"编译Xcode工程 复制配置到电脑根目录 mkdir -p $HOME/telegram-configuration cp -R build-system/example-configuration/* $HOME/telegram-configuration/ cp -R build-system/appstore-configuration.json $HOME/telegram-configuration/ cp -R build-system/fake-codesigning/profiles $HOME/telegram-configuration/provisioning/ 创建缓存文件夹(可选) mkdir -p \"$HOME/telegram-bazel-cache\" 最终我的电脑根目录下结构如图所示: 目录结构 脚本生成 python3 build-system/Make/Make.py \\ --cacheDir=\"$HOME/telegram-bazel-cache\" \\ generateProject \\ --configurationPath=\"$HOME/telegram-configuration/appstore-configuration.json\" \\ --disableExtensions \\ --codesigningInformationPath=\"$HOME/telegram-configuration/provisioning\" python3 build-system/Make/Make.py –cacheDir=\"$HOME/telegram-bazel-cache\" generateProject –configurationPath=\"$HOME/telegram-configuration/appstore-configuration.json\" –codesigningInformationPath=\"$HOME/telegram-configuration/provisioning\" 到此Xcode工程成功生成,友情提示代码注释几乎没有… ","date":"2023-01-28","objectID":"/telegram/:5:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"真机运行问题 打开app,白屏或者黑屏,原因是app-group 没有添加,在Xcode工程配置上添加自己设置好的即可. ","date":"2023-01-28","objectID":"/telegram/:6:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"打包 打开HOME/telegram-configuration/路径下的variables.bzl(就是上一步复制到电脑根目录的配置文件的路径),原配置如下: telegram_bundle_id = \"ph.telegra.Telegraph\" telegram_api_id = \"8\" telegram_api_hash = \"7245de8e747a0d6fbe11f7cc14fcc0bb\" telegram_team_id = \"C67CF9S4VU\" telegram_app_center_id = \"0\" telegram_is_internal_build = \"false\" telegram_is_appstore_build = \"true\" telegram_appstore_id = \"686449807\" telegram_app_specific_url_scheme = \"tg\" telegram_premium_iap_product_id = \"org.telegram.telegramPremium.monthly\" telegram_aps_environment = \"production\" telegram_enable_siri = True telegram_enable_icloud = True telegram_enable_watch = True 待施工. 还没有进行打包. ","date":"2023-01-28","objectID":"/telegram/:7:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"主要记录Xcode使用遇到的一些问题","date":"2023-01-17","objectID":"/xcode-question/","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"前言 本文主要记录Xcode使用遇到的一些问题,以及当时版本的解决方案. ","date":"2023-01-17","objectID":"/xcode-question/:1:0","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"Xcode下载 主要有两种途径: ","date":"2023-01-17","objectID":"/xcode-question/:2:0","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"方式1: App Store 苹果商店搜索Xcode即可下载. 优点: 可自动更新. 缺点: 安装的时候经常会遇到最后卡住,或者安装不上等问题. ","date":"2023-01-17","objectID":"/xcode-question/:2:1","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"方式2: 官网下载Xip包 下载地址,登录苹果账号进行下载. 优点: 弥补了方式1的缺点,并且历史版本也可以下载安装. 缺点: 无法自动更新下一个版本. ","date":"2023-01-17","objectID":"/xcode-question/:2:2","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"方式3: 使用Xcodes管理 【Xcodes】 非常方便的管理Xcode的工具,优点: 不必等苹果商店更新 可安装测试版本 多版本安装 下载快,不会卡99% Xcodes ","date":"2023-01-17","objectID":"/xcode-question/:2:3","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"重装Xcode之后,Cocoapods报错问题 ","date":"2023-01-17","objectID":"/xcode-question/:3:0","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"如下报错: /.rvm/rubies/ruby-3.0.0/lib/ruby/gems/3.0.0/gems/cocoapods-1.11.3/lib/cocoapods/command.rb:128:in `git_version': Failed to extract git version from `git --version` (\"xcrun: error: active developer path (\\\\\"/Users/wangzhu/Downloads/Xcode.app/Contents/Developer\\\\\") does not exist\\\\nUse `sudo xcode-select --switch path/to/Xcode.app` to specify the Xcode that you wish to use for command line developer tools, or use `xcode-select --install` to install the standalone command line developer tools.\\\\nSee `man xcode-select` for more details.\\\\n\") (RuntimeError) from /Users/wangzhu/.rvm/rubies/ruby-3.0.0/lib/ruby/gems/3.0.0/gems/cocoapods-1.11.3/lib/cocoapods/command.rb:140:in `verify_minimum_git_version!' from /Users/wangzhu/.rvm/rubies/ruby-3.0.0/lib/ruby/gems/3.0.0/gems/cocoapods-1.11.3/lib/cocoapods/command.rb:49:in `run' from /Users/wangzhu/.rvm/rubies/ruby-3.0.0/lib/ruby/gems/3.0.0/gems/cocoapods-1.11.3/bin/pod:55:in `\u003ctop (required)\u003e' from /usr/local/bin/pod:25:in `load' from /usr/local/bin/pod:25:in `\u003cmain\u003e' from /Users/wangzhu/.rvm/rubies/ruby-3.0.0/bin/ruby_executable_hooks:22:in `eval' from /Users/wangzhu/.rvm/rubies/ruby-3.0.0/bin/ruby_executable_hooks:22:in `\u003cmain\u003e' ","date":"2023-01-17","objectID":"/xcode-question/:3:1","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"解决办法: 1.终端执行下面命令 xcode-select --install admoni 2.然后尝试执行 pod --version 如果正常显示版本号,命令行工具已正常工作,到此解决.如果还是报错看步骤3. 3.到此如果cocoapods还是无法正常使用,执行上面步骤1提示如下: xcode-select: error: command line tools are already installed, use \"Software Update\" in System Settings to install updates 按照提示更新下工具: softwareupdate --install -a 执行步骤2查看版本号正常显示版本,到此解决. ","date":"2023-01-17","objectID":"/xcode-question/:3:2","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"平时在开发中遇到需求或是在社区中发现了一些优秀且实用的iOS相关开源库","date":"2023-01-14","objectID":"/third-party/","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"前言 平时在开发中遇到需求或是在社区中发现了一些优秀且实用的iOS相关开源库时,我会进行记录.这些库涵盖了开发和完整项目应用两方面,并无特定排名.当发现有用的库时,我会立刻进行记录. 说明 本文没有排名，默认状态为维护中。如果停止维护，将会在其上面加上停止维护的提示。根据规则，如果一年及以上没有提交记录，将会判定为停止维护。时间截止以标注记录时间为准。如果你有优秀的库推荐,欢迎评论! ","date":"2023-01-14","objectID":"/third-party/:1:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"完整App ","date":"2023-01-14","objectID":"/third-party/:2:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"框架 名称 简述 语言 记录时间 维护情况 【Texture(AsyncDisplayKit)】 一款异步渲染的UI框架 Swift\u0026OC 2023.01.14 - 【QMUIKit】 是一个致力于提高项目UI开发效率的UI框架 OC 2023.01.14 - ","date":"2023-01-14","objectID":"/third-party/:3:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"UI 名称 简述 语言 记录时间 维护情况 【MJRefresh】 下拉/上拉刷新控件 OC 2023.01.17 - 【DeviceKit】 获取设备信息 Swift 2023.10.30 - ","date":"2023-01-14","objectID":"/third-party/:4:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"多线程 ","date":"2023-01-14","objectID":"/third-party/:5:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"网络 ","date":"2023-01-14","objectID":"/third-party/:6:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"数据存储 ","date":"2023-01-14","objectID":"/third-party/:7:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"动画 ","date":"2023-01-14","objectID":"/third-party/:8:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"多媒体 ","date":"2023-01-14","objectID":"/third-party/:9:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"图像 ","date":"2023-01-14","objectID":"/third-party/:10:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"安全 ","date":"2023-01-14","objectID":"/third-party/:11:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"工具 名称 简述 语言 记录时间 维护情况 ","date":"2023-01-14","objectID":"/third-party/:12:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"测试调试 ","date":"2023-01-14","objectID":"/third-party/:13:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"数据结构/算法","date":"2023-01-14","objectID":"/third-party/:14:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"UITableView使过程中遇到的一些问题记录","date":"2023-01-06","objectID":"/uitableview/","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["移动端"],"content":"UITableView的type ","date":"2023-01-06","objectID":"/uitableview/:1:0","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["移动端"],"content":"UITableView的类型(type) public enum Style : Int, @unchecked Sendable { case plain = 0 // 通用类 case grouped = 1 // 分组模式 @available(iOS 13.0, *) case insetGrouped = 2 // iOS13以后支持的API,给组加圆角,效果如下 } insetGrouped ","date":"2023-01-06","objectID":"/uitableview/:1:1","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["移动端"],"content":"iOS15系统之后type为grouped时,头部有间距 if #available(iOS 15.0, *) { tableView.sectionHeaderTopPadding = 0 } if (@available(iOS 15.0, *)) { _tableView.sectionHeaderTopPadding = 0; } ","date":"2023-01-06","objectID":"/uitableview/:1:2","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["移动端"],"content":"type为grouped时,组间距问题 func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -\u003e CGFloat { return 0 } func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -\u003e UIView? { return UIView() } ","date":"2023-01-06","objectID":"/uitableview/:1:3","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["移动端"],"content":"去除诡异动画 [UIView setAnimationsEnabled:false]; [CATransaction begin]; [CATransaction setCompletionBlock:^{ [UIView setAnimationsEnabled:true]; }]; [self.tableView beginUpdates]; [self.tableView insertRowsAtIndexPaths:addIndexPathes withRowAnimation:UITableViewRowAnimationNone]; [self.tableView endUpdates]; [CATransaction commit]; ","date":"2023-01-06","objectID":"/uitableview/:1:4","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["前端"],"content":"a元素的伪类,link 一般用来表示没有访问过的链接(正常的链接)","date":"2022-12-05","objectID":"/%E5%85%83%E7%B4%A0%E7%9A%84%E4%BC%AA%E7%B1%BB/","tags":["HTML"],"title":"Web学习笔记 - a元素的伪类","uri":"/%E5%85%83%E7%B4%A0%E7%9A%84%E4%BC%AA%E7%B1%BB/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* link 一般用来表示没有访问过的链接(正常的链接) */ a:link { color: red; } /* visited 用来表示访问过的链接 由于隐私的原因,visited这个伪类只能修改链接的颜色. */ a:visited { color: yellow; } /* :hover 用来表示鼠标移入的状态 */ a:hover { color: aqua; font-size: 50px; } /* :active 用来表示鼠标点击 */ a:active { color: blue; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 1.没有访问过的链接 2.访问过的链接 --\u003e \u003ca href=\"https://www.baidu.com\"\u003e访问过的链接\u003c/a\u003e \u003cbr\u003e \u003ca href=\"https://www.baidu.com123\"\u003e没有访问过的链接\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-05","objectID":"/%E5%85%83%E7%B4%A0%E7%9A%84%E4%BC%AA%E7%B1%BB/:0:0","tags":["HTML"],"title":"Web学习笔记 - a元素的伪类","uri":"/%E5%85%83%E7%B4%A0%E7%9A%84%E4%BC%AA%E7%B1%BB/"},{"categories":["前端"],"content":"复合选择器,关系选择器,属性选择器,伪类选择器,伪元素选择器","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"复合选择器 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* 将所有的段落设置为红色(字体) 元素选择器 作用,根据标签名来选中指定的元素 语法:标签名{} 例子:p{} h1{} dic{} */ /* p{ color: red; } h1{ color: red; } */ /* 将`儿童乡间不相识`设置红色 id选择器 作用:根据元素的id属性值选中一个元素 语法:#id属性值{} 例子:#box{} #red{} */ /* #red{ color: red; } */ /* 将`秋水共长天一色`和`落霞与孤鹜齐飞` 设置为红色 类选择器 作用:根据元素的class属性值选中一组元素 语法: .class属性值 例子: .bule .red .abc */ /* .red{ color: red; } .abc{ font-size: 15px; } */ /* 通配选择器 作用:选中页面中的所有元素 语法: * */ *{ color: red; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 class=\"red\"\u003e我是标题\u003c/h1\u003e \u003cp\u003e少小离家老大回\u003c/p\u003e \u003cp\u003e乡音无改鬓毛衰\u003c/p\u003e \u003c!-- 多个类选择时使用空格隔开; --\u003e \u003cp class=\"red abc\"\u003e儿童相见不相识\u003c/p\u003e \u003cp\u003e笑问客从何处来\u003c/p\u003e \u003c!-- class 是一个标签的属性,它和id类似,不同的是class可以重复使用 可以通过class属性来为元素分组 --\u003e \u003cp class=\"red\"\u003e秋水共长天一色\u003c/p\u003e \u003cp\u003e落霞与孤鹜齐飞\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* 将class为red的元素设置为红色(字体) */ .red{ color: red; } /* 将class为red的div字体大小设置为30px */ /* 交集选择器 作用:选中同时符合多个条件的元素 语法:选择器1选择器2选择器3...{} 注意点:交集选择器中如果有元素选择器,必须使用元素选择器开头 */ /* 比如下面就是 元素选择器+类选择器 */ /* 与的关系\u0026 */ div.red{ font-size: 30px; } /* 选择器分组(并集选择器) 作用:同时选择多个选择器对应的元素 语法:选择器1,选择器2...{} */ /* 或的关系|| */ h1,span{ color: blue; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"red\"\u003e我的div\u003c/div\u003e \u003cp class=\"red\"\u003e我是p\u003c/p\u003e \u003ch1 \u003e标题\u003c/h1\u003e \u003cspan \u003e哈哈\u003c/span\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/:1:0","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"关系选择器 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* 为div的子元素span设置一个字体颜色红色 (为div直接包含的span设置一个字体颜色) 子元素选择器 作用: 选中指定父元素的指定子元素 语法: 父元素 \u003e 子元素 */ /* div.box \u003e span { color: red; } */ /* 后代元素选择器: 作用: 选中指定元素内的指定后代元素 语法: 祖先 后代 */ /* div span { color: blue; } */ /* div \u003e p \u003e span { color: orange; } */ /* 选中下一个兄弟 语法: 前一个 + 后一个 (要紧挨着) 选中下边所有的兄弟 语法: 兄 ~ 弟 */ p + span { color: aqua; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 父元素 - 直接包含子元素的元素叫做父元素 子元素 - 直接被父元素包含的元素叫子元素 祖先元素 - 直接或间接包含后代元素的元素叫祖先元素 - 一个元素的父元素也是它的祖先元素 后代元素 - 直接或者间接被祖先元素包含的元素叫做后代元素 - 子元素也是后代元素 兄弟元素 - 拥有相同父元素的元素是兄弟元素 --\u003e \u003cdiv class=\"box\"\u003e我是一个div \u003cp\u003e我的div中的p \u003cspan\u003e 我是p中的span \u003c/span\u003e \u003c/p\u003e \u003cspan\u003e我的div中的span\u003c/span\u003e \u003c/div\u003e \u003cspan\u003e 我是div外的span1 \u003c/span\u003e \u003cp\u003e 我是div外的p \u003c/p\u003e \u003cspan\u003e 我是div外的span2 \u003c/span\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/:2:0","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"属性选择器 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* [属性名] 选择含有指定属性的元素 [属性名=属性值] 选择含有指定属性和属性值的元素 [属性名^=属性值] 选择属性值以指定值开头的元素 [属性名$=属性值] 选择属性值以指定值结尾的元素 [属性名*=属性值] 选择属性值中含有某值的元素 */ /* p[title=abc] { color: orange; } */ /* p[title^=abc]{ color: red; } */ /* p[title$=abc]{ color: orange; } */ p[title*=e]{ color: aqua; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cp title=\"abc\"\u003e少小离家老大回\u003c/p\u003e \u003cp title=\"abcd\"\u003e乡音无改鬓毛衰\u003c/p\u003e \u003cp title=\"adsiaje\"\u003e儿童相见不相识\u003c/p\u003e \u003cp\u003e笑问客从何处来\u003c/p\u003e \u003cp\u003e秋水共长天一色\u003c/p\u003e \u003cp\u003e落霞与孤鹜齐飞\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/:3:0","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"伪类选择器 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e p{ font-size: 20px; } /* 伪元素,表示页面中一些特殊的并不真实的存在的元素(特殊的位置) 伪元素使用 :: 开头 ::first-letter 表示第一个字母 ::first-line 表示第一行 ::selection 表示选中的内容 ::before 表示元素的起始 ::after 表示元素的结束 -before atfer 必须结合content属性来使用 */ p::first-letter { font-size: 50px; } p::first-line { background-color: blue; } p::selection { background-color: yellow; } div::before { content: \"abc\"; color: red; } div::after { content: \"haha\"; color: greenyellow; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cq\u003e hello \u003c/q\u003e \u003cp\u003e 这是一个p标签 \u003c/p\u003e \u003cdiv\u003ehello hello hello\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/:4:0","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"伪元素选择器 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e p{ font-size: 20px; } /* 伪元素,表示页面中一些特殊的并不真实的存在的元素(特殊的位置) 伪元素使用 :: 开头 ::first-letter 表示第一个字母 ::first-line 表示第一行 ::selection 表示选中的内容 ::before 表示元素的起始 ::after 表示元素的结束 -before atfer 必须结合content属性来使用 */ p::first-letter { font-size: 50px; } p::first-line { background-color: blue; } p::selection { background-color: yellow; } div::before { content: \"abc\"; color: red; } div::after { content: \"haha\"; color: greenyellow; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cq\u003e hello \u003c/q\u003e \u003cp\u003e 这是一个p标签 \u003c/p\u003e \u003cdiv\u003ehello hello hello\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/:5:0","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"css用来设置网页中元素的样式","date":"2022-12-04","objectID":"/css%E7%AE%80%E4%BB%8B/","tags":["HTML"],"title":"Web学习笔记 - CSS简介","uri":"/css%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"简介 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c!-- 第二种方式(内部样式表) - 将样式编写到head中的style标签里 然后通过css的选择器来选中元素并为其设置各种样式 可以同时为多个标签设置样式,并且修改时只需修改一处即可全部应用 - 内部样式表更加方便对样式进行复用 - 问题: 我们的内部样式只能对一个网页起作用 它里面的样式不能跨页面复用 --\u003e \u003c!-- \u003cstyle\u003e /* 所有的p元素 */ p{color: red; font-size: 30px;} \u003c/style\u003e --\u003e \u003c!-- 第三种方式(外部样式表) - 可以将CSS样式编写到一个外部的CSS文件中 然后通过link标签来引入外部的css文件 - 外部样式需要通过link标签进行引入 意味着只要想使用这些样式的网页都可以对其使用,使样式可以再不同页面之间进行复用 - 将样式编写到外部的css文件中,可以使用到浏览器的缓存机制 从而加快的网页的加载速度,提高用户的体验 --\u003e \u003clink rel=\"stylesheet\" href=\"./style.css\"\u003e \u003c!-- p{ color: red; font-size: 30px; } --\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 网页分成三个部分: 结构(html) 表现(css) 行为(JavaScript) CSS - 层叠样式表 - 网页实际上是一个多层的结构,通过css可以分别为网页的每一个层来设置样式 而最终我们能看到的至少网页的最上边一层 - 总之一句话,css用来设置网页中元素的样式 --\u003e \u003c!-- 使用css来修改元素的样式 第一种方式(内联样式,或者叫行内样式) - 在标签内部通过style属性来设置元素的样式 - 问题: 使用内联样式,样式只能对一个标签生效 如果希望影响到多个元素必须每个元素复制一遍 并且当样式发送变化时,我们必须一个一个修改 - 注意: 开发时绝对不要使用内联样式 --\u003e \u003c!-- \u003cp style=\"color: red; font-size: 30px;\"\u003e少小离家老大回,乡音无改鬓毛衰\u003c/p\u003e \u003cp style=\"color: red; font-size: 30px;\"\u003e今天天气真不错\u003c/p\u003e --\u003e \u003cp\u003e少小离家老大回,乡音无改鬓毛衰\u003c/p\u003e \u003cp\u003e今天天气真不错\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/css%E7%AE%80%E4%BB%8B/:1:0","tags":["HTML"],"title":"Web学习笔记 - CSS简介","uri":"/css%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"语法 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* CSS中的注释,注释中内容会自动被浏览器忽略 CSS的基本语法: 选择器 声明块 选择器,通过选择器可以选中页面中的指定元素 比如 p 的作用就是选中页面中所有的 p 元素 声明块,通过声明块来指定要为元素设置的样式 声明块由一个一个的声明组成 声明是一个名值对结构 一个样式名对应一个样式值,名和值之间以`:`链接,以`;`结尾 */ p{ color: red; font-size: 30px; } h1{ color: blue; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e我是h1\u003c/h1\u003e \u003cp\u003e今天天气真不错\u003c/p\u003e \u003cp\u003e今天天气真不错\u003c/p\u003e \u003cp\u003e今天天气真不错\u003c/p\u003e \u003cp\u003e今天天气真不错\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/css%E7%AE%80%E4%BB%8B/:2:0","tags":["HTML"],"title":"Web学习笔记 - CSS简介","uri":"/css%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"内联框架,用于向当前页面中引入一个其他页面","date":"2022-12-04","objectID":"/%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6/","tags":["HTML"],"title":"Web学习笔记 - 内联框架","uri":"/%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 内联框架,用于向当前页面中引入一个其他页面 src 指定网页的路径 frameborder 指定内联框架的边框 --\u003e \u003ciframe src=\"https://www.bilibili.com\" width=\"800\" height=\"600\" frameborder=\"0\"\u003e\u003c/iframe\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6/:0:0","tags":["HTML"],"title":"Web学习笔记 - 内联框架","uri":"/%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6/"},{"categories":["前端"],"content":"图片标签用于向当前页面中引入一个外部图片","date":"2022-12-04","objectID":"/%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE/","tags":["HTML"],"title":"Web学习笔记 - 图片标签","uri":"/%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 图片标签用于向当前页面中引入一个外部图片 使用img标签来引入外部图片,img标签是一个自结束标签 img这种元素用于替换元素(基于块和行内元素之间,具有两种元素的特点) 属性: scr 属性指定的是外部图片的路径(路径规则和超链接是一样的) alt 属性是图片的描述,这个描述默认情况下不会显示,有些浏览器无法加载时显示 搜索引擎会根据alt中的内容来识别图片,如果不写alt属性,则图片不会被搜索引擎收录 width 宽度(单位是像素) height 高度 - 如果宽度和高度中只修改了一个,另一个会等比例缩放 注意: 一般情况在pc端,不建议修改图片的大小 但是在移动端,经常需要对图片进行缩放(主要大图缩小) 图片的格式: jpeg(jpg) - 支持的颜色比较丰富,不支持透明效果,不支持动图 - 一般用来显示照片 gif - 支持的颜色比较少,支持简单透明,支持动图 - 适合颜色单一的图片,动图 png - 支持的颜色丰富,支持复杂透明,不支持动图 - 颜色丰富,复杂透明图片(专为网页而生) webp - 这种格式是谷歌新推出的专门用来表示网页中的图片格式 - 它具备其他图片格式所有的优点,而且文件大小特别小 - 缺点,兼容性不好 base64 (不是图片格式) - 将图片使用base64进行编码,这样可以将图片转换为字符,通过字符的形式来引入图片 - 一般都是一些和网页一起加载的图片才会使用base64 效果一样,用小的 效果不一样,用效果好的 --\u003e \u003cimg src=\"./下载.jpeg\" alt=\"京东\"\u003e \u003cbr\u003e \u003cimg src=\"https://img95.699pic.com/photo/50136/1351.jpg_wh300.jpg\" alt=\"美女\"\u003e \u003cbr\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE/:0:0","tags":["HTML"],"title":"Web学习笔记 - 图片标签","uri":"/%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"当我们需要跳转一个服务器内部的页面时,一般我们都会使用相对路径","date":"2022-12-04","objectID":"/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/","tags":["HTML"],"title":"Web学习笔记 - 相对路径","uri":"/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 当我们需要跳转一个服务器内部的页面时,一般我们都会使用相对路径 相对路径都会使用.或者..开头 ./ 表示当前文件所在的目录 ../ 表示当前文件所在目录的上一级 ./可以省略不写, 如果不写./也不写../则就相当于写./ --\u003e \u003ca href=\"../7列表.html\"\u003e内部相对路径跳转\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/:0:0","tags":["HTML"],"title":"Web学习笔记 - 相对路径","uri":"/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"},{"categories":["前端"],"content":"超链接可以让我们从一个页面跳转到其他页面.","date":"2022-12-03","objectID":"/%E8%B6%85%E9%93%BE%E6%8E%A5/","tags":["HTML"],"title":"Web学习笔记 - 超链接","uri":"/%E8%B6%85%E9%93%BE%E6%8E%A5/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 超链接可以让我们从一个页面跳转到其他页面, 或者是当前页面的其他位置 使用 a 标签来定义超链接 属性: href 指定跳转的目标路径 - 值可以是一个外部网站的地址 - 值也可以是一个内部网站的地址 超链接也是一个行内元素,在 a 标签中可以嵌套除它自身外任何元素 --\u003e \u003ca href=\"https://www.baidu.com\"\u003e百度\u003c/a\u003e \u003cbr\u003e \u003ca href=\"https://www.baidu.com\"\u003e百度\u003c/a\u003e \u003cbr\u003e \u003ca href=\"7列表.html\"\u003e内部页面\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- target 属性, 用来指定超链接打开的位置 可选值: _self 默认值,当前页中打开超链接 _blank 在一个新的页面中打开超链接 --\u003e \u003ca href=\"https://www.baidu.com\" target=\"_blank\"\u003e打开百度\u003c/a\u003e \u003cbr\u003e \u003c!-- 在开发中可以将#作为超链接路径的占位符使用 --\u003e \u003ca href=\"#\"\u003e这是一个新的超链接\u003c/a\u003e \u003cbr\u003e \u003c!-- 可以使用JavaScript:; 来作为href属性,此时点击这个超链接什么也不会发生 --\u003e \u003ca href=\"javascript:;\"\u003e这是一个新的超链接\u003c/a\u003e \u003cbr\u003e \u003ca href=\"bottom\"\u003e去底部\u003c/a\u003e \u003c!-- 可以直接将超链接的href属性设置为#,这样点击超链接后, 页面不会发送跳转,而是转到当前页面的顶部的位置 可以调整到页面的指定位置,只需讲href属性设置 #目标元素的id id属性(唯一不重复的) - 每一个标签都可以添加一个id属性 - id属性就是元素的唯一标识,同一个页面中不能出现重复的id属性; --\u003e \u003ca id=\"bottom\" href=\"#\"\u003e回到顶部\u003c/a\u003e \u003cbr\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-03","objectID":"/%E8%B6%85%E9%93%BE%E6%8E%A5/:0:0","tags":["HTML"],"title":"Web学习笔记 - 超链接","uri":"/%E8%B6%85%E9%93%BE%E6%8E%A5/"},{"categories":["前端"],"content":"HTML中的有序列表和无序列表","date":"2022-12-02","objectID":"/%E5%88%97%E8%A1%A8/","tags":["HTML"],"title":"Web学习笔记 - 列表","uri":"/%E5%88%97%E8%A1%A8/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 列表(list) 1. 铅笔 2. 尺子 3. 橡皮 在html中也可以创建列表,html列表一共有三种 1. 有序列表 2. 无序列表 3. 定义列表 有序列表,使用ol标签来创建有序列表 使用li表示列表项 无序列表,使用ul标签来创建无序列表 使用li表示列表项 定义列表,使用dl标签来创建一个定义列表 使用dt来表示定义的内容 使用dd来对内容进行解释说明 列表之间可以互相嵌套 --\u003e \u003cul\u003e \u003cli\u003e\u003c/li\u003e \u003c/ul\u003e \u003col\u003e \u003cli\u003e\u003c/li\u003e \u003c/ol\u003e \u003cdl\u003e \u003cdt\u003e结构\u003c/dt\u003e \u003cdd\u003e结构表示网页的结构,结构用来规定网页中哪里是标题,哪里是段落\u003c/dd\u003e \u003c/dl\u003e \u003cul\u003e \u003cli\u003e aa \u003cul\u003e \u003cli\u003eaa-1\u003c/li\u003e \u003cli\u003eaa-2\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-02","objectID":"/%E5%88%97%E8%A1%A8/:0:0","tags":["HTML"],"title":"Web学习笔记 - 列表","uri":"/%E5%88%97%E8%A1%A8/"},{"categories":["文档"],"content":"Hugo 文章通用配置,gitalk评论设置","date":"2022-12-02","objectID":"/hugo/","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"文章目录 # 目录设置 [markup.tableOfContents] startLevel = 2 # 代表从第几级标题开始生成目录 endLevel = 6 # 代表从第几级标题结束目录 ordered = true # 目录排序 ","date":"2022-12-02","objectID":"/hugo/:1:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"文章通用配置 打开archetypes/default.md文件进行编辑: --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} draft: false categories: [\"Web\"] tags: [\"HTML\"] keywords: [\"HTML\"] --- ","date":"2022-12-02","objectID":"/hugo/:2:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"常用指令 hugo new posts 文章.md # 发布文章 hugo # 编译 hugo server -D # 启动本地服务 ","date":"2022-12-02","objectID":"/hugo/:3:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"loveit主题相关 代码块识别语言高亮,配置文件路径: /themes/LoveIt/assets/css/_variables.scss ","date":"2022-12-02","objectID":"/hugo/:4:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"链接 链接 - 普通链接 {{\u003c link \"https://andy90s.github.io/\" \u003e}} 或者 {{\u003c link href=\"https://andy90s.github.io/\" content=\"https://andy90s.github.io/\" \u003e}} {{\u003c link \"mailto:contact@qq.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@qq.com\" content=\"mailto:contact@qq.com\" \u003e}} {{\u003c link \"https://andy90s.github.io/\" Andy90s \u003e}} 或者 {{\u003c link href=\"https://andy90s.github.io/\" content=Andy90s \u003e}} \u003c!-- 停留带标题 --\u003e {{\u003c link \"https://andy90s.github.io/\" Andy90s \"Visit Andy90s!\" \u003e}} 或者 {{\u003c link href=\"https://andy90s.github.io/\" content=Andy90s title=\"Visit Andy90s!\" \u003e}} 效果如下: https://andy90s.github.io/ 或者 https://andy90s.github.io/ mailto:contact@qq.com 或者 mailto:contact@qq.com Andy90s 或者 Andy90s Andy90s 或者 Andy90s 链接 - 内部跳转链接 \u003c!-- ref绝对路径 relref相对路径 --\u003e {{\u003c ref \"path/to/document.md#锚点\" \u003e}} {{\u003c relref \"path/to/document.md#锚点\" \u003e}} 例如跳转到本文的文章目录锚点: [跳转到其他文章锚点]({{\u003c relref \"其他文章.md#文章目录\" \u003e}}) [跳转到文章目录]({{\u003c relref \"../other/hugo常见问题.md#文章目录\" \u003e}}) 效果: 跳转到文章目录 ","date":"2022-12-02","objectID":"/hugo/:4:1","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"gitalk评论设置 ","date":"2022-12-02","objectID":"/hugo/:5:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"github生成application auth 生成方法:打开github设置 - develop setting - OAuth Apps - 选择新建 新建OAuth ","date":"2022-12-02","objectID":"/hugo/:5:1","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"得到秘钥,粘贴到配置中 [params.page.comment.gitalk] enable = true owner = \"andy90s\" repo = \"andy90s.github.io\" clientId = \"上面拿到的id\" clientSecret = \"上面生成的秘钥\" id = \"location.pathname\" 注意 上述评论配置为(hugo+loveit主题),其他配置差别不大,注意repo应填写仓库名即可 id按照上述配置,会自动生成issue ","date":"2022-12-02","objectID":"/hugo/:5:2","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"图片资源 由于我的图片是直接存放到github仓库中的,所以需要配置下CDN来加速访问,上传我使用的是picgo工具,配置如下: picgo设置 https://cdn.jsdelivr.net/gh/ + 你的github用户名 + 你的仓库名 + 图片路径 例如: https://cdn.jsdelivr.net/gh/andy90s/blog-image/blog/images/271669958429_.pic.jpg 技巧 gh = github 指定master分支: https://cdn.jsdelivr.net/gh/andy90s/blog-image@master/blog/images/271669958429_.pic.jpg 还可以指定版本号: https://cdn.jsdelivr.net/gh/andy90s/blog-image@版本号/blog/images/271669958429_.pic.jpg 压缩资源: https://cdn.jsdelivr.net/gh/andy90s/blog-image@版本号/blog/images/271669958429_.pic?x-oss-process=image/resize,m_lfit,h_100,w_100 ","date":"2022-12-02","objectID":"/hugo/:6:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"自定义shortcode 比如我要将这段HTML代码转换为shortcode: \u003cdetails\u003e \u003csummary\u003e标题\u003c/summary\u003e \u003cp style=\"background-color: #F4F6F6;\"\u003e 内容 \u003c/p\u003e \u003c/details\u003e ","date":"2022-12-02","objectID":"/hugo/:7:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"1. 在layouts/shortcodes目录下新建details.html文件 \u003cdetails\u003e \u003csummary\u003e{{ .Get \"summary\" }}\u003c/summary\u003e \u003cp style=\"background-color: #F4F6F6;\"\u003e {{ .Inner }} \u003c/p\u003e \u003c/details\u003e ","date":"2022-12-02","objectID":"/hugo/:7:1","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"2. 在文章中使用 {{\u003c details summary=\"标题\" \u003e}} 内容 {{\u003c /details \u003e}} ","date":"2022-12-02","objectID":"/hugo/:7:2","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"参考 主题文档 - 扩展 Shortcodes ","date":"2022-12-02","objectID":"/hugo/:8:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["前端"],"content":"在使用html标签时,应该关注的是标签的语义,而不是样式.","date":"2022-12-01","objectID":"/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/","tags":["HTML"],"title":"Web学习笔记 - 语义化标签","uri":"/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 在网页中HTML专门用来负责网页的结构 所以在使用html标签时,应该关注的是标签的语义,而不是样式 标题标签: h1~h6 一共六级标题 从h1~h6重要性递减,h1最重要,h6最不重要 h1在网页中的重要性仅次于title标签,一般情况下一个页面只会有一个h1 一般情况下标题标签只会使用到h1~h3,h4~h6很少用 标题标签都是块元素 块元素,在页面中独占一行的元素(block element) --\u003e \u003ch1\u003e一级标题\u003c/h1\u003e \u003ch2\u003e二级标题\u003c/h2\u003e \u003ch3\u003e三级标题\u003c/h3\u003e \u003ch4\u003e丝级标题\u003c/h4\u003e \u003ch5\u003e五级标题\u003c/h5\u003e \u003ch6\u003e六级标题\u003c/h6\u003e \u003c!-- hgroup 标签用来标题分组,可以将一组相关的标题同时放入hgroup --\u003e \u003chgroup\u003e \u003ch1\u003e大标题\u003c/h1\u003e \u003ch2\u003e小标题\u003c/h2\u003e \u003c/hgroup\u003e \u003c!-- p标签表示页面汇总的一个段落; p也是一个块元素 --\u003e \u003cp\u003e段落1\u003c/p\u003e \u003cp\u003e段落2\u003c/p\u003e \u003c!-- em标签用于表示语音语调的一个加重 在页面中不会独占一行的元素成为行内元素(inline element) --\u003e \u003cp\u003e今天天气\u003cem\u003e真\u003c/em\u003e不错!\u003c/p\u003e \u003c!-- strong 表示强调,重要的内容 --\u003e \u003cp\u003e你今天必须要\u003cstrong\u003e完成作业!\u003c/strong\u003e\u003c/p\u003e 鲁迅说, \u003c!-- blockquote 表示一个引用 --\u003e \u003cblockquote\u003e这句话我是从来没有说过\u003c/blockquote\u003e \u003c!-- q 表示一个短引用 --\u003e 子曰\u003cq\u003e学而时学志,乐呵乐呵!\u003c/q\u003e \u003c!-- br 表示换行 --\u003e \u003cbr\u003e \u003cbr\u003e 今天天气真不错 \u003c/body\u003e \u003c/html\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 块元素(block element) - 在网页中一般通过块元素对页面进行布局 行内元素(inline element) - 行内元素主要用来包裹文字 - 一般情况下会在块元素中放行内元素,而不会在行内元素中放块元素 - 块元素中基本什么都能放 - p元素中不能放任何的块元素 浏览器在解析网页时,会自动对网页中不符合规范的内容进行修整 比如: 标签写在了根元素的外部 p元素中嵌套了块元素 根元素中出现了除head和body以外的子元素 --\u003e \u003c/body\u003e \u003c/html\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- header 表示网页的头部 main 表示网页的主体部分(一个网页中只会有一个main) footer 表示网页的底部 nav 表示网页的导航 aside 表示主体相关的其他内容(侧边栏) article 文章 section 表示一个独立的区块,上边的标签都不能表示时使用section div 没有语义,就是表示一个区块 span 行内元素,没有语义,一般用于在网页中选中文字 --\u003e \u003cheader\u003e\u003c/header\u003e \u003cmain\u003e\u003c/main\u003e \u003cfooter\u003e\u003c/footer\u003e \u003cnav\u003e\u003c/nav\u003e \u003caside\u003e\u003c/aside\u003e \u003carticle\u003e\u003c/article\u003e \u003csection\u003e\u003c/section\u003e \u003cdiv\u003e\u003c/div\u003e \u003cspan\u003e\u003c/span\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-01","objectID":"/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/:0:0","tags":["HTML"],"title":"Web学习笔记 - 语义化标签","uri":"/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"主要用于设置网页中的一些元数据,元数据不是给用户看","date":"2022-12-01","objectID":"/meta%E6%A0%87%E7%AD%BE/","tags":["HTML"],"title":"Web学习笔记 - Meta标签","uri":"/meta%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c!-- meta主要用于设置网页中的一些元数据,元数据不是给用户看 charset 指定网页的字符集 name 指定的数据的名称 content 指定的数据的内容 keywords 表示网站的关键字,可以同时指定多个关键字,关键字之间使用`,`隔开 \u003cmeta name=\"keywords\" content=\"网上购物,网上商城,手机\"\u003e \u003cmeta name=\"keywords\" content=\"网上购物,网上商城,手机\"\u003e --\u003e \u003cmeta name=\"keywords\" content=\"html5,前端,CSS3\"\u003e \u003cmeta name=\"description\" content=\"这是一个非常不错的网站\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-01","objectID":"/meta%E6%A0%87%E7%AD%BE/:0:0","tags":["HTML"],"title":"Web学习笔记 - Meta标签","uri":"/meta%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"在网页中书写这些特殊字符,则需要使用html中的实体(转义字符)","date":"2022-12-01","objectID":"/%E5%AE%9E%E4%BD%93/","tags":["HTML"],"title":"Web学习笔记 - 实体","uri":"/%E5%AE%9E%E4%BD%93/"},{"categories":["前端"],"content":"实体 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e实体\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 在网页中编写的多个空格默认情况会自动被浏览器解析为一个空格 在HTML中有些时候,我们不能直接书写一些特殊符号 比如,多个连续的空格,比如字母两侧的大于和小于号. 如果我们需要在网页中书写这些特殊字符,则需要使用html中的实体(转义字符) 实体的语法: \u0026实体的名字; 空格: \u0026nbsp; --\u003e \u003cp\u003e '今天\u0026nbsp;天气真不错' \u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-01","objectID":"/%E5%AE%9E%E4%BD%93/:1:0","tags":["HTML"],"title":"Web学习笔记 - 实体","uri":"/%E5%AE%9E%E4%BD%93/"},{"categories":["前端"],"content":"HTML用于描述页面的结构","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"软件 应用软件C/S架构;C: Client /S: Server 网页端的软件B/S架构; B: Browser ","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/:1:0","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"结构,表现,行为 结构 HTML用于描述页面的结构 表现 CSS用于控制页面中元素的样式 行为 JavaScript用于响应用户操作 ","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/:2:0","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"HTML \u003chtml\u003e\u003c/html\u003e根标签(元素),网页中的所有内容都要写在根元素里边; \u003chead\u003e\u003c/head\u003e头; 不会出现在内容中;主要用来帮助浏览器或搜索引擎来解析网页; \u003cbody\u003e\u003c/body\u003e体; \u003c!-- 文档声明HTML5的规范; --\u003e \u003c!DOCTYPE html\u003e \u003c!-- 告诉浏览器语言(提示是否翻译此页) --\u003e \u003chtml lang=\"en\"\u003e \u003c!-- 根标签(元素),网页中的所有内容都要写根元素里面 --\u003e \u003chtml\u003e \u003c!-- head是网页的头部,head中的内容不会在网页中出现,主要用来帮助浏览器或者搜索引擎来解析网页 --\u003e \u003chead\u003e \u003c!-- meta标签用来设置网页的元数据,这里可以通过meta标签设置网页的字符集,避免乱码问题 --\u003e \u003cmeta charset=\"utf-8\"\u003e \u003c!-- title中的内容会显示在浏览器的标题栏,搜索引擎会主要根据title中的内容来判断网页的主要内容,不会出现在内容中 --\u003e \u003ctitle\u003e网页的基本结构\u003c/title\u003e \u003c/head\u003e \u003c!-- body是html的子元素,表示网页的主体,网页中所有的可见内容都应该写在body里面 --\u003e \u003cbody\u003e \u003c!-- h1网页的一级标题 --\u003e \u003ch1\u003e网页的大标题\u003c/h1\u003e \u003c!-- 大标题,属性问题,空格隔开;--\u003e \u003ch1\u003e这是我的\u003cfont color=\"red\" size=\"18\"\u003e第三个\u003c/font\u003e网页\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/:3:0","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"进制: 十进制(日常使用) 特点:满10进1 计数:0 1 2 3 4 5 6 7 8 9 单位数字:10个(0~9) 二进制(计算机底层的进制) 特点:满2进1 计数:0 1 10 11 100 101 110… 单位数字:2个(0,1) 扩展: 所有的数据在计算机底层都会以二进制的形式保存 可以将内存想象为一个有多个小格子组成的容器,每一个格子中可以存储一个1或者一个0 这一个小格子在内存中被称为1位(bit) 8bit = 1byte(字节) 1024byte = 1kb(千字节) 1024kb = 1mb(兆字节) 1024mb = 1gb(吉字节) 1024gb = 1tb(特字节) 1024tb = 1pb 八进制(很少用) 特点:满8进1 计数:0 1 2 3 4 5 6 7 10 … 单位数字:8个(0~7) 十六进制(一般显示一个二进制数字时,都会转换为十六进制) 特点:满16进1 计数:0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 … 1a 1b 1c 1d 1e 1f 20… 单位数字:16个(0~f) ","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/:4:0","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"字符编码 李立超 -\u003e 1100 0011 (编码) 1100 0011 -\u003e 李立超 (解码) 所有的数据在计算机中存储时都是以二进制形式存储的,文字也不例外,所以一段文字在存储到内存中时,都需要转换为二进制编码,当我们读取这段文字时,计算机会将编码转换为字符,供我们阅读 编码 将字符转换为二进制码的过程称为编码 解码 将二进制码转换为字符的过程称为解码 字符集 编码和解码所采用的规则称为字符集 乱码 如果编码和解码采用的字符集不同,就会产生乱码 常见的字符集: ASCII 美国 ISO88591 欧洲扩充 GB2312 国标,中国扩充 GBK UTF-8 万国码,在开发时我们使用的字符集都是UTF-8 ","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/:5:0","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["文档"],"content":"提交信息由 `Header`+`Body`+`Footer`组成","date":"2022-12-01","objectID":"/git-submit/","tags":["git"],"title":"代码提交规范","uri":"/git-submit/"},{"categories":["文档"],"content":"代码提交记录示例 feat(home): add a homepage feat(首页): 添加一个首页 ","date":"2022-12-01","objectID":"/git-submit/:1:0","tags":["git"],"title":"代码提交规范","uri":"/git-submit/"},{"categories":["文档"],"content":"格式说明 提交信息由 Header+Body+Footer组成 Header:feat: 本次提交类型描述 Body:(home): 功能模块,自己分类 Footer:add a homepage: 具体描述 ","date":"2022-12-01","objectID":"/git-submit/:2:0","tags":["git"],"title":"代码提交规范","uri":"/git-submit/"},{"categories":["文档"],"content":"提交类型说明 type 说明 feat 新增feature fix 修复bug docs 文档修改,比如readme文件 perf 优化 style 修改了代码格式,不修改逻辑,比如删除多余的空格和空行 refactor 代码重构,没有新增功能,也没有修复bug test 测试用例,包含单元测试和集成测试 ci 修改ci配置文件或者脚本,比如jenkins fastlane chore 修改构建脚本,或者增加依赖库,工具等 revert 回滚之前的commit ","date":"2022-12-01","objectID":"/git-submit/:3:0","tags":["git"],"title":"代码提交规范","uri":"/git-submit/"},{"categories":["文档"],"content":"常用markdown语法(hugo+loveit主题)","date":"2022-11-30","objectID":"/markdown/","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"前言 本文大部分是在hugo+loveit主题两者基础上才有作用,具体参考loveit主题shortcode文档 ","date":"2022-11-30","objectID":"/markdown/:1:0","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"代码块 ","date":"2022-11-30","objectID":"/markdown/:2:0","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"TOML baseURL = \"http://example.org/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true ","date":"2022-11-30","objectID":"/markdown/:2:1","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"bash git clone https://github.com/dillonzq/LoveIt.git themes/LoveI ","date":"2022-11-30","objectID":"/markdown/:2:2","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"css @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; ","date":"2022-11-30","objectID":"/markdown/:2:3","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"admonition 注意 注意 admonition note admonition note admonition tip admonition tip 【更多admonition参考】 ","date":"2022-11-30","objectID":"/markdown/:3:0","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"版本 ","date":"2022-11-30","objectID":"/markdown/:4:0","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"图片 ","date":"2022-11-30","objectID":"/markdown/:5:0","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"默认 ![](/images/fengmian4.jpg) ","date":"2022-11-30","objectID":"/markdown/:5:1","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"控制大小和位置(1) \u003cp align=\"center\"\u003e \u003cimg src=\"/images/fengmian4.jpg\" width=\"200\" /\u003e \u003c/p\u003e \u003ccenter\u003e图示\u003c/center\u003e 图示 ","date":"2022-11-30","objectID":"/markdown/:5:2","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"控制大小和位置(2) \u003ccenter\u003e \u003cimg width=\"300\" src=\"/images/fengmian4.jpg\"\u003e \u003cdiv style=\"color:black;\"\u003e \u003cb\u003e 图示 \u003c/b\u003e \u003c/div\u003e \u003c/center\u003e 图示 ","date":"2022-11-30","objectID":"/markdown/:5:3","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"控制大小和位置(3) \u003ccenter\u003e {{\u003c image src=\"/images/fengmian4.jpg\" title=\"停留显示\"width=\"50%\" \u003e}} \u003cdiv style=\"color:black;\"\u003e \u003cb\u003e 图示 \u003c/b\u003e \u003c/div\u003e \u003c/center\u003e 技巧 1.此shortcode需loveit主题支持 2.这种方式显示的图片配合loveit主题可以点击放大,停留显示文案等 图示 Bug 主题应该是有bug, 当设置caption图片标题, 会造成width属性失效,所以这里加div标签达到效果 ","date":"2022-11-30","objectID":"/markdown/:5:4","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"git github问题记录","date":"2022-11-30","objectID":"/git/","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"生成ssh-key,对应不同平台 ","date":"2022-11-30","objectID":"/git/:1:0","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"1. 利用ssh生成秘钥(这里以github平台为例) ssh-keygen -t rsa -C \"youremail@xxx.com\" -f ~/.ssh/id_rsa 注意 id_rsa是文件名,可自己修改,大部分默认名为id_rsa 如果想要多个平台分开不同秘钥,再次执行上面指令,文件名替换其他,例:gitlab_id_rsa ","date":"2022-11-30","objectID":"/git/:1:1","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"2. 添加私钥 ssh-add ~/.ssh/id_rsa ","date":"2022-11-30","objectID":"/git/:1:2","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"3. 查看公钥内容并复制到对应的git平台的ssh keys设置中 cat ~/.ssh/id_rsa.pub ","date":"2022-11-30","objectID":"/git/:1:3","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"4. 测试链接 ssh -T git@github.com ","date":"2022-11-30","objectID":"/git/:1:4","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"gitignore忽略文件不生效 1.准备工作: 删除pods文件,然后提交代码 2.缓存导致不生效,按如下解决: git rm -r --cached . git add . git commit -m 'update gitignore' ","date":"2022-11-30","objectID":"/git/:2:0","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"github提示账号密码不对 仓库是https拉取,终端提示输入账号密码,怎么输入都不对? 这是因为github不再支持原密码登录,替换为token登录. 解决办法 打开github设置(settings) -\u003e Developer settings -\u003e Personal access tokens -\u003e Tokens 选择新建一个如下图所示,得到一个token字符串,登录的时候密码使用此token替换原来的密码进行登录 设置github token ","date":"2022-11-30","objectID":"/git/:3:0","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"}]