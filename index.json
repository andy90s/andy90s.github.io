[{"categories":["移动端"],"content":"前言 关于设备信息,苹果提供的API并不多,但是我们可以通过一些开源库来获取更多的信息,比如设备型号,屏幕尺寸,系统版本等等.比如获取当前设备是否是刘海屏,如果用安全距离来判断,因为window有可能是nil,可能会导致判断错误 ","date":"2023-10-30","objectID":"/uidevice/:1:0","tags":["iOS"],"title":"UIDevice","uri":"/uidevice/"},{"categories":["移动端"],"content":"DeviceKit ","date":"2023-10-30","objectID":"/uidevice/:2:0","tags":["iOS"],"title":"UIDevice","uri":"/uidevice/"},{"categories":["移动端"],"content":"地址 【DeviceKit】 ","date":"2023-10-30","objectID":"/uidevice/:2:1","tags":["iOS"],"title":"UIDevice","uri":"/uidevice/"},{"categories":["移动端"],"content":"使用 比如判断是否是刘海屏等: import DeviceKit let device = Device.current // 判断是否是iphone if device.isPhone { // 判断是否是刘海屏 if device.hasRoundedDisplayCorners { // 判断是否是iphoneX if device == .iPhoneX { // ... } } } ","date":"2023-10-30","objectID":"/uidevice/:2:2","tags":["iOS"],"title":"UIDevice","uri":"/uidevice/"},{"categories":["移动端"],"content":"前言 keyWindow是iOS系统中的一个概念,它是一个全局的变量,代表当前显示在屏幕最上面的window,它是一个UIWindow对象,每个应用程序都有一个keyWindow,它是一个全局的变量,可以通过UIApplication的keyWindow属性获取,但是由于 iOS系统的不断迭代,导致获取keywindow的方法也在不断变化,这里记录一下获取keywindow的方法 ","date":"2023-10-30","objectID":"/keywindow/:1:0","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"获取keywindow ","date":"2023-10-30","objectID":"/keywindow/:2:0","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"iOS13之前 UIApplication.shared.keyWindow ","date":"2023-10-30","objectID":"/keywindow/:2:1","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"iOS13之后 UIApplication.shared.windows.filter {$0.isKeyWindow}.first ","date":"2023-10-30","objectID":"/keywindow/:2:2","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"iOS16之后 UIApplication.shared.connectedScenes .filter {$0.activationState == .foregroundActive} .map {$0 as? UIWindowScene} .compactMap {$0} .first?.windows .filter {$0.isKeyWindow}.first 技巧 获取逻辑: 多个场景 -\u003e 筛选出前台激活的场景 -\u003e 转换为UIWindowScene -\u003e 去除nil -\u003e 取第一个场景 -\u003e 获取场景中的窗口 -\u003e 筛选出keywindow -\u003e 取第一个窗口 ","date":"2023-10-30","objectID":"/keywindow/:2:3","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"适配所有版本 由于新的api已经兼容到了13.0,所以只需要兼容到13.0就可以了,这里使用#available来判断版本,如果版本大于13.0,则使用新的api,否则使用旧的api extension UIApplication { /// 获取keywindow static var currentKeyWindow: UIWindow? { if #available(iOS 13.0, *) { return UIApplication.shared.connectedScenes .filter {$0.activationState == .foregroundActive} .compactMap {$0 as? UIWindowScene} .first?.windows .filter {$0.isKeyWindow}.first } else { return UIApplication.shared.keyWindow } } } 注意 需要注意的是 1\u003e当程序处于启动状态时,keyWindow可能为nil,因为此时程序还没有显示出来,13系统以后苹果推荐使用Scene来管理窗口 2\u003e当程序处于后台时,keyWindow可能为nil,因为此时程序已经被挂起,不再显示 3\u003e程序启动过程中,keyWindow可能会发生变化,也可能是nil,因为程序启动过程中,可能会创建多个窗口,最后显示的窗口才是keyWindow 具体表现是,在root的控制器中分别在viewDidload和viewDidAppear打印keyWindow: \"viewDidLoad = nil\" \"viewDidAppear = Optional(\u003cUIWindow: 0x100b095a0; frame = (0 0; 414 896);gestureRecognizers = \u003cNSArray: 0x281662b50\u003e; layer = \u003cUIWindowLayer: 0x281662ac0\u003e\u003e)\" 上面的方法我已经分别在包含Scene和不包含两种工程中测试,都已经通过,如果有问题,欢迎指出 ","date":"2023-10-30","objectID":"/keywindow/:2:4","tags":["iOS"],"title":"keyWindow","uri":"/keywindow/"},{"categories":["移动端"],"content":"前言 很多场景需要获取当前显示的控制器，比如弹窗，需要获取当前显示的控制器，才能弹出来，否则会出现问题。这里记录一下获取当前显示的控制器的方法。 ","date":"2023-10-30","objectID":"/top-viewcontroller/:1:0","tags":["iOS"],"title":"获取当前显示的ViewController","uri":"/top-viewcontroller/"},{"categories":["移动端"],"content":"获取当前显示的控制器 ","date":"2023-10-30","objectID":"/top-viewcontroller/:2:0","tags":["iOS"],"title":"获取当前显示的ViewController","uri":"/top-viewcontroller/"},{"categories":["移动端"],"content":"首先获取当前显示的window extension UIApplication { /// 获取keywindow static var currentKeyWindow: UIWindow? { if #available(iOS 13.0, *) { return UIApplication.shared.connectedScenes .filter {$0.activationState == .foregroundActive} .compactMap {$0 as? UIWindowScene} .first?.windows .filter {$0.isKeyWindow}.first } else { return UIApplication.shared.keyWindow } } } 技巧 关于keyWindow可以看这里 获取keyWindow ","date":"2023-10-30","objectID":"/top-viewcontroller/:2:1","tags":["iOS"],"title":"获取当前显示的ViewController","uri":"/top-viewcontroller/"},{"categories":["移动端"],"content":"获取当前显示的控制器 extension UIApplication { /// 获取当前显示的控制器 /// - Parameter base: 基础控制器 /// - Returns: 当前显示的控制器 class func topViewController(base: UIViewController? = UIApplication.currentKeyWindow?.rootViewController) -\u003e UIViewController? { if let nav = base as? UINavigationController { return topViewController(base: nav.visibleViewController) } if let tab = base as? UITabBarController { if let selected = tab.selectedViewController { return topViewController(base: selected) } } if let presented = base?.presentedViewController { return topViewController(base: presented) } return base } class var topViewController: UIViewController? { return topViewController() } } 建议 建议不要在viewDidLoad中使用topViewController，因为此时view还没有加载完成，会导致获取到的控制器不正确。 ","date":"2023-10-30","objectID":"/top-viewcontroller/:2:2","tags":["iOS"],"title":"获取当前显示的ViewController","uri":"/top-viewcontroller/"},{"categories":["工具"],"content":"前言 有时候需要下载app的ipa包 ","date":"2023-10-27","objectID":"/download-ipa/:1:0","tags":["网站","ipa"],"title":"下载ipa","uri":"/download-ipa/"},{"categories":["工具"],"content":"【decrypt】 【decrypt】","date":"2023-10-27","objectID":"/download-ipa/:2:0","tags":["网站","ipa"],"title":"下载ipa","uri":"/download-ipa/"},{"categories":["移动端"],"content":"前言 底部弹框,类似微信的分享功能,动画效果有两个: 从底部弹出内容 从底部弹出内容,并且背景变暗 ","date":"2023-10-25","objectID":"/popup-slide/:1:0","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"效果 弹框效果 ","date":"2023-10-25","objectID":"/popup-slide/:2:0","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"思路 直接模态一个控制器,自定义转场动画,并且给内容view添加一个改变frame的动画就可以了 ","date":"2023-10-25","objectID":"/popup-slide/:3:0","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"代码 ","date":"2023-10-25","objectID":"/popup-slide/:4:0","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"转场动画 class CustomPresentAnimator: NSObject, UIViewControllerAnimatedTransitioning { private var duration: TimeInterval = 0.3 private var maskColor: UIColor = UIColor.black private var maskAlpha: CGFloat = 0.6 private var present = true convenience init(_ present: Bool = true, maskColor: UIColor? = nil, maskAlpha: CGFloat? = nil, duration: TimeInterval? = nil) { self.init() if let maskColor = maskColor { self.maskColor = maskColor } if let maskAlpha = maskAlpha { self.maskAlpha = maskAlpha } if let duration = duration { self.duration = duration } self.present = present } func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -\u003e TimeInterval { return duration } func animateTransition(using transitionContext: UIViewControllerContextTransitioning) { guard let toVC = transitionContext.viewController(forKey: .to) else {return} guard let fromVC = transitionContext.viewController(forKey: .from) else {return} let containerView = transitionContext.containerView if present { containerView.addSubview(toVC.view) toVC.view.alpha = 0.0 toVC.view.backgroundColor = .clear UIView.animate(withDuration: duration, animations: {[weak self] in guard let wself = self else { return } toVC.view.alpha = 1.0 toVC.view.backgroundColor = wself.maskColor.withAlphaComponent(wself.maskAlpha) }, completion: { finished in transitionContext.completeTransition(finished) }) } else { UIView.animate(withDuration: duration, animations: { fromVC.view.alpha = 0.0 fromVC.view.backgroundColor = .clear }, completion: { finished in transitionContext.completeTransition(finished) }) } } } ","date":"2023-10-25","objectID":"/popup-slide/:4:1","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"弹框控制器 class CommonModalController: UIViewController,UIViewControllerTransitioningDelegate { let contentView = UIView() let pageBottomPadding = -34 // 需要减去底部安全区域的高度,这里省略机型判断,默认是iPhoneX以上机型 private var contentSize: CGSize = .zero private var touchView: UIView = UIView() convenience init(contentSize: CGSize) { self.init() self.modalPresentationStyle = .custom self.transitioningDelegate = self self.contentSize = contentSize self.contentView.frame = CGRectMake(0, self.view.bounds.size.height, self.view.bounds.size.width, self.contentSize.height - pageBottomPadding) self.touchView.frame = CGRectMake(0, 0, self.view.bounds.size.width, self.view.bounds.size.height - self.contentSize.height + pageBottomPadding) } override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) UIView.animate(withDuration: 0.3,delay: 0) {[weak self] in guard let wself = self else { return } wself.contentView.frame = CGRectMake(0, wself.view.bounds.size.height - wself.contentSize.height + pageBottomPadding, wself.view.bounds.size.width, wself.contentSize.height - pageBottomPadding) } } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) UIView.animate(withDuration: 0.3,delay: 0) {[weak self] in guard let wself = self else { return } wself.contentView.frame = CGRectMake(0, wself.view.bounds.size.height, wself.view.bounds.size.width, wself.contentSize.height - pageBottomPadding) } } override func viewDidLoad() { super.viewDidLoad() self.contentView.backgroundColor = .white self.contentView.layer.cornerRadius = 18 self.contentView.layer.maskedCorners = [.layerMinXMinYCorner, .layerMaxXMinYCorner] let tap = UITapGestureRecognizer(target: self, action: #selector(dismissView)) self.touchView.addGestureRecognizer(tap) self.view.addSubview(touchView) self.view.addSubview(contentView) } @objc func dismissView() { self.dismiss(animated: true) } func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -\u003e UIViewControllerAnimatedTransitioning? { return CustomPresentAnimator() } func animationController(forDismissed dismissed: UIViewController) -\u003e UIViewControllerAnimatedTransitioning? { return CustomPresentAnimator(false) } deinit { debugPrint(\"\\(self)\\(#function)\") } } ","date":"2023-10-25","objectID":"/popup-slide/:4:2","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["移动端"],"content":"使用 let vc = CommonModalController(contentSize: CGSizeMake(self.view.bounds.size.width, 200)) self.present(vc, animated: true) 这里只是简单的实现了一个底部弹框,如果需要更多的动画效果,可以自己去实现,这里只是提供一个思路 ","date":"2023-10-25","objectID":"/popup-slide/:4:3","tags":["iOS"],"title":"底部弹框简单实现","uri":"/popup-slide/"},{"categories":["工具"],"content":"前言 Mac 版 Chrome 自带双指手势前进后退功能,这个功能叫做Overscroll history navigation,但是这个功能很不好用，经常会误触，所以需要禁用。 这个功能是根据MAC系统的设置来开启的,在MAC中这个功能叫做在页面之间轻扫，默认是开启的。 下面就来介绍两种禁用方法。 ","date":"2023-10-23","objectID":"/chrome-overscoll/:1:0","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"系统设置 ","date":"2023-10-23","objectID":"/chrome-overscoll/:2:0","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"触控板设置 「系统偏好设置」 → 「触控板」 → 「更多手势」中的「在页面之间轻扫」,取消勾选。 触摸板轻扫 ","date":"2023-10-23","objectID":"/chrome-overscoll/:2:1","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"鼠标设置 「系统偏好设置」 → 「鼠标」 → 「更多手势」中的「在页面之间轻扫」,取消勾选。 鼠标轻扫 ","date":"2023-10-23","objectID":"/chrome-overscoll/:2:2","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"Chrome设置 上面系统设置会禁用所有的轻扫手势，如果只想禁用Chrome浏览器的轻扫手势，可以通过以下命令禁用： ","date":"2023-10-23","objectID":"/chrome-overscoll/:3:0","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"禁用鼠标手势 defaults write com.google.Chrome AppleEnableMouseSwipeNavigateWithScrolls -bool false ","date":"2023-10-23","objectID":"/chrome-overscoll/:3:1","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["工具"],"content":"禁用触控板手势 defaults write com.google.Chrome AppleEnableSwipeNavigateWithScrolls -bool false ","date":"2023-10-23","objectID":"/chrome-overscoll/:3:2","tags":["Chrome"],"title":"Mac版Chrome浏览器关闭左右滑动","uri":"/chrome-overscoll/"},{"categories":["移动端"],"content":"布局从右到左 ","date":"2023-10-13","objectID":"/uicollectionview/:1:0","tags":["iOS"],"title":"UICollectionView","uri":"/uicollectionview/"},{"categories":["移动端"],"content":"方式1 数据会从右到左排列 if #available(iOS 9.0, *) { collectionView.semanticContentAttribute = .forceRightToLeft } if (@available(iOS 9.0, *)) { _collectionView.semanticContentAttribute = UISemanticContentAttributeForceRightToLeft; } ","date":"2023-10-13","objectID":"/uicollectionview/:1:1","tags":["iOS"],"title":"UICollectionView","uri":"/uicollectionview/"},{"categories":["移动端"],"content":"方式2 数据会从右到左排列 if #available(iOS 9.0, *) { collectionView.transform = CGAffineTransform(scaleX: -1.0, y: 1.0) } if (@available(iOS 9.0, *)) { _collectionView.transform = CGAffineTransformMakeScale(-1.0, 1.0); } cell中的内容也需要做相应的变换 cell.transform = CGAffineTransform(scaleX: -1.0, y: 1.0) cell.transform = CGAffineTransformMakeScale(-1.0, 1.0); ","date":"2023-10-13","objectID":"/uicollectionview/:1:2","tags":["iOS"],"title":"UICollectionView","uri":"/uicollectionview/"},{"categories":["移动端"],"content":"方式3 自定义UICollectionViewFlowLayout,这种方式不会改变数据的排列方向，只是改变了cell的布局方向 比如一行有4个cell，那么第一个cell的x坐标为0，第二个cell的x坐标为第一个cell的x坐标加上第一个cell的宽度，以此类推，第四个cell的x坐标为第三个cell的x坐标加上第三个cell的宽度，这样就可以实现从右到左的布局 示例代码如下： class RTLCollectionViewFlowLayout: UICollectionViewFlowLayout { override func layoutAttributesForElements(in rect: CGRect) -\u003e [UICollectionViewLayoutAttributes]? { guard let attributesArray = super.layoutAttributesForElements(in: rect) else { return nil } var newAttributesArray = [UICollectionViewLayoutAttributes]() // 获取余数 let remainder = attributesArray.count % 4 // 获取collectionView的宽度 let collectionViewWidth = collectionViewContentSize.width var currentX: CGFloat = sectionInset.left if attributesArray.count \u003c 4 { // 只有一行 currentX = collectionViewWidth - sectionInset.right - CGFloat(remainder) * (itemSize.width + minimumInteritemSpacing) } var currentY: CGFloat = sectionInset.top for (index,attributes) in attributesArray.enumerated() { let newAttributes = attributes.copy() as! UICollectionViewLayoutAttributes if newAttributes.frame.origin.y == currentY { // 在同一行 newAttributes.frame.origin.x = currentX } else { // 开始新的一行 currentY = newAttributes.frame.origin.y let last = attributesArray.count - index if last \u003c 4 { let count = last % 4 currentX = collectionViewContentSize.width - sectionInset.right - CGFloat(count) * itemSize.width - CGFloat(count - 1) * minimumInteritemSpacing } else { currentX = sectionInset.left } newAttributes.frame.origin.x = currentX } currentX += newAttributes.frame.size.width + minimumInteritemSpacing newAttributesArray.append(newAttributes) } return newAttributesArray } } @implementation RTLCollectionViewFlowLayout - (NSArray\u003cUICollectionViewLayoutAttributes *\u003e *)layoutAttributesForElementsInRect:(CGRect)rect { NSArray *attributesArray = [super layoutAttributesForElementsInRect:rect]; NSMutableArray *newAttributesArray = [NSMutableArray array]; // 获取余数 NSInteger remainder = attributesArray.count % 4; // 获取collectionView的宽度 CGFloat collectionViewWidth = self.collectionViewContentSize.width; CGFloat currentX = self.sectionInset.left; if (attributesArray.count \u003c 4) { // 只有一行 currentX = collectionViewWidth - self.sectionInset.right - remainder * (self.itemSize.width + self.minimumInteritemSpacing); } CGFloat currentY = self.sectionInset.top; for (NSInteger index = 0; index \u003c attributesArray.count; index++) { UICollectionViewLayoutAttributes *attributes = attributesArray[index]; UICollectionViewLayoutAttributes *newAttributes = [attributes copy]; if (newAttributes.frame.origin.y == currentY) { // 在同一行 newAttributes.frame.origin.x = currentX; } else { // 开始新的一行 currentY = newAttributes.frame.origin.y; NSInteger last = attributesArray.count - index; if (last \u003c 4) { NSInteger count = last % 4; currentX = collectionViewWidth - self.sectionInset.right - count * self.itemSize.width - (count - 1) * self.minimumInteritemSpacing; } else { currentX = self.sectionInset.left; } newAttributes.frame.origin.x = currentX; } currentX += newAttributes.frame.size.width + self.minimumInteritemSpacing; [newAttributesArray addObject:newAttributes]; } return newAttributesArray; } @end ","date":"2023-10-13","objectID":"/uicollectionview/:1:3","tags":["iOS"],"title":"UICollectionView","uri":"/uicollectionview/"},{"categories":["后端"],"content":"命令行进入Django项目交互环境 python manage.py shell ","date":"2023-09-18","objectID":"/django-interactive-environment/:1:0","tags":[],"title":"Django项目交互环境","uri":"/django-interactive-environment/"},{"categories":["工具"],"content":"抓包工具 Windows平台有finder Mac平台有Charles 都是比较常用的,因为我是mac刚开始用的也是Charles,但是因为公司路由器等原因,经常性的无法抓包,这里分享另一个开源工具 【Whistle】 ","date":"2023-09-14","objectID":"/whistle/:1:0","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"1.安装 npm install -g whistle ","date":"2023-09-14","objectID":"/whistle/:1:1","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"2.启动 w2 start 默认是8899端口,如果需要修改端口,可以在启动命令后面加上端口号,比如 w2 start -p 8888 启动之后可以在浏览器中输入终端提示链接打开抓包工具 启动 ","date":"2023-09-14","objectID":"/whistle/:1:2","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"3.停止 w2 stop ","date":"2023-09-14","objectID":"/whistle/:1:3","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"3.手机配置 手机连接电脑,打开wifi,选择电脑的wifi 手机设置代理,代理地址填写电脑的ip地址,端口号填写8899 手机用safari输入rootca.pro下载证书,安装证书,也可以到网页设置页面扫码安装如下图 到手机的设置中,找到通用-\u003e关于本机-\u003e证书信任设置,找到刚才安装的证书,打开信任开关 电脑打开http://localhost:8899/点击左侧network-\u003eenable开启抓包 扫码安装证书 抓包 技巧 如果证书配置成功,但是抓包不成功,并且网络也正常,但是手机却无法访问网络,这时候可以尝试关闭电脑的wifi,然后再打开,这样手机就可以访问网络了 ","date":"2023-09-14","objectID":"/whistle/:1:4","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"MOCK数据 mock数据 ","date":"2023-09-14","objectID":"/whistle/:1:5","tags":[],"title":"Whistle抓包工具","uri":"/whistle/"},{"categories":["工具"],"content":"安装 brew install --cask docker ","date":"2023-08-08","objectID":"/install-docker/:1:0","tags":[],"title":"Mac电脑安装Docker","uri":"/install-docker/"},{"categories":["工具"],"content":"查看版本 docker --version ","date":"2023-08-08","objectID":"/install-docker/:2:0","tags":[],"title":"Mac电脑安装Docker","uri":"/install-docker/"},{"categories":["工具"],"content":"安装完毕打开客户端 在应用程序中找到Docker图标，双击打开，会出现如下界面，点击右上角的鲸鱼图标，选择preferences，进入设置界面，选择resources，设置内存大小，推荐设置为4G，然后点击apply \u0026 restart，重启docker，这样就可以了。 Docker 默认的Setting 这里我运行开源项目 【Misago】截图 docker compose up 【Misago】 ","date":"2023-08-08","objectID":"/install-docker/:3:0","tags":[],"title":"Mac电脑安装Docker","uri":"/install-docker/"},{"categories":["工具"],"content":"清理 默认docker占用磁盘60G，如果不清理，会占用很多磁盘空间，可以通过如下命令清理 docker system prune -a ","date":"2023-08-08","objectID":"/install-docker/:4:0","tags":[],"title":"Mac电脑安装Docker","uri":"/install-docker/"},{"categories":["工具"],"content":"参考 【Docker 入门到实践】","date":"2023-08-08","objectID":"/install-docker/:5:0","tags":[],"title":"Mac电脑安装Docker","uri":"/install-docker/"},{"categories":["移动端"],"content":"M系列电脑运行MAC(Designed for iPad)或者MAC(Designed for iPhone)项目报错 ","date":"2023-07-12","objectID":"/xcode-error/:1:0","tags":[],"title":"Xcode运行项目报错","uri":"/xcode-error/"},{"categories":["移动端"],"content":"报错信息 The app's bundle identifier \"com.xxx.xxx.xxx\" is being used by another running app. macOS does not support running iOS or Mac Catalyst apps concurrently with other apps using the same bundle identifier. Please try again after terminating all other processes using the same bundle identifier or changing the bundle identifier of your app. ","date":"2023-07-12","objectID":"/xcode-error/:1:1","tags":[],"title":"Xcode运行项目报错","uri":"/xcode-error/"},{"categories":["移动端"],"content":"分析原因 电脑上有同名应用 ","date":"2023-07-12","objectID":"/xcode-error/:1:2","tags":[],"title":"Xcode运行项目报错","uri":"/xcode-error/"},{"categories":["移动端"],"content":"解决方案 检查当前电脑应用是否有同名应用，如果有，关闭同名应用 重启Xcode 上面不行直接施展重启大法: 重启电脑 ","date":"2023-07-12","objectID":"/xcode-error/:1:3","tags":[],"title":"Xcode运行项目报错","uri":"/xcode-error/"},{"categories":["工具"],"content":"MySQL是一种流行的关系型数据库管理系统，本文将介绍如何在Mac上安装MySQL并创建数据库和表格。","date":"2023-07-11","objectID":"/install-mysql/","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"前言 最近在学习MySQL，需要在Mac上安装MySQL，记录一下安装使用过程。 ","date":"2023-07-11","objectID":"/install-mysql/:1:0","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"安装 ","date":"2023-07-11","objectID":"/install-mysql/:2:0","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"1.通过brew安装 brew install mysql ","date":"2023-07-11","objectID":"/install-mysql/:2:1","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"2.启动MySQL brew services start mysql ","date":"2023-07-11","objectID":"/install-mysql/:2:2","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"3.设置密码 mysql_secure_installation ","date":"2023-07-11","objectID":"/install-mysql/:2:3","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"4.登录MySQL mysql -uroot -p ","date":"2023-07-11","objectID":"/install-mysql/:2:4","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"5.修改密码 ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password'; ","date":"2023-07-11","objectID":"/install-mysql/:2:5","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"6.退出MySQL exit ","date":"2023-07-11","objectID":"/install-mysql/:2:6","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"7.重启MySQL brew services restart mysql ","date":"2023-07-11","objectID":"/install-mysql/:2:7","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"8.登录MySQL mysql -uroot -p ","date":"2023-07-11","objectID":"/install-mysql/:2:8","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"9.创建数据库 create database test; ","date":"2023-07-11","objectID":"/install-mysql/:2:9","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"10.查看数据库 show databases; ","date":"2023-07-11","objectID":"/install-mysql/:2:10","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"11.删除数据库 drop database test; ","date":"2023-07-11","objectID":"/install-mysql/:2:11","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"12.MySQL 服务器管理命令 brew services start mysql #: 启动 MySQL 服务器，并设置为自启动。 brew services stop mysql #: 停止 MySQL 服务器，并设置为不自启动。 brew services run mysql #: 只启动 MySQL 服务器。 mysql.server start #: 启动 MySQL 服务器。 mysql.server stop #: 停止 MySQL 服务器 ","date":"2023-07-11","objectID":"/install-mysql/:2:12","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"使用(以mysite为例) 执行上面的安装和启动后，就可以使用MySQL了。 ","date":"2023-07-11","objectID":"/install-mysql/:3:0","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 登录MySQL mysql -uroot -p ","date":"2023-07-11","objectID":"/install-mysql/:3:1","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 创建数据库 create database mysite DEFAULT CHARSET utf8 COLLATE utf8_general_ci; ","date":"2023-07-11","objectID":"/install-mysql/:3:2","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 查看数据库 show databases; ","date":"2023-07-11","objectID":"/install-mysql/:3:3","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 选择数据库 use mysite; ","date":"2023-07-11","objectID":"/install-mysql/:3:4","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 创建表 CREATE TABLE `app_userinfo` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(255) NOT NULL, `password` varchar(255) NOT NULL, `email` varchar(255) NOT NULL, `is_active` tinyint(1) NOT NULL, `is_staff` tinyint(1) NOT NULL, `is_superuser` tinyint(1) NOT NULL, `date_joined` datetime NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`), UNIQUE KEY `email` (`email`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; ","date":"2023-07-11","objectID":"/install-mysql/:3:5","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"- 查看表 desc app_userinfo; ","date":"2023-07-11","objectID":"/install-mysql/:3:6","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"参考 【Mac安装MySQL】","date":"2023-07-11","objectID":"/install-mysql/:4:0","tags":["mysql"],"title":"Mac安装MySQL及简单使用","uri":"/install-mysql/"},{"categories":["工具"],"content":"fastlane简介 fastlane是一个用来自动化打包和发布的工具,可以用来自动化打包,上传到App Store或者TestFlight,也可以用来自动化发布到fir或者蒲公英等平台,还可以用来自动化生成icon和splash等等,总之,fastlane是一个非常强大的工具,可以大大提高开发效率,减少出错的概率,下面就来介绍一下fastlane的使用 ","date":"2023-07-04","objectID":"/fastlane-package/:1:0","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["工具"],"content":"使用 ","date":"2023-07-04","objectID":"/fastlane-package/:2:0","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["工具"],"content":"安装 使用brew安装 brew install fastlane ","date":"2023-07-04","objectID":"/fastlane-package/:2:1","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["工具"],"content":"初始化 在项目根目录下执行 fastlane init 然后选择2来初始化fastlane配置文件,这样就会在项目根目录下生成一个fastlane文件夹,里面有一个Fastfile文件,这个文件就是fastlane的配置文件,我们可以在这个文件中配置自动化打包的一些参数,比如bundleId等等,也可以在这个文件中配置自动化上传到App Store或者TestFlight等等,具体的配置可以参考fastlane官方文档 ","date":"2023-07-04","objectID":"/fastlane-package/:2:2","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["工具"],"content":"以下是我自己上传到蒲公英的脚本 工程自动签名: ENV[\"FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT\"] = \"120\" # 设置超时时间,不然会报超时错误 default_platform(:ios) platform :ios do desc \"Description of what the lane does\" lane :beta do gym( export_method: \"ad-hoc\", scheme: \"XXX\", # 项目的scheme configuration: \"Release\" ) pgyer(api_key: \"xxx\") # 蒲公英的api_key,可到蒲公英网站查看 end end 工程手动签名: ENV[\"FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT\"] = \"120\" # 设置超时时间,不然会报超时错误 default_platform(:ios) platform :ios do desc \"Description of what the lane does\" lane :beta do increment_build_number gym( output_directory: \"./fastlane/\", # 打包后的ipa文件存放的路径 export_method: \"ad-hoc\", scheme: \"XXX\", # 项目的scheme export_options: { provisioningProfiles: { \"包名\" =\u003e \"描述文件名称\" } }, configuration: \"Release\" ) pgyer(api_key: \"蒲公英的api_key\") end end 打包的时候到项目根目录执行: fastlane beta ","date":"2023-07-04","objectID":"/fastlane-package/:3:0","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["工具"],"content":"二次签名 准备好需要二次签名的ipa文件,然后执行以下命令: fastlane sigh resign --signing_identity \"iPhone Distribution: XXXX\" --provisioning_profile \"描述文件名称.mobileprovision\" --ipa \"需要二次签名的ipa文件路径\" --entitlements \"entitlements.plist\" --display_name \"显示名称\" --bundle_id \"包名\" --output_path \"输出路径\" 其中signing_identity是证书的名称,可以在钥匙串中查看,provisioning_profile是描述文件的名称,可以在~/Library/MobileDevice/Provisioning Profiles目录下查看,ipa是需要二次签名的ipa文件路径,entitlements是entitlements文件的路径,display_name是显示名称,bundle_id是包名,output_path是输出路径 ","date":"2023-07-04","objectID":"/fastlane-package/:4:0","tags":["iOS"],"title":"Fastlane打包","uri":"/fastlane-package/"},{"categories":["前端"],"content":"升级electron到最新版本 sudo npm install electron@latest 升级electron-packager到最新版本 sudo npm install electron-packager@latest 升级electron-builder到最新版本 sudo npm install electron-builder@latest ","date":"2023-06-08","objectID":"/electron/:0:0","tags":[],"title":"Electron","uri":"/electron/"},{"categories":["前端"],"content":"问题 当文本是链接时候,会超出组件显示,如下图,红色为text组件: 超出组件 ","date":"2023-05-31","objectID":"/text-word-break/:1:0","tags":["uniapp","vue"],"title":"Text组件显示链接文本超出组件","uri":"/text-word-break/"},{"categories":["前端"],"content":"解决 /* 单词换行 */ word-break: break-all; ","date":"2023-05-31","objectID":"/text-word-break/:2:0","tags":["uniapp","vue"],"title":"Text组件显示链接文本超出组件","uri":"/text-word-break/"},{"categories":["前端"],"content":"uni小程序弹出组件滑动穿透问题解决方案 示例: @touchmove.stop.prevent=\"moveStop\" \u003cview @touchmove.stop.prevent=\"moveStop\"\u003e \u003cu-popup :show=\"show\" class=\"approval-popup\" mode=\"bottom\" :round=\"18\" @close=\"close\"\u003e \u003c/u-popup\u003e \u003c/view\u003e const moveStop = (e) =\u003e { e.stopPropagation(); }; ","date":"2023-05-18","objectID":"/uni-popup-sliding-penetration/:1:0","tags":["uniapp","vue"],"title":"Uni Popup等弹出组件滑动穿透问题","uri":"/uni-popup-sliding-penetration/"},{"categories":["前端"],"content":"uni-popup 带圆角的情况下，底部安全区域问题 官方自带了一个popup组件，但是在ios手机上，如果popup组件带圆角，会出现底部安全区域问题，如下图所示： 底部安全区域问题 ","date":"2023-05-18","objectID":"/uni-popup-safearea/:1:0","tags":["uniapp","vue"],"title":"Uni Popup组件底部安全区域问题","uri":"/uni-popup-safearea/"},{"categories":["前端"],"content":"解决方案 :safeArea=false \u003cuni-popup type=\"bottom\" :safeArea=false\u003e \u003cview class=\"content\"\u003e \u003cview\u003e标题\u003c/view\u003e \u003cview\u003e内容\u003c/view\u003e \u003c/view\u003e \u003c/uni-popup\u003e .content { background-color: #fff; border-radius: 20upx 20upx 0 0; /*兼容 IOS\u003c11.2*/ padding-bottom: constant(safe-area-inset-bottom); /*兼容 IOS\u003e11.2*/ padding-bottom: env(safe-area-inset-bottom); } ","date":"2023-05-18","objectID":"/uni-popup-safearea/:2:0","tags":["uniapp","vue"],"title":"Uni Popup组件底部安全区域问题","uri":"/uni-popup-safearea/"},{"categories":["移动端"],"content":"退到后台通知引起的崩溃 不排除是特定版本的iOS系统bug ","date":"2023-05-17","objectID":"/background-crash/:1:0","tags":["iOS"],"title":"退到后台通知引起的崩溃","uri":"/background-crash/"},{"categories":["移动端"],"content":"解决 @objc func appDidEnterBackground() { // 要判断当前应用程序状态是否为后台状态 guard UIApplication.shared.applicationState == .background else { return } // todo something } ","date":"2023-05-17","objectID":"/background-crash/:2:0","tags":["iOS"],"title":"退到后台通知引起的崩溃","uri":"/background-crash/"},{"categories":["前端"],"content":"异步函数调用this找不到方法 that 一下; const that = this; promise { then(res =\u003e { that.xxx(); }) } ","date":"2023-05-10","objectID":"/uniapp-this/:1:0","tags":["uniapp","vue"],"title":"异步函数调用this找不到方法","uri":"/uniapp-this/"},{"categories":["前端"],"content":"Uni页面撑满整个view 设置了父元素高度100%后,没有撑满整个view,如下图所示: 示例 ","date":"2023-05-08","objectID":"/uniapp-full-view/:1:0","tags":["uniapp","vue"],"title":"Uni页面撑满整个view","uri":"/uniapp-full-view/"},{"categories":["前端"],"content":"解决方法 增加如下样式代码,uni-page-body,html,body{height:100%}: \u003cstyle lang=\"scss\" scoped\u003e uni-page-body,html,body{height:100%} .page { display: flex; background-color: #FFFFFF; height: 100%; } \u003c/style\u003e ","date":"2023-05-08","objectID":"/uniapp-full-view/:2:0","tags":["uniapp","vue"],"title":"Uni页面撑满整个view","uri":"/uniapp-full-view/"},{"categories":["前端"],"content":"效果 效果 ","date":"2023-05-08","objectID":"/uniapp-full-view/:3:0","tags":["uniapp","vue"],"title":"Uni页面撑满整个view","uri":"/uniapp-full-view/"},{"categories":["前端"],"content":"v-show在微信小程序中不生效 \u003cstyle lang=\"scss\" scoped\u003e /* #ifdef MP-WEIXIN */ view[hidden] { display: none !important; } /* #endif */ \u003c/style\u003e 【具体原因】","date":"2023-05-08","objectID":"/uniapp-v-show/:1:0","tags":["uniapp","vue"],"title":"v-show在微信小程序中不生效","uri":"/uniapp-v-show/"},{"categories":["前端"],"content":"v-show在微信小程序中不生效 【v-show在微信小程序中不生效】 ","date":"2023-05-08","objectID":"/uniapp-question/:1:0","tags":["uniapp","vue"],"title":"Uni开发遇到的一些问题汇总","uri":"/uniapp-question/"},{"categories":["前端"],"content":"Uni页面撑满整个view,设置高度100%无效 【Uni页面撑满整个view,设置高度100%无效】 ","date":"2023-05-08","objectID":"/uniapp-question/:2:0","tags":["uniapp","vue"],"title":"Uni开发遇到的一些问题汇总","uri":"/uniapp-question/"},{"categories":["移动端"],"content":"iOS原生API录音功能","date":"2023-04-23","objectID":"/ios-recorder/","tags":["iOS","AVFoundation"],"title":"iOS录音功能","uri":"/ios-recorder/"},{"categories":["移动端"],"content":"前言 iOS原生API录音功能 ","date":"2023-04-23","objectID":"/ios-recorder/:1:0","tags":["iOS","AVFoundation"],"title":"iOS录音功能","uri":"/ios-recorder/"},{"categories":["移动端"],"content":"代码 import AVFoundation class Recorder { var recorder: AVAudioRecorder? func startRecord() { let session = AVAudioSession.sharedInstance() do { try session.setCategory(.playAndRecord, mode: .default, options: []) try session.setActive(true, options: []) session.requestRecordPermission { [unowned self] allowed in DispatchQueue.main.async { if allowed { self.startRecording() } else { // failed to record! } } } } catch { // failed to record! } } func startRecording() { // 输出mav格式 let audioFilename = getDocumentsDirectory().appendingPathComponent(\"recording.wav\") let settings = [ AVFormatIDKey: Int(kAudioFormatLinearPCM), AVSampleRateKey: 44100, AVNumberOfChannelsKey: 2, AVEncoderAudioQualityKey: AVAudioQuality.high.rawValue ] do { recorder = try AVAudioRecorder(url: audioFilename, settings: settings) recorder?.record() } catch { finishRecording(success: false) } } func finishRecording(success: Bool) { recorder?.stop() recorder = nil if success { print(\"Finished recording\") } else { print(\"Failed recording\") } } func getDocumentsDirectory() -\u003e URL { let paths = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask) return paths[0] } func stopRecord() { finishRecording(success: true) } } ","date":"2023-04-23","objectID":"/ios-recorder/:2:0","tags":["iOS","AVFoundation"],"title":"iOS录音功能","uri":"/ios-recorder/"},{"categories":["移动端"],"content":"使用 let recorder = Recorder() // 初始化 recorder.startRecord() // 开始录音 recorder.stopRecord() // 结束录音 ","date":"2023-04-23","objectID":"/ios-recorder/:3:0","tags":["iOS","AVFoundation"],"title":"iOS录音功能","uri":"/ios-recorder/"},{"categories":["移动端"],"content":"使用form-data上传 private func recordComplete() { // 1. 获取录音文件 let filePath = recorder.getDocumentsDirectory().appendingPathComponent(\"recording.wav\") // 2. 上传录音文件地址 let uploadUrl = \"http://xxx.com/upload\" // 3. 设置请求头 let headers: HTTPHeaders = [ \"Content-type\": \"multipart/form-data\", \"Accept\": \"application/json\", ] // 4. 使用alamofire上传 AF.upload(multipartFormData: { (multipartFormData) in multipartFormData.append(filePath, withName: \"file\", fileName: \"recoding.wav\", mimeType: \"audio/wav\") }, to: uploadUrl, method: .post, headers: headers).responseJSON { (response) in switch response.result { case .success(let value): print(value) case .failure(let error): print(\"error: \\(error)\") } } } ","date":"2023-04-23","objectID":"/ios-recorder/:4:0","tags":["iOS","AVFoundation"],"title":"iOS录音功能","uri":"/ios-recorder/"},{"categories":["工具"],"content":"收集一些AI生产力工具，方便自己和大家使用。","date":"2023-04-14","objectID":"/ai/","tags":["AI"],"title":"AI生产力工具","uri":"/ai/"},{"categories":["工具"],"content":"AI语言 【Poe】(chatgpt-4部分收费其他免费) ","date":"2023-04-14","objectID":"/ai/:1:0","tags":["AI"],"title":"AI生产力工具","uri":"/ai/"},{"categories":["工具"],"content":"AI编程 【Copilot】(收费) ","date":"2023-04-14","objectID":"/ai/:2:0","tags":["AI"],"title":"AI生产力工具","uri":"/ai/"},{"categories":["工具"],"content":"AI抠图 【lama-cleaner】(开源)","date":"2023-04-14","objectID":"/ai/:3:0","tags":["AI"],"title":"AI生产力工具","uri":"/ai/"},{"categories":["移动端"],"content":"前言 记录Xcode等相关的问题 ","date":"2023-04-03","objectID":"/xocde14.3-error/:1:0","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["移动端"],"content":"Xcode14.3 报错 ","date":"2023-04-03","objectID":"/xocde14.3-error/:2:0","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["移动端"],"content":"更新后先重置下pod文件 在podfile文件中增加如下: post_install do |installer| installer.generated_projects.each do |project| project.targets.each do |target| target.build_configurations.each do |config| config.build_settings['IPHONEOS_DEPLOYMENT_TARGET'] = '11.0' end end end end 然后依次执行: pod deintegrate pod install 编译看是否报错? 其他报错看下面继续: ","date":"2023-04-03","objectID":"/xocde14.3-error/:2:1","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["移动端"],"content":"Xcode14.3 编译报错(手动修改为11.0) pod第三方库的支持版本改为11.0以上 设置版本 ","date":"2023-04-03","objectID":"/xocde14.3-error/:2:2","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["移动端"],"content":"Xcode14.3 打包报错command phasescriptexecution failed with a nonzero exit code 如图脚本文件增加 -f 示例 更新: 新版本cocoapods已修复此问题, 无需手动修改 ","date":"2023-04-03","objectID":"/xocde14.3-error/:2:3","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["移动端"],"content":"iOS13系统闪退问题 最新发现, 已退回14.2 , 坑! 崩溃日志: Date/Time: 2023-04-06 10:25:29.5699 +0800 Launch Time: 2023-04-06 10:25:29.5246 +0800 OS Version: iPhone OS 13.7 (17H35) Release Type: User Baseband Version: 7.70.01 Report Version: 104 Exception Type: EXC_CRASH (SIGABRT) Exception Codes: 0x0000000000000000, 0x0000000000000000 Exception Note: EXC_CORPSE_NOTIFY Termination Description: DYLD, Assertion failed: (gotLocation), function applyFixupsToImage_block_invoke_3, file /Library/Caches/com.apple.xbs/Sources/dyld/dyld-750.4.2/dyld3/Loading.cpp, line 779. Highlighted by Thread: 0 Backtrace not available Unknown thread crashed with ARM Thread State (64-bit): x0: 0x0000000000000006 x1: 0x0000000000000009 x2: 0x000000016d117e70 x3: 0x0000000000000014 x4: 0x000000016d117a70 x5: 0x0000000000000000 x6: 0x000000016d1187f0 x7: 0x000000016d118908 x8: 0x0000000000000020 x9: 0x0000000000000009 x10: 0x2e342e3035372d64 x11: 0x2f33646c79642f32 x12: 0x2f33646c79642f32 x13: 0x2e676e6964616f4c x14: 0x6e696c202c707063 x15: 0x000a2e3937372065 x16: 0x0000000000000209 x17: 0x0000000000000000 x18: 0x0000000000000000 x19: 0x0000000000000000 x20: 0x000000016d117a70 x21: 0x0000000000000014 x22: 0x000000016d117e70 x23: 0x0000000000000009 x24: 0x0000000000000006 x25: 0x0000000000000392 x26: 0x000000000000030a x27: 0x000000010758ac70 x28: 0x0000000000117cf0 fp: 0x000000016d117a40 lr: 0x000000010784fee8 sp: 0x000000016d117a00 pc: 0x0000000107848f68 cpsr: 0x40000000 esr: 0x00000000 Address size fault Binary images description not available Error Formulating Crash Report: Failed to create CSSymbolicatorRef - corpse still valid ¯\\_(ツ)_/¯ EOF ","date":"2023-04-03","objectID":"/xocde14.3-error/:2:4","tags":["Xcode14","ios"],"title":"Xcode14.3问题记录","uri":"/xocde14.3-error/"},{"categories":["工具"],"content":"前言 习惯了用MAC电脑进行工作开发,搬砖的辅助生产工具也是必不可少,根据自己的经验分享一些常用的软件或者技巧,提升开发效率. ","date":"2023-03-16","objectID":"/mac-environment/:1:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"终端 【iterm2】 ","date":"2023-03-16","objectID":"/mac-environment/:2:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"iterm2快捷键 快捷键组合 说明 ctrl + a 到行首 ctrl + e 行末 ctrl + u 删除一行 ⌘ + r（ctrl + l） 清屏，其实是滚到新的一屏，并没有清空。 ctrl + r 搜索命令历史，这个大家都应该很熟悉了 ctrl + d 删除当前字符 ctrl + h 删除之前的字符 ctrl + w 删除光标前的单词 ctrl + k 删除到文本末尾 ctrl + t 交换光标处文本 ⌘ + —/+/0 调整字体大小 ctrl + f/b 前进后退，相当于左右方向键，但是显然比移开手按方向键更快 ctrl + p 上一条命令，相当于方向键上 ","date":"2023-03-16","objectID":"/mac-environment/:2:1","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"窗口操作 新建窗口： shift + command + d（横向）command + d（竖向） 关闭窗口： shift + command + w 前一个窗口： command + ` 后一个窗口： command + ~ 进入窗口 1,2,3： option + command + 编号 ","date":"2023-03-16","objectID":"/mac-environment/:2:2","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"标签页操作 新建标签页: Command + T 关闭标签页: Command + W 前一个标签页: Command + 左方向键，Shift + Command + [ 后一个标签页: Command + 右方向键，Shitf + Command + ] 进入标签页1，2，3…: Command + 标签页编号 Expose 标签页: Option + Command + E（将标签页打撒到全屏，并可以全局搜索所有的标签页） ","date":"2023-03-16","objectID":"/mac-environment/:2:3","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"面板操作 垂直分割: Command + D 水平分割: Shift + Command + D 前一个面板: Command + [ 后一个面板: Command + ] 切换到上/下/左/右面板: Option + Command + 上下左右方向键 ","date":"2023-03-16","objectID":"/mac-environment/:2:4","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"tree brew install tree tree ","date":"2023-03-16","objectID":"/mac-environment/:3:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"oh-my-zsh curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh 打开 .zshrc文件 修改插件配置(自带插件) plugins=(colored-man-pages pod git git-flow ruby gem python pip node npm bower sublime) ","date":"2023-03-16","objectID":"/mac-environment/:4:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"新增其他插件,比如zsh-syntax-highlighting高亮插件 cd ~/.oh-my-zsh/custom/plugins git clone https://github.com/zsh-users/zsh-syntax-highlighting.git 再次修改.zshrc文件插件配置 在sublime后面加上zsh-syntax-highlighting 然后执行 source ~/.zshrc 比如执行 pod install pod install ","date":"2023-03-16","objectID":"/mac-environment/:4:1","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"Go2Shell 快捷打开当前文件路径的终端,并且支持iterm2 【官网】 效果如下: Go2Shell ","date":"2023-03-16","objectID":"/mac-environment/:5:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"Xcodes 【Xcodes】 非常方便的管理Xcode的工具,优点: 不必等苹果商店更新 可安装测试版本 多版本安装 下载快,不会卡99% Xcodes ","date":"2023-03-16","objectID":"/mac-environment/:6:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"MAC自带邮箱增加QQ邮箱 首先登录网页端QQ邮箱,然后到设置中生成授权码,在mac中添加QQ邮箱时密码填授权码即可. 授权码 ","date":"2023-03-16","objectID":"/mac-environment/:7:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"超级右键lite 超级右键 ","date":"2023-03-16","objectID":"/mac-environment/:8:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"Snipaste 超好用的截图贴板工具 【Snipaste】 snipaste ","date":"2023-03-16","objectID":"/mac-environment/:9:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"抓包工具 Windows平台有finder Mac平台有Charles 都是比较常用的,因为我是mac刚开始用的也是Charles,但是因为公司路由器等原因,经常性的无法抓包,这里分享另一个开源工具 【Whistle】 ","date":"2023-03-16","objectID":"/mac-environment/:10:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"1.安装 npm install -g whistle ","date":"2023-03-16","objectID":"/mac-environment/:10:1","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"2.启动 w2 start 默认是8899端口,如果需要修改端口,可以在启动命令后面加上端口号,比如 w2 start -p 8888 启动之后可以在浏览器中输入终端提示链接打开抓包工具 启动 ","date":"2023-03-16","objectID":"/mac-environment/:10:2","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"3.停止 w2 stop ","date":"2023-03-16","objectID":"/mac-environment/:10:3","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"3.手机配置 手机连接电脑,打开wifi,选择电脑的wifi 手机设置代理,代理地址填写电脑的ip地址,端口号填写8899 手机用safari输入rootca.pro下载证书,安装证书,也可以到网页设置页面扫码安装如下图 到手机的设置中,找到通用-\u003e关于本机-\u003e证书信任设置,找到刚才安装的证书,打开信任开关 电脑打开http://localhost:8899/点击左侧network-\u003eenable开启抓包 扫码安装证书 抓包 技巧 如果证书配置成功,但是抓包不成功,并且网络也正常,但是手机却无法访问网络,这时候可以尝试关闭电脑的wifi,然后再打开,这样手机就可以访问网络了 ","date":"2023-03-16","objectID":"/mac-environment/:10:4","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"4.mock数据 mock数据 ","date":"2023-03-16","objectID":"/mac-environment/:10:5","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"markdown工具 ","date":"2023-03-16","objectID":"/mac-environment/:11:0","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["工具"],"content":"Typora 【Typora】 优点: 支持实时预览 支持导出多种格式 图片资源管理,解决了markdown图片资源管理的痛点 ","date":"2023-03-16","objectID":"/mac-environment/:11:1","tags":[],"title":"MAC工作环境","uri":"/mac-environment/"},{"categories":["移动端"],"content":"前言 在阅读Telegram源码的过程中,抽出业务代码,留下有用的代码,同时也修改或总结一些自己遇到的好用的方法. ","date":"2023-02-21","objectID":"/string-extension/:1:0","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"货币字符串 ","date":"2023-02-21","objectID":"/string-extension/:2:0","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"数字格式化 去除其他字符,只留数字 public func numeralFormat() -\u003e String { return replacingOccurrences(of:\"[^0-9]\", with: \"\", options: .regularExpression) } ","date":"2023-02-21","objectID":"/string-extension/:2:1","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"判断是否是表示0的字符串 比如 “0”,“0.0” 字符串表示的值都是0 public var representsZero: Bool { return numeralFormat().replacingOccurrences(of: \"0\", with: \"\").count == 0 } ","date":"2023-02-21","objectID":"/string-extension/:2:2","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"是否包含数字 public var hasNumbers: Bool { return numeralFormat().count \u003e 0 } ","date":"2023-02-21","objectID":"/string-extension/:2:3","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"字符串最后的索引到最后一个数字的偏移 从结束索引到字符串最后一个数字之后的索引的偏移量。 例如，对于字符串\"123some\"，最后一个数字位置是4，因为从字符串结束索引到3的索引 偏移量为4，“e, m, o and s” public var lastNumberOffsetFromEnd: Int? { guard let indexOfLastNumber = lastIndex(where: { $0.isNumber }) else { return nil } let indexAfterLastNumber = index(after: indexOfLastNumber) return distance(from: endIndex, to: indexAfterLastNumber) } ","date":"2023-02-21","objectID":"/string-extension/:2:4","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"更新货币字符串的十进制分隔符位置 decimalDigits:货币格式化字符串的小数位数 mutating public func updateDecimalSeparator(decimalDigits: Int) { guard decimalDigits != 0 \u0026\u0026 count \u003e= decimalDigits else { return } let decimalsRange = index(endIndex, offsetBy: -decimalDigits)..\u003cendIndex let decimalChars = self[decimalsRange] replaceSubrange(decimalsRange, with: \".\" + decimalChars) } ","date":"2023-02-21","objectID":"/string-extension/:2:5","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"补齐字符串 ","date":"2023-02-21","objectID":"/string-extension/:3:0","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":["移动端"],"content":"十六进制对齐 右对齐 func rightJustified(width: Int, pad: String = \" \", truncate: Bool = false) -\u003e String { guard width \u003e count else { return truncate ? String(suffix(width)) : self } return String(repeating: pad, count: width - count) + self } 左对齐 func leftJustified(width: Int, pad: String = \" \", truncate: Bool = false) -\u003e String { guard width \u003e count else { return truncate ? String(prefix(width)) : self } return self + String(repeating: pad, count: width - count) } 例如联动 Color的十六进制字符串 以黑色(#000000)为例: String(UIColor.black.rgb, radix: 16) // print 0 String(UIColor.black.rgb, radix: 16, uppercase: false).rightJustified(width: 6,pad: \"0\") // print 000000 ","date":"2023-02-21","objectID":"/string-extension/:3:1","tags":["String","iOS"],"title":"String的一些扩展","uri":"/string-extension/"},{"categories":[],"content":"脚本配置Xray 配置xray ","date":"2023-02-15","objectID":"/tools/:1:0","tags":[],"title":"工具","uri":"/tools/"},{"categories":["移动端"],"content":"UIColor的一些功能扩展,获取属性值以及初始化等方法","date":"2023-02-02","objectID":"/uicolor-extension/","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"前言 在阅读Telegram源码的过程中,抽出业务代码,留下有用的代码,同时也修改或总结一些自己遇到的好用的方法. ","date":"2023-02-02","objectID":"/uicolor-extension/:1:0","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"颜色 wiki 红绿蓝三原色 (RGB) 发光的媒体（比如电视机）使用红、绿 和蓝加色的三元色，每种光尽可能只刺激针对它们的锥状细胞而不刺激其它的锥状细胞。这个系统的色域占人可以感受到的色彩空间的大部分，因此电视机和电脑萤幕使用这个系统。 理论上我们也可以使用其他颜色作为元色，但使用红、绿和蓝我们可以最大地达到人的色彩空间。遗憾的是对于红、绿和蓝色没有固定的波长的定义，因此不同的技术仪器可能使用不同的波长从而在萤幕上产生稍微不同的颜色。 色相、色度和明度系统 (HSB) 在制作计算机图像时人们往往使用另一种颜色系统。这个颜色系统使用三项分类，分别叫做色相（hue）、色度（saturation）和明度（brightness）的系数。色调决定到底哪一种颜色被使用，色度决定颜色的纯度，亮度决定颜色的明暗程度 参考wiki ","date":"2023-02-02","objectID":"/uicolor-extension/:2:0","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"UIColor初始化扩展 rgb argb hex数值或者字符串颜色值的初始化 convenience init(rgb: UInt64) { self.init(red: CGFloat((rgb \u003e\u003e 16) \u0026 0xff) / 255.0, green: CGFloat((rgb \u003e\u003e 8) \u0026 0xff) / 255.0, blue: CGFloat(rgb \u0026 0xff) / 255.0, alpha: 1.0) } convenience init(rgb: UInt64, alpha: CGFloat) { self.init(red: CGFloat((rgb \u003e\u003e 16) \u0026 0xff) / 255.0, green: CGFloat((rgb \u003e\u003e 8) \u0026 0xff) / 255.0, blue: CGFloat(rgb \u0026 0xff) / 255.0, alpha: alpha) } convenience init(argb: UInt64) { self.init(red: CGFloat((argb \u003e\u003e 16) \u0026 0xff) / 255.0, green: CGFloat((argb \u003e\u003e 8) \u0026 0xff) / 255.0, blue: CGFloat(argb \u0026 0xff) / 255.0, alpha: CGFloat((argb \u003e\u003e 24) \u0026 0xff) / 255.0) } convenience init?(hex: String) { let scanner = Scanner(string: hex) if hex.hasPrefix(\"#\") { scanner.scanLocation = 1 } var value: UInt64 = 0 if scanner.scanHexInt64(\u0026value) { if hex.count \u003e 7 { self.init(argb: value) } else { self.init(rgb: value) } } else { return nil } } 位移运算 左移:\u003c\u003c,右移:\u003e\u003e 对一个数进行按位左移或按位右移，相当于对这个数进行乘以 2 或除以 2 的运算。将一个整数左移一位，等价于将这个数乘以 2，同样地，将一个整数右移一位，等价于将这个数除以 2。 十六进制一个字符4位,例如 #AABBCC AA代表红,BB代表绿,CC代表蓝,三个值分别都以255为基数,要得到AA的值,可以按位与\u00260xFF0000 取反再右移16位的到0xAA即十进制170. ","date":"2023-02-02","objectID":"/uicolor-extension/:3:0","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"属性扩展 ","date":"2023-02-02","objectID":"/uicolor-extension/:4:0","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"alpha透明度 var alpha: CGFloat { var alpha: CGFloat = 0.0 if self.getRed(nil, green: nil, blue: nil, alpha: \u0026alpha) { return alpha } else if self.getWhite(nil, alpha: \u0026alpha) { return alpha } else { return 0.0 } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:1","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"RGB值 var rgb: UInt64 { var red: CGFloat = 0.0 var green: CGFloat = 0.0 var blue: CGFloat = 0.0 if self.getRed(\u0026red, green: \u0026green, blue: \u0026blue, alpha: nil) { return (UInt64(max(0.0, red) * 255.0) \u003c\u003c 16) | (UInt64(max(0.0, green) * 255.0) \u003c\u003c 8) | (UInt64(max(0.0, blue) * 255.0)) } else if self.getWhite(\u0026red, alpha: nil) { return (UInt64(max(0.0, red) * 255.0) \u003c\u003c 16) | (UInt64(max(0.0, red) * 255.0) \u003c\u003c 8) | (UInt64(max(0.0, red) * 255.0)) } else { return 0 } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:2","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"ARGB值 var argb: UInt64 { var red: CGFloat = 0.0 var green: CGFloat = 0.0 var blue: CGFloat = 0.0 var alpha: CGFloat = 0.0 if self.getRed(\u0026red, green: \u0026green, blue: \u0026blue, alpha: \u0026alpha) { return (UInt64(alpha * 255.0) \u003c\u003c 24) | (UInt64(max(0.0, red) * 255.0) \u003c\u003c 16) | (UInt64(max(0.0, green) * 255.0) \u003c\u003c 8) | (UInt64(max(0.0, blue) * 255.0)) } else if self.getWhite(\u0026red, alpha: \u0026alpha) { return (UInt64(max(0.0, alpha) * 255.0) \u003c\u003c 24) | (UInt64(max(0.0, red) * 255.0) \u003c\u003c 16) | (UInt64(max(0.0, red) * 255.0) \u003c\u003c 8) | (UInt64(max(0.0, red) * 255.0)) } else { return 0 } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:3","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"HSB值 var hsb: (h: CGFloat, s: CGFloat, b: CGFloat) { var hue: CGFloat = 0.0 var saturation: CGFloat = 0.0 var brightness: CGFloat = 0.0 if self.getHue(\u0026hue, saturation: \u0026saturation, brightness: \u0026brightness, alpha: nil) { return (hue, saturation, brightness) } else { return (0.0, 0.0, 0.0) } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:4","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"明度值 var lightness: CGFloat { var red: CGFloat = 0.0 var green: CGFloat = 0.0 var blue: CGFloat = 0.0 if self.getRed(\u0026red, green: \u0026green, blue: \u0026blue, alpha: nil) { return 0.2126 * red + 0.7152 * green + 0.0722 * blue } else if self.getWhite(\u0026red, alpha: nil) { return red } else { return 0.0 } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:5","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"HEX字符串 var hexString: String { return String(rgb, radix: 16, uppercase: false).rightJustified(width: 6, pad: \"0\") } rightJustified extension String { func rightJustified(width: Int, pad: String = \" \", truncate: Bool = false) -\u003e String { guard width \u003e count else { return truncate ? String(suffix(width)) : self } return String(repeating: pad, count: width - count) + self } } ","date":"2023-02-02","objectID":"/uicolor-extension/:4:6","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"方法扩展 ","date":"2023-02-02","objectID":"/uicolor-extension/:5:0","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"改变亮度明度(根据传入系数使亮度明度乘积得到新颜色) func withMultipliedBrightnessBy(_ factor: CGFloat) -\u003e UIColor { var hue: CGFloat = 0.0 var saturation: CGFloat = 0.0 var brightness: CGFloat = 0.0 var alpha: CGFloat = 0.0 self.getHue(\u0026hue, saturation: \u0026saturation, brightness: \u0026brightness, alpha: \u0026alpha) return UIColor(hue: hue, saturation: saturation, brightness: max(0.0, min(1.0, brightness * factor)), alpha: alpha) } 如下调整.red红色亮度比例从左到右分别为0.3,0.6,1(不改变) override func viewDidLoad() { super.viewDidLoad() let bgView1 = UIView(frame: CGRectMake(17, 100, 100, 100)) bgView1.backgroundColor = .red.withMultipliedBrightnessBy(0.3) self.view.addSubview(bgView1) let bgView2 = UIView(frame: CGRectMake(127, 100, 100, 100)) bgView2.backgroundColor = .red.withMultipliedBrightnessBy(0.6) self.view.addSubview(bgView2) let bgView3 = UIView(frame: CGRectMake(237, 100, 100, 100)) bgView3.backgroundColor = .red.withMultipliedBrightnessBy(1) self.view.addSubview(bgView3) } withMultipliedBrightnessBy ","date":"2023-02-02","objectID":"/uicolor-extension/:5:1","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"改变HSB值 func withMultiplied(hue: CGFloat, saturation: CGFloat, brightness: CGFloat) -\u003e UIColor { var hueValue: CGFloat = 0.0 var saturationValue: CGFloat = 0.0 var brightnessValue: CGFloat = 0.0 var alphaValue: CGFloat = 0.0 self.getHue(\u0026hueValue, saturation: \u0026saturationValue, brightness: \u0026brightnessValue, alpha: \u0026alphaValue) return UIColor(hue: max(0.0, min(1.0, hueValue * hue)), saturation: max(0.0, min(1.0, saturationValue * saturation)), brightness: max(0.0, min(1.0, brightnessValue * brightness)), alpha: alphaValue) } 如下调整.red颜色HSB值 private func setupViews2() { let bgView1 = UIView(frame: CGRectMake(17, 100, 100, 100)) bgView1.backgroundColor = .red.withMultiplied(hue: 1.034, saturation: 0.819, brightness: 0.633) self.view.addSubview(bgView1) let bgView2 = UIView(frame: CGRectMake(127, 100, 100, 100)) bgView2.backgroundColor = .red.withMultiplied(hue: 1.029, saturation: 0.77, brightness: 0.332) self.view.addSubview(bgView2) let bgView3 = UIView(frame: CGRectMake(237, 100, 100, 100)) bgView3.backgroundColor = .red.withMultiplied(hue: 1.034, saturation: 0.583, brightness: 1.234) self.view.addSubview(bgView3) } withMultiplied ","date":"2023-02-02","objectID":"/uicolor-extension/:5:2","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"混合颜色(alpha合成) 说明 RGB混合算法目前在常用到的算法是AlphaBlend. 计算公式如下:假设一幅图象是A，另一幅透明的图象是B，那么透过B去看A，看上去的图象C就是B和A的混合图象，设B图象的透明度为alpha(取值为0-1，1为完全透明，0为完全不透明). Alpha混合公式如下： R(C)=(1-alpha)*R(B) + alpha*R(A) G(C)=(1-alpha)*G(B) + alpha*G(A) B(C)=(1-alpha)*B(B) + alpha*B(A) R(x)、G(x)、B(x)分别指颜色x的RGB分量原色值。从上面的公式可以知道，Alpha其实是一个决定混合透明度的数值。 这里只对B图的Alpha进行了处理，但A图本身如果也有透明通道的，也需要进行一样的处理，即 A(C)=(1-alpha)*A(B) + alpha*A(A) 【验证链接】 【wiki】 【参考链接】 mixedWith func mixedWith(_ other: UIColor, alpha: CGFloat) -\u003e UIColor { let alpha = min(1.0, max(0.0, alpha)) let oneMinusAlpha = 1.0 - alpha var r1: CGFloat = 0.0 var r2: CGFloat = 0.0 var g1: CGFloat = 0.0 var g2: CGFloat = 0.0 var b1: CGFloat = 0.0 var b2: CGFloat = 0.0 var a1: CGFloat = 0.0 var a2: CGFloat = 0.0 if self.getRed(\u0026r1, green: \u0026g1, blue: \u0026b1, alpha: \u0026a1) \u0026\u0026 other.getRed(\u0026r2, green: \u0026g2, blue: \u0026b2, alpha: \u0026a2) { let r = r1 * oneMinusAlpha + r2 * alpha let g = g1 * oneMinusAlpha + g2 * alpha let b = b1 * oneMinusAlpha + b2 * alpha let a = a1 * oneMinusAlpha + a2 * alpha return UIColor(red: r, green: g, blue: b, alpha: a) } return self } 示例如下将0.5透明度的黄色覆盖到红色上面,透过上面的黄色看下面的红色,得到的颜色: private func setupViews3() { let bgView1 = UIView(frame: CGRectMake(17, 100, 100, 100)) bgView1.backgroundColor = .red self.view.addSubview(bgView1) let bgView2 = UIView(frame: CGRectMake(127, 100, 100, 100)) bgView2.backgroundColor = .yellow self.view.addSubview(bgView2) let bgView3 = UIView(frame: CGRectMake(237, 100, 100, 100)) bgView3.backgroundColor = .red.mixedWith(.yellow, alpha: 0.5) self.view.addSubview(bgView3) } mixedWith blitOver 和上面的mixedWith方法相反,表示覆盖到另一个颜色上面作为前景色. func blitOver(_ other: UIColor, alpha: CGFloat) -\u003e UIColor { let alpha = min(1.0, max(0.0, alpha)) var r1: CGFloat = 0.0 var r2: CGFloat = 0.0 var g1: CGFloat = 0.0 var g2: CGFloat = 0.0 var b1: CGFloat = 0.0 var b2: CGFloat = 0.0 var a1: CGFloat = 0.0 var a2: CGFloat = 0.0 if self.getRed(\u0026r1, green: \u0026g1, blue: \u0026b1, alpha: \u0026a1) \u0026\u0026 other.getRed(\u0026r2, green: \u0026g2, blue: \u0026b2, alpha: \u0026a2) { let resultingAlpha = max(0.0, min(1.0, alpha * a1)) let oneMinusResultingAlpha = 1.0 - resultingAlpha let r = r1 * resultingAlpha + r2 * oneMinusResultingAlpha let g = g1 * resultingAlpha + g2 * oneMinusResultingAlpha let b = b1 * resultingAlpha + b2 * oneMinusResultingAlpha let a: CGFloat = 1.0 return UIColor(red: r, green: g, blue: b, alpha: a) } return self } ","date":"2023-02-02","objectID":"/uicolor-extension/:5:3","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"调整透明度倍数 func withMultipliedAlpha(_ alpha: CGFloat) -\u003e UIColor { var r1: CGFloat = 0.0 var g1: CGFloat = 0.0 var b1: CGFloat = 0.0 var a1: CGFloat = 0.0 if self.getRed(\u0026r1, green: \u0026g1, blue: \u0026b1, alpha: \u0026a1) { return UIColor(red: r1, green: g1, blue: b1, alpha: max(0.0, min(1.0, a1 * alpha))) } return self } ","date":"2023-02-02","objectID":"/uicolor-extension/:5:4","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"篡改一个颜色到另一个颜色 说明 fraction取值范围为0~1,当为0时,返回当前颜色,当为1时,返回传入颜色. 从0到1的变化既是当前颜色到传入颜色的变化. func interpolateTo(_ color: UIColor, fraction: CGFloat) -\u003e UIColor? { let f = min(max(0, fraction), 1) var r1: CGFloat = 0.0 var r2: CGFloat = 0.0 var g1: CGFloat = 0.0 var g2: CGFloat = 0.0 var b1: CGFloat = 0.0 var b2: CGFloat = 0.0 var a1: CGFloat = 0.0 var a2: CGFloat = 0.0 if self.getRed(\u0026r1, green: \u0026g1, blue: \u0026b1, alpha: \u0026a1) \u0026\u0026 color.getRed(\u0026r2, green: \u0026g2, blue: \u0026b2, alpha: \u0026a2) { let r: CGFloat = CGFloat(r1 + (r2 - r1) * f) let g: CGFloat = CGFloat(g1 + (g2 - g1) * f) let b: CGFloat = CGFloat(b1 + (b2 - b1) * f) let a: CGFloat = CGFloat(a1 + (a2 - a1) * f) return UIColor(red: r, green: g, blue: b, alpha: a) } else { return self } } ","date":"2023-02-02","objectID":"/uicolor-extension/:5:5","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"欧氏距离 说明 很多日常使用的“颜色差异”，是直接通过在一个“设备无关”的色彩空间里，进行欧氏距离的计算得到的。给定一个RGB（红绿蓝）的色彩空间，最简单的差异计算方式就是在这个三维空间里求两个点间的距离. 有不少人尝试将RGB三值加上权重，希望可以让得到的结果更加符合人类感官。一种做法是使用2、4、3： 【wiki】 private var colorComponents: (r: Int64, g: Int64, b: Int64) { var r: CGFloat = 0.0 var g: CGFloat = 0.0 var b: CGFloat = 0.0 if self.getRed(\u0026r, green: \u0026g, blue: \u0026b, alpha: nil) { return (Int64(max(0.0, r) * 255.0), Int64(max(0.0, g) * 255.0), Int64(max(0.0, b) * 255.0)) } else if self.getWhite(\u0026r, alpha: nil) { return (Int64(max(0.0, r) * 255.0), Int64(max(0.0, r) * 255.0), Int64(max(0.0, r) * 255.0)) } return (0, 0, 0) } func distance(to other: UIColor) -\u003e Int64 { let e1 = self.colorComponents let e2 = other.colorComponents let rMean = (e1.r + e2.r) / 2 let r = e1.r - e2.r let g = e1.g - e2.g let b = e1.b - e2.b let a1 = ((512 + rMean) * r * r) \u003e\u003e 8 let b1 = 4 * g * g let c1 = ((767 - rMean) * b * b) \u003e\u003e 8 return a1 + b1 + c1 } ","date":"2023-02-02","objectID":"/uicolor-extension/:5:6","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"平均颜色 static func average(of colors: [UIColor]) -\u003e UIColor { var sr: CGFloat = 0.0 var sg: CGFloat = 0.0 var sb: CGFloat = 0.0 var sa: CGFloat = 0.0 for color in colors { var r: CGFloat = 0.0 var g: CGFloat = 0.0 var b: CGFloat = 0.0 var a: CGFloat = 0.0 color.getRed(\u0026r, green: \u0026g, blue: \u0026b, alpha: \u0026a) sr += r sg += g sb += b sa += a } return UIColor(red: sr / CGFloat(colors.count), green: sg / CGFloat(colors.count), blue: sb / CGFloat(colors.count), alpha: sa / CGFloat(colors.count)) } ","date":"2023-02-02","objectID":"/uicolor-extension/:5:7","tags":["iOS","UIColor"],"title":"UIColor的一些扩展","uri":"/uicolor-extension/"},{"categories":["移动端"],"content":"Swift中的只读属性,像OC一样隐藏set方法","date":"2023-02-01","objectID":"/swift-readonly/","tags":["iOS只读","Swift","OC"],"title":"iOS中的只读属性","uri":"/swift-readonly/"},{"categories":["移动端"],"content":"OC只读,Swift设置set私有private(set) public private(set) var someKey: String 当外部调用set方法时的报错信息: Cannot assign to property: 'somekey' setter is inaccessible OC表示只读readonly: @property (nonatomic, strong, readonly) NSString *someKey; ","date":"2023-02-01","objectID":"/swift-readonly/:1:0","tags":["iOS只读","Swift","OC"],"title":"iOS中的只读属性","uri":"/swift-readonly/"},{"categories":["移动端"],"content":"Telegram开源iOS端代码编译学习记录","date":"2023-01-28","objectID":"/telegram/","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"前言 Telegram开源IM应用,虽然服务器代码不开源,但是可以从客户端的体验来看非常流畅,故下载编译学习记录. ","date":"2023-01-28","objectID":"/telegram/:1:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"创建应用(只编译Xcode工程此步骤不需要看) 打开官网,选择API development tools API development tools 填写自己的电报号码登录,验证码为官方TG给你发条验证消息: TG账号登录 选择API,Getting started下面的Creating an application Creating an application 然后在表单页面填写应用信息,如App名称等,最后提交即可. 注意 如果提交的时候出现报错Error,需要科学上网(全局模式). 生成的应用示例: 示例 ","date":"2023-01-28","objectID":"/telegram/:2:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"源码下载 iOS地址 git clone --recursive -j8 https://github.com/TelegramMessenger/Telegram-iOS.git 提醒 此处加参数是为了拉取子模块,子模块要拉取完整后续才能编译成功. ","date":"2023-01-28","objectID":"/telegram/:3:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"环境设置 打开下载的项目文件夹,找到versions.json文件,并打开: { \"app\": \"9.3\", \"bazel\": \"5.3.1\", \"xcode\": \"14.1\" } 确认到环境为Xcode为14.1版本,bazel要求5.3.1 由于我已经安装Xcode14.2版本,所以这里编辑Xcode版本号为当前电脑已安装Xcode版本. 安装bazel: brew install bazel XXX(版本号) 如果提示没有版本号,可以去官网直接看文档下载安装. 如果你是第一次安装bazel到此环境问题就解决了,安装过的看下面👇🏻 由于bazel我是之前已经安装过(通过homebrew安装),默认为最新版本,需要切换为配置文件版本,不然后续编译会报错 brew tap bazelbuild/tap brew extract bazel bazelbuild/tap --version 5.3.2 brew install bazel@5.3.2 注意 当我执行如上发现brew并没有5.3.1版本,找到历史版本,发现比较接近的有5.3.2,将版本号修改并执行指令(versions.json文件中也修改一致,但是bazel版本不能和官方相差太大,会报错). 如果和我一样之前已经安装了新版本,需要链接到下载的旧版本: brew install bazelbuild/tap/bazel@5.3.2 brew link bazel@5.3.2 ","date":"2023-01-28","objectID":"/telegram/:4:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"编译Xcode工程 复制配置到电脑根目录 mkdir -p $HOME/telegram-configuration cp -R build-system/example-configuration/* $HOME/telegram-configuration/ cp -R build-system/appstore-configuration.json $HOME/telegram-configuration/ cp -R build-system/fake-codesigning/profiles $HOME/telegram-configuration/provisioning/ 创建缓存文件夹(可选) mkdir -p \"$HOME/telegram-bazel-cache\" 最终我的电脑根目录下结构如图所示: 目录结构 脚本生成 python3 build-system/Make/Make.py \\ --cacheDir=\"$HOME/telegram-bazel-cache\" \\ generateProject \\ --configurationPath=\"$HOME/telegram-configuration/appstore-configuration.json\" \\ --disableExtensions \\ --codesigningInformationPath=\"$HOME/telegram-configuration/provisioning\" python3 build-system/Make/Make.py –cacheDir=\"$HOME/telegram-bazel-cache\" generateProject –configurationPath=\"$HOME/telegram-configuration/appstore-configuration.json\" –codesigningInformationPath=\"$HOME/telegram-configuration/provisioning\" 到此Xcode工程成功生成,友情提示代码注释几乎没有… ","date":"2023-01-28","objectID":"/telegram/:5:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"真机运行问题 打开app,白屏或者黑屏,原因是app-group 没有添加,在Xcode工程配置上添加自己设置好的即可. ","date":"2023-01-28","objectID":"/telegram/:6:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"打包 打开HOME/telegram-configuration/路径下的variables.bzl(就是上一步复制到电脑根目录的配置文件的路径),原配置如下: telegram_bundle_id = \"ph.telegra.Telegraph\" telegram_api_id = \"8\" telegram_api_hash = \"7245de8e747a0d6fbe11f7cc14fcc0bb\" telegram_team_id = \"C67CF9S4VU\" telegram_app_center_id = \"0\" telegram_is_internal_build = \"false\" telegram_is_appstore_build = \"true\" telegram_appstore_id = \"686449807\" telegram_app_specific_url_scheme = \"tg\" telegram_premium_iap_product_id = \"org.telegram.telegramPremium.monthly\" telegram_aps_environment = \"production\" telegram_enable_siri = True telegram_enable_icloud = True telegram_enable_watch = True 待施工. 还没有进行打包. ","date":"2023-01-28","objectID":"/telegram/:7:0","tags":["Telegram","iOS"],"title":"Telegram-iOS编译打包","uri":"/telegram/"},{"categories":["移动端"],"content":"主要记录Xcode使用遇到的一些问题","date":"2023-01-17","objectID":"/xcode-question/","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"前言 本文主要记录Xcode使用遇到的一些问题,以及当时版本的解决方案. ","date":"2023-01-17","objectID":"/xcode-question/:1:0","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"Xcode下载 主要有两种途径: ","date":"2023-01-17","objectID":"/xcode-question/:2:0","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"方式1: App Store 苹果商店搜索Xcode即可下载. 优点: 可自动更新. 缺点: 安装的时候经常会遇到最后卡住,或者安装不上等问题. ","date":"2023-01-17","objectID":"/xcode-question/:2:1","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"方式2: 官网下载Xip包 下载地址,登录苹果账号进行下载. 优点: 弥补了方式1的缺点,并且历史版本也可以下载安装. 缺点: 无法自动更新下一个版本. ","date":"2023-01-17","objectID":"/xcode-question/:2:2","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"方式3: 使用Xcodes管理 【Xcodes】 非常方便的管理Xcode的工具,优点: 不必等苹果商店更新 可安装测试版本 多版本安装 下载快,不会卡99% Xcodes ","date":"2023-01-17","objectID":"/xcode-question/:2:3","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"重装Xcode之后,Cocoapods报错问题 ","date":"2023-01-17","objectID":"/xcode-question/:3:0","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"如下报错: /.rvm/rubies/ruby-3.0.0/lib/ruby/gems/3.0.0/gems/cocoapods-1.11.3/lib/cocoapods/command.rb:128:in `git_version': Failed to extract git version from `git --version` (\"xcrun: error: active developer path (\\\\\"/Users/wangzhu/Downloads/Xcode.app/Contents/Developer\\\\\") does not exist\\\\nUse `sudo xcode-select --switch path/to/Xcode.app` to specify the Xcode that you wish to use for command line developer tools, or use `xcode-select --install` to install the standalone command line developer tools.\\\\nSee `man xcode-select` for more details.\\\\n\") (RuntimeError) from /Users/wangzhu/.rvm/rubies/ruby-3.0.0/lib/ruby/gems/3.0.0/gems/cocoapods-1.11.3/lib/cocoapods/command.rb:140:in `verify_minimum_git_version!' from /Users/wangzhu/.rvm/rubies/ruby-3.0.0/lib/ruby/gems/3.0.0/gems/cocoapods-1.11.3/lib/cocoapods/command.rb:49:in `run' from /Users/wangzhu/.rvm/rubies/ruby-3.0.0/lib/ruby/gems/3.0.0/gems/cocoapods-1.11.3/bin/pod:55:in `\u003ctop (required)\u003e' from /usr/local/bin/pod:25:in `load' from /usr/local/bin/pod:25:in `\u003cmain\u003e' from /Users/wangzhu/.rvm/rubies/ruby-3.0.0/bin/ruby_executable_hooks:22:in `eval' from /Users/wangzhu/.rvm/rubies/ruby-3.0.0/bin/ruby_executable_hooks:22:in `\u003cmain\u003e' ","date":"2023-01-17","objectID":"/xcode-question/:3:1","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"解决办法: 1.终端执行下面命令 xcode-select --install admoni 2.然后尝试执行 pod --version 如果正常显示版本号,命令行工具已正常工作,到此解决.如果还是报错看步骤3. 3.到此如果cocoapods还是无法正常使用,执行上面步骤1提示如下: xcode-select: error: command line tools are already installed, use \"Software Update\" in System Settings to install updates 按照提示更新下工具: softwareupdate --install -a 执行步骤2查看版本号正常显示版本,到此解决. ","date":"2023-01-17","objectID":"/xcode-question/:3:2","tags":["iOS","Xcode"],"title":"Xcode相关问题记录","uri":"/xcode-question/"},{"categories":["移动端"],"content":"平时在开发中遇到需求或是在社区中发现了一些优秀且实用的iOS相关开源库","date":"2023-01-14","objectID":"/third-party/","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"前言 平时在开发中遇到需求或是在社区中发现了一些优秀且实用的iOS相关开源库时,我会进行记录.这些库涵盖了开发和完整项目应用两方面,并无特定排名.当发现有用的库时,我会立刻进行记录. 说明 本文没有排名，默认状态为维护中。如果停止维护，将会在其上面加上停止维护的提示。根据规则，如果一年及以上没有提交记录，将会判定为停止维护。时间截止以标注记录时间为准。如果你有优秀的库推荐,欢迎评论! ","date":"2023-01-14","objectID":"/third-party/:1:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"完整App ","date":"2023-01-14","objectID":"/third-party/:2:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"框架 名称 简述 语言 记录时间 维护情况 【Texture(AsyncDisplayKit)】 一款异步渲染的UI框架 Swift\u0026OC 2023.01.14 - 【QMUIKit】 是一个致力于提高项目UI开发效率的UI框架 OC 2023.01.14 - ","date":"2023-01-14","objectID":"/third-party/:3:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"UI 名称 简述 语言 记录时间 维护情况 【MJRefresh】 下拉/上拉刷新控件 OC 2023.01.17 - 【DeviceKit】 获取设备信息 Swift 2023.10.30 - ","date":"2023-01-14","objectID":"/third-party/:4:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"多线程 ","date":"2023-01-14","objectID":"/third-party/:5:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"网络 ","date":"2023-01-14","objectID":"/third-party/:6:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"数据存储 ","date":"2023-01-14","objectID":"/third-party/:7:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"动画 ","date":"2023-01-14","objectID":"/third-party/:8:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"多媒体 ","date":"2023-01-14","objectID":"/third-party/:9:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"图像 ","date":"2023-01-14","objectID":"/third-party/:10:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"安全 ","date":"2023-01-14","objectID":"/third-party/:11:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"工具 名称 简述 语言 记录时间 维护情况 ","date":"2023-01-14","objectID":"/third-party/:12:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"测试调试 ","date":"2023-01-14","objectID":"/third-party/:13:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"数据结构/算法","date":"2023-01-14","objectID":"/third-party/:14:0","tags":["iOS","开源"],"title":"iOS开源三方库汇总记录","uri":"/third-party/"},{"categories":["移动端"],"content":"UITableView使过程中遇到的一些问题记录","date":"2023-01-06","objectID":"/uitableview/","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["移动端"],"content":"UITableView的type ","date":"2023-01-06","objectID":"/uitableview/:1:0","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["移动端"],"content":"UITableView的类型(type) public enum Style : Int, @unchecked Sendable { case plain = 0 // 通用类 case grouped = 1 // 分组模式 @available(iOS 13.0, *) case insetGrouped = 2 // iOS13以后支持的API,给组加圆角,效果如下 } insetGrouped ","date":"2023-01-06","objectID":"/uitableview/:1:1","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["移动端"],"content":"iOS15系统之后type为grouped时,头部有间距 if #available(iOS 15.0, *) { tableView.sectionHeaderTopPadding = 0 } if (@available(iOS 15.0, *)) { _tableView.sectionHeaderTopPadding = 0; } ","date":"2023-01-06","objectID":"/uitableview/:1:2","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["移动端"],"content":"type为grouped时,组间距问题 func tableView(_ tableView: UITableView, heightForFooterInSection section: Int) -\u003e CGFloat { return 0 } func tableView(_ tableView: UITableView, viewForFooterInSection section: Int) -\u003e UIView? { return UIView() } ","date":"2023-01-06","objectID":"/uitableview/:1:3","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["移动端"],"content":"去除诡异动画 [UIView setAnimationsEnabled:false]; [CATransaction begin]; [CATransaction setCompletionBlock:^{ [UIView setAnimationsEnabled:true]; }]; [self.tableView beginUpdates]; [self.tableView insertRowsAtIndexPaths:addIndexPathes withRowAnimation:UITableViewRowAnimationNone]; [self.tableView endUpdates]; [CATransaction commit]; ","date":"2023-01-06","objectID":"/uitableview/:1:4","tags":["iOS"],"title":"UITableView使用记录","uri":"/uitableview/"},{"categories":["前端"],"content":"a元素的伪类,link 一般用来表示没有访问过的链接(正常的链接)","date":"2022-12-05","objectID":"/%E5%85%83%E7%B4%A0%E7%9A%84%E4%BC%AA%E7%B1%BB/","tags":["HTML"],"title":"Web学习笔记 - a元素的伪类","uri":"/%E5%85%83%E7%B4%A0%E7%9A%84%E4%BC%AA%E7%B1%BB/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* link 一般用来表示没有访问过的链接(正常的链接) */ a:link { color: red; } /* visited 用来表示访问过的链接 由于隐私的原因,visited这个伪类只能修改链接的颜色. */ a:visited { color: yellow; } /* :hover 用来表示鼠标移入的状态 */ a:hover { color: aqua; font-size: 50px; } /* :active 用来表示鼠标点击 */ a:active { color: blue; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 1.没有访问过的链接 2.访问过的链接 --\u003e \u003ca href=\"https://www.baidu.com\"\u003e访问过的链接\u003c/a\u003e \u003cbr\u003e \u003ca href=\"https://www.baidu.com123\"\u003e没有访问过的链接\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-05","objectID":"/%E5%85%83%E7%B4%A0%E7%9A%84%E4%BC%AA%E7%B1%BB/:0:0","tags":["HTML"],"title":"Web学习笔记 - a元素的伪类","uri":"/%E5%85%83%E7%B4%A0%E7%9A%84%E4%BC%AA%E7%B1%BB/"},{"categories":["前端"],"content":"复合选择器,关系选择器,属性选择器,伪类选择器,伪元素选择器","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"复合选择器 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* 将所有的段落设置为红色(字体) 元素选择器 作用,根据标签名来选中指定的元素 语法:标签名{} 例子:p{} h1{} dic{} */ /* p{ color: red; } h1{ color: red; } */ /* 将`儿童乡间不相识`设置红色 id选择器 作用:根据元素的id属性值选中一个元素 语法:#id属性值{} 例子:#box{} #red{} */ /* #red{ color: red; } */ /* 将`秋水共长天一色`和`落霞与孤鹜齐飞` 设置为红色 类选择器 作用:根据元素的class属性值选中一组元素 语法: .class属性值 例子: .bule .red .abc */ /* .red{ color: red; } .abc{ font-size: 15px; } */ /* 通配选择器 作用:选中页面中的所有元素 语法: * */ *{ color: red; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1 class=\"red\"\u003e我是标题\u003c/h1\u003e \u003cp\u003e少小离家老大回\u003c/p\u003e \u003cp\u003e乡音无改鬓毛衰\u003c/p\u003e \u003c!-- 多个类选择时使用空格隔开; --\u003e \u003cp class=\"red abc\"\u003e儿童相见不相识\u003c/p\u003e \u003cp\u003e笑问客从何处来\u003c/p\u003e \u003c!-- class 是一个标签的属性,它和id类似,不同的是class可以重复使用 可以通过class属性来为元素分组 --\u003e \u003cp class=\"red\"\u003e秋水共长天一色\u003c/p\u003e \u003cp\u003e落霞与孤鹜齐飞\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* 将class为red的元素设置为红色(字体) */ .red{ color: red; } /* 将class为red的div字体大小设置为30px */ /* 交集选择器 作用:选中同时符合多个条件的元素 语法:选择器1选择器2选择器3...{} 注意点:交集选择器中如果有元素选择器,必须使用元素选择器开头 */ /* 比如下面就是 元素选择器+类选择器 */ /* 与的关系\u0026 */ div.red{ font-size: 30px; } /* 选择器分组(并集选择器) 作用:同时选择多个选择器对应的元素 语法:选择器1,选择器2...{} */ /* 或的关系|| */ h1,span{ color: blue; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"red\"\u003e我的div\u003c/div\u003e \u003cp class=\"red\"\u003e我是p\u003c/p\u003e \u003ch1 \u003e标题\u003c/h1\u003e \u003cspan \u003e哈哈\u003c/span\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/:1:0","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"关系选择器 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* 为div的子元素span设置一个字体颜色红色 (为div直接包含的span设置一个字体颜色) 子元素选择器 作用: 选中指定父元素的指定子元素 语法: 父元素 \u003e 子元素 */ /* div.box \u003e span { color: red; } */ /* 后代元素选择器: 作用: 选中指定元素内的指定后代元素 语法: 祖先 后代 */ /* div span { color: blue; } */ /* div \u003e p \u003e span { color: orange; } */ /* 选中下一个兄弟 语法: 前一个 + 后一个 (要紧挨着) 选中下边所有的兄弟 语法: 兄 ~ 弟 */ p + span { color: aqua; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 父元素 - 直接包含子元素的元素叫做父元素 子元素 - 直接被父元素包含的元素叫子元素 祖先元素 - 直接或间接包含后代元素的元素叫祖先元素 - 一个元素的父元素也是它的祖先元素 后代元素 - 直接或者间接被祖先元素包含的元素叫做后代元素 - 子元素也是后代元素 兄弟元素 - 拥有相同父元素的元素是兄弟元素 --\u003e \u003cdiv class=\"box\"\u003e我是一个div \u003cp\u003e我的div中的p \u003cspan\u003e 我是p中的span \u003c/span\u003e \u003c/p\u003e \u003cspan\u003e我的div中的span\u003c/span\u003e \u003c/div\u003e \u003cspan\u003e 我是div外的span1 \u003c/span\u003e \u003cp\u003e 我是div外的p \u003c/p\u003e \u003cspan\u003e 我是div外的span2 \u003c/span\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/:2:0","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"属性选择器 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* [属性名] 选择含有指定属性的元素 [属性名=属性值] 选择含有指定属性和属性值的元素 [属性名^=属性值] 选择属性值以指定值开头的元素 [属性名$=属性值] 选择属性值以指定值结尾的元素 [属性名*=属性值] 选择属性值中含有某值的元素 */ /* p[title=abc] { color: orange; } */ /* p[title^=abc]{ color: red; } */ /* p[title$=abc]{ color: orange; } */ p[title*=e]{ color: aqua; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cp title=\"abc\"\u003e少小离家老大回\u003c/p\u003e \u003cp title=\"abcd\"\u003e乡音无改鬓毛衰\u003c/p\u003e \u003cp title=\"adsiaje\"\u003e儿童相见不相识\u003c/p\u003e \u003cp\u003e笑问客从何处来\u003c/p\u003e \u003cp\u003e秋水共长天一色\u003c/p\u003e \u003cp\u003e落霞与孤鹜齐飞\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/:3:0","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"伪类选择器 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e p{ font-size: 20px; } /* 伪元素,表示页面中一些特殊的并不真实的存在的元素(特殊的位置) 伪元素使用 :: 开头 ::first-letter 表示第一个字母 ::first-line 表示第一行 ::selection 表示选中的内容 ::before 表示元素的起始 ::after 表示元素的结束 -before atfer 必须结合content属性来使用 */ p::first-letter { font-size: 50px; } p::first-line { background-color: blue; } p::selection { background-color: yellow; } div::before { content: \"abc\"; color: red; } div::after { content: \"haha\"; color: greenyellow; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cq\u003e hello \u003c/q\u003e \u003cp\u003e 这是一个p标签 \u003c/p\u003e \u003cdiv\u003ehello hello hello\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/:4:0","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"伪元素选择器 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e p{ font-size: 20px; } /* 伪元素,表示页面中一些特殊的并不真实的存在的元素(特殊的位置) 伪元素使用 :: 开头 ::first-letter 表示第一个字母 ::first-line 表示第一行 ::selection 表示选中的内容 ::before 表示元素的起始 ::after 表示元素的结束 -before atfer 必须结合content属性来使用 */ p::first-letter { font-size: 50px; } p::first-line { background-color: blue; } p::selection { background-color: yellow; } div::before { content: \"abc\"; color: red; } div::after { content: \"haha\"; color: greenyellow; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cq\u003e hello \u003c/q\u003e \u003cp\u003e 这是一个p标签 \u003c/p\u003e \u003cdiv\u003ehello hello hello\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E9%80%89%E6%8B%A9%E5%99%A8/:5:0","tags":["HTML"],"title":"Web学习笔记 - 选择器","uri":"/%E9%80%89%E6%8B%A9%E5%99%A8/"},{"categories":["前端"],"content":"css用来设置网页中元素的样式","date":"2022-12-04","objectID":"/css%E7%AE%80%E4%BB%8B/","tags":["HTML"],"title":"Web学习笔记 - CSS简介","uri":"/css%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"简介 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c!-- 第二种方式(内部样式表) - 将样式编写到head中的style标签里 然后通过css的选择器来选中元素并为其设置各种样式 可以同时为多个标签设置样式,并且修改时只需修改一处即可全部应用 - 内部样式表更加方便对样式进行复用 - 问题: 我们的内部样式只能对一个网页起作用 它里面的样式不能跨页面复用 --\u003e \u003c!-- \u003cstyle\u003e /* 所有的p元素 */ p{color: red; font-size: 30px;} \u003c/style\u003e --\u003e \u003c!-- 第三种方式(外部样式表) - 可以将CSS样式编写到一个外部的CSS文件中 然后通过link标签来引入外部的css文件 - 外部样式需要通过link标签进行引入 意味着只要想使用这些样式的网页都可以对其使用,使样式可以再不同页面之间进行复用 - 将样式编写到外部的css文件中,可以使用到浏览器的缓存机制 从而加快的网页的加载速度,提高用户的体验 --\u003e \u003clink rel=\"stylesheet\" href=\"./style.css\"\u003e \u003c!-- p{ color: red; font-size: 30px; } --\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 网页分成三个部分: 结构(html) 表现(css) 行为(JavaScript) CSS - 层叠样式表 - 网页实际上是一个多层的结构,通过css可以分别为网页的每一个层来设置样式 而最终我们能看到的至少网页的最上边一层 - 总之一句话,css用来设置网页中元素的样式 --\u003e \u003c!-- 使用css来修改元素的样式 第一种方式(内联样式,或者叫行内样式) - 在标签内部通过style属性来设置元素的样式 - 问题: 使用内联样式,样式只能对一个标签生效 如果希望影响到多个元素必须每个元素复制一遍 并且当样式发送变化时,我们必须一个一个修改 - 注意: 开发时绝对不要使用内联样式 --\u003e \u003c!-- \u003cp style=\"color: red; font-size: 30px;\"\u003e少小离家老大回,乡音无改鬓毛衰\u003c/p\u003e \u003cp style=\"color: red; font-size: 30px;\"\u003e今天天气真不错\u003c/p\u003e --\u003e \u003cp\u003e少小离家老大回,乡音无改鬓毛衰\u003c/p\u003e \u003cp\u003e今天天气真不错\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/css%E7%AE%80%E4%BB%8B/:1:0","tags":["HTML"],"title":"Web学习笔记 - CSS简介","uri":"/css%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"语法 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cstyle\u003e /* CSS中的注释,注释中内容会自动被浏览器忽略 CSS的基本语法: 选择器 声明块 选择器,通过选择器可以选中页面中的指定元素 比如 p 的作用就是选中页面中所有的 p 元素 声明块,通过声明块来指定要为元素设置的样式 声明块由一个一个的声明组成 声明是一个名值对结构 一个样式名对应一个样式值,名和值之间以`:`链接,以`;`结尾 */ p{ color: red; font-size: 30px; } h1{ color: blue; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e我是h1\u003c/h1\u003e \u003cp\u003e今天天气真不错\u003c/p\u003e \u003cp\u003e今天天气真不错\u003c/p\u003e \u003cp\u003e今天天气真不错\u003c/p\u003e \u003cp\u003e今天天气真不错\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/css%E7%AE%80%E4%BB%8B/:2:0","tags":["HTML"],"title":"Web学习笔记 - CSS简介","uri":"/css%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"内联框架,用于向当前页面中引入一个其他页面","date":"2022-12-04","objectID":"/%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6/","tags":["HTML"],"title":"Web学习笔记 - 内联框架","uri":"/%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 内联框架,用于向当前页面中引入一个其他页面 src 指定网页的路径 frameborder 指定内联框架的边框 --\u003e \u003ciframe src=\"https://www.bilibili.com\" width=\"800\" height=\"600\" frameborder=\"0\"\u003e\u003c/iframe\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6/:0:0","tags":["HTML"],"title":"Web学习笔记 - 内联框架","uri":"/%E5%86%85%E8%81%94%E6%A1%86%E6%9E%B6/"},{"categories":["前端"],"content":"图片标签用于向当前页面中引入一个外部图片","date":"2022-12-04","objectID":"/%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE/","tags":["HTML"],"title":"Web学习笔记 - 图片标签","uri":"/%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 图片标签用于向当前页面中引入一个外部图片 使用img标签来引入外部图片,img标签是一个自结束标签 img这种元素用于替换元素(基于块和行内元素之间,具有两种元素的特点) 属性: scr 属性指定的是外部图片的路径(路径规则和超链接是一样的) alt 属性是图片的描述,这个描述默认情况下不会显示,有些浏览器无法加载时显示 搜索引擎会根据alt中的内容来识别图片,如果不写alt属性,则图片不会被搜索引擎收录 width 宽度(单位是像素) height 高度 - 如果宽度和高度中只修改了一个,另一个会等比例缩放 注意: 一般情况在pc端,不建议修改图片的大小 但是在移动端,经常需要对图片进行缩放(主要大图缩小) 图片的格式: jpeg(jpg) - 支持的颜色比较丰富,不支持透明效果,不支持动图 - 一般用来显示照片 gif - 支持的颜色比较少,支持简单透明,支持动图 - 适合颜色单一的图片,动图 png - 支持的颜色丰富,支持复杂透明,不支持动图 - 颜色丰富,复杂透明图片(专为网页而生) webp - 这种格式是谷歌新推出的专门用来表示网页中的图片格式 - 它具备其他图片格式所有的优点,而且文件大小特别小 - 缺点,兼容性不好 base64 (不是图片格式) - 将图片使用base64进行编码,这样可以将图片转换为字符,通过字符的形式来引入图片 - 一般都是一些和网页一起加载的图片才会使用base64 效果一样,用小的 效果不一样,用效果好的 --\u003e \u003cimg src=\"./下载.jpeg\" alt=\"京东\"\u003e \u003cbr\u003e \u003cimg src=\"https://img95.699pic.com/photo/50136/1351.jpg_wh300.jpg\" alt=\"美女\"\u003e \u003cbr\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE/:0:0","tags":["HTML"],"title":"Web学习笔记 - 图片标签","uri":"/%E5%9B%BE%E7%89%87%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"当我们需要跳转一个服务器内部的页面时,一般我们都会使用相对路径","date":"2022-12-04","objectID":"/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/","tags":["HTML"],"title":"Web学习笔记 - 相对路径","uri":"/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 当我们需要跳转一个服务器内部的页面时,一般我们都会使用相对路径 相对路径都会使用.或者..开头 ./ 表示当前文件所在的目录 ../ 表示当前文件所在目录的上一级 ./可以省略不写, 如果不写./也不写../则就相当于写./ --\u003e \u003ca href=\"../7列表.html\"\u003e内部相对路径跳转\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-04","objectID":"/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/:0:0","tags":["HTML"],"title":"Web学习笔记 - 相对路径","uri":"/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"},{"categories":["前端"],"content":"超链接可以让我们从一个页面跳转到其他页面.","date":"2022-12-03","objectID":"/%E8%B6%85%E9%93%BE%E6%8E%A5/","tags":["HTML"],"title":"Web学习笔记 - 超链接","uri":"/%E8%B6%85%E9%93%BE%E6%8E%A5/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 超链接可以让我们从一个页面跳转到其他页面, 或者是当前页面的其他位置 使用 a 标签来定义超链接 属性: href 指定跳转的目标路径 - 值可以是一个外部网站的地址 - 值也可以是一个内部网站的地址 超链接也是一个行内元素,在 a 标签中可以嵌套除它自身外任何元素 --\u003e \u003ca href=\"https://www.baidu.com\"\u003e百度\u003c/a\u003e \u003cbr\u003e \u003ca href=\"https://www.baidu.com\"\u003e百度\u003c/a\u003e \u003cbr\u003e \u003ca href=\"7列表.html\"\u003e内部页面\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- target 属性, 用来指定超链接打开的位置 可选值: _self 默认值,当前页中打开超链接 _blank 在一个新的页面中打开超链接 --\u003e \u003ca href=\"https://www.baidu.com\" target=\"_blank\"\u003e打开百度\u003c/a\u003e \u003cbr\u003e \u003c!-- 在开发中可以将#作为超链接路径的占位符使用 --\u003e \u003ca href=\"#\"\u003e这是一个新的超链接\u003c/a\u003e \u003cbr\u003e \u003c!-- 可以使用JavaScript:; 来作为href属性,此时点击这个超链接什么也不会发生 --\u003e \u003ca href=\"javascript:;\"\u003e这是一个新的超链接\u003c/a\u003e \u003cbr\u003e \u003ca href=\"bottom\"\u003e去底部\u003c/a\u003e \u003c!-- 可以直接将超链接的href属性设置为#,这样点击超链接后, 页面不会发送跳转,而是转到当前页面的顶部的位置 可以调整到页面的指定位置,只需讲href属性设置 #目标元素的id id属性(唯一不重复的) - 每一个标签都可以添加一个id属性 - id属性就是元素的唯一标识,同一个页面中不能出现重复的id属性; --\u003e \u003ca id=\"bottom\" href=\"#\"\u003e回到顶部\u003c/a\u003e \u003cbr\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-03","objectID":"/%E8%B6%85%E9%93%BE%E6%8E%A5/:0:0","tags":["HTML"],"title":"Web学习笔记 - 超链接","uri":"/%E8%B6%85%E9%93%BE%E6%8E%A5/"},{"categories":["前端"],"content":"HTML中的有序列表和无序列表","date":"2022-12-02","objectID":"/%E5%88%97%E8%A1%A8/","tags":["HTML"],"title":"Web学习笔记 - 列表","uri":"/%E5%88%97%E8%A1%A8/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 列表(list) 1. 铅笔 2. 尺子 3. 橡皮 在html中也可以创建列表,html列表一共有三种 1. 有序列表 2. 无序列表 3. 定义列表 有序列表,使用ol标签来创建有序列表 使用li表示列表项 无序列表,使用ul标签来创建无序列表 使用li表示列表项 定义列表,使用dl标签来创建一个定义列表 使用dt来表示定义的内容 使用dd来对内容进行解释说明 列表之间可以互相嵌套 --\u003e \u003cul\u003e \u003cli\u003e\u003c/li\u003e \u003c/ul\u003e \u003col\u003e \u003cli\u003e\u003c/li\u003e \u003c/ol\u003e \u003cdl\u003e \u003cdt\u003e结构\u003c/dt\u003e \u003cdd\u003e结构表示网页的结构,结构用来规定网页中哪里是标题,哪里是段落\u003c/dd\u003e \u003c/dl\u003e \u003cul\u003e \u003cli\u003e aa \u003cul\u003e \u003cli\u003eaa-1\u003c/li\u003e \u003cli\u003eaa-2\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003c/ul\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-02","objectID":"/%E5%88%97%E8%A1%A8/:0:0","tags":["HTML"],"title":"Web学习笔记 - 列表","uri":"/%E5%88%97%E8%A1%A8/"},{"categories":["文档"],"content":"Hugo 文章通用配置,gitalk评论设置","date":"2022-12-02","objectID":"/hugo/","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"文章目录 # 目录设置 [markup.tableOfContents] startLevel = 2 # 代表从第几级标题开始生成目录 endLevel = 6 # 代表从第几级标题结束目录 ordered = true # 目录排序 ","date":"2022-12-02","objectID":"/hugo/:1:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"文章通用配置 打开archetypes/default.md文件进行编辑: --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} draft: false categories: [\"Web\"] tags: [\"HTML\"] keywords: [\"HTML\"] --- ","date":"2022-12-02","objectID":"/hugo/:2:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"常用指令 hugo new posts 文章.md # 发布文章 hugo # 编译 hugo server -D # 启动本地服务 ","date":"2022-12-02","objectID":"/hugo/:3:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"loveit主题相关 代码块识别语言高亮,配置文件路径: /themes/LoveIt/assets/css/_variables.scss ","date":"2022-12-02","objectID":"/hugo/:4:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"链接 链接 - 普通链接 {{\u003c link \"https://andy90s.github.io/\" \u003e}} 或者 {{\u003c link href=\"https://andy90s.github.io/\" content=\"https://andy90s.github.io/\" \u003e}} {{\u003c link \"mailto:contact@qq.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@qq.com\" content=\"mailto:contact@qq.com\" \u003e}} {{\u003c link \"https://andy90s.github.io/\" Andy90s \u003e}} 或者 {{\u003c link href=\"https://andy90s.github.io/\" content=Andy90s \u003e}} \u003c!-- 停留带标题 --\u003e {{\u003c link \"https://andy90s.github.io/\" Andy90s \"Visit Andy90s!\" \u003e}} 或者 {{\u003c link href=\"https://andy90s.github.io/\" content=Andy90s title=\"Visit Andy90s!\" \u003e}} 效果如下: https://andy90s.github.io/ 或者 https://andy90s.github.io/ mailto:contact@qq.com 或者 mailto:contact@qq.com Andy90s 或者 Andy90s Andy90s 或者 Andy90s 链接 - 内部跳转链接 \u003c!-- ref绝对路径 relref相对路径 --\u003e {{\u003c ref \"path/to/document.md#锚点\" \u003e}} {{\u003c relref \"path/to/document.md#锚点\" \u003e}} 例如跳转到本文的文章目录锚点: [跳转到其他文章锚点]({{\u003c relref \"其他文章.md#文章目录\" \u003e}}) [跳转到文章目录]({{\u003c relref \"../other/hugo常见问题.md#文章目录\" \u003e}}) 效果: 跳转到文章目录 ","date":"2022-12-02","objectID":"/hugo/:4:1","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"gitalk评论设置 ","date":"2022-12-02","objectID":"/hugo/:5:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"github生成application auth 生成方法:打开github设置 - develop setting - OAuth Apps - 选择新建 新建OAuth ","date":"2022-12-02","objectID":"/hugo/:5:1","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"得到秘钥,粘贴到配置中 [params.page.comment.gitalk] enable = true owner = \"andy90s\" repo = \"andy90s.github.io\" clientId = \"上面拿到的id\" clientSecret = \"上面生成的秘钥\" id = \"location.pathname\" 注意 上述评论配置为(hugo+loveit主题),其他配置差别不大,注意repo应填写仓库名即可 id按照上述配置,会自动生成issue ","date":"2022-12-02","objectID":"/hugo/:5:2","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"图片资源 由于我的图片是直接存放到github仓库中的,所以需要配置下CDN来加速访问,上传我使用的是picgo工具,配置如下: picgo设置 https://cdn.jsdelivr.net/gh/ + 你的github用户名 + 你的仓库名 + 图片路径 例如: https://cdn.jsdelivr.net/gh/andy90s/blog-image/blog/images/271669958429_.pic.jpg 技巧 gh = github 指定master分支: https://cdn.jsdelivr.net/gh/andy90s/blog-image@master/blog/images/271669958429_.pic.jpg 还可以指定版本号: https://cdn.jsdelivr.net/gh/andy90s/blog-image@版本号/blog/images/271669958429_.pic.jpg 压缩资源: https://cdn.jsdelivr.net/gh/andy90s/blog-image@版本号/blog/images/271669958429_.pic?x-oss-process=image/resize,m_lfit,h_100,w_100 ","date":"2022-12-02","objectID":"/hugo/:6:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["文档"],"content":"参考 主题文档 - 扩展 Shortcodes ","date":"2022-12-02","objectID":"/hugo/:7:0","tags":["hugo"],"title":"Hugo常见问题","uri":"/hugo/"},{"categories":["前端"],"content":"在使用html标签时,应该关注的是标签的语义,而不是样式.","date":"2022-12-01","objectID":"/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/","tags":["HTML"],"title":"Web学习笔记 - 语义化标签","uri":"/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 在网页中HTML专门用来负责网页的结构 所以在使用html标签时,应该关注的是标签的语义,而不是样式 标题标签: h1~h6 一共六级标题 从h1~h6重要性递减,h1最重要,h6最不重要 h1在网页中的重要性仅次于title标签,一般情况下一个页面只会有一个h1 一般情况下标题标签只会使用到h1~h3,h4~h6很少用 标题标签都是块元素 块元素,在页面中独占一行的元素(block element) --\u003e \u003ch1\u003e一级标题\u003c/h1\u003e \u003ch2\u003e二级标题\u003c/h2\u003e \u003ch3\u003e三级标题\u003c/h3\u003e \u003ch4\u003e丝级标题\u003c/h4\u003e \u003ch5\u003e五级标题\u003c/h5\u003e \u003ch6\u003e六级标题\u003c/h6\u003e \u003c!-- hgroup 标签用来标题分组,可以将一组相关的标题同时放入hgroup --\u003e \u003chgroup\u003e \u003ch1\u003e大标题\u003c/h1\u003e \u003ch2\u003e小标题\u003c/h2\u003e \u003c/hgroup\u003e \u003c!-- p标签表示页面汇总的一个段落; p也是一个块元素 --\u003e \u003cp\u003e段落1\u003c/p\u003e \u003cp\u003e段落2\u003c/p\u003e \u003c!-- em标签用于表示语音语调的一个加重 在页面中不会独占一行的元素成为行内元素(inline element) --\u003e \u003cp\u003e今天天气\u003cem\u003e真\u003c/em\u003e不错!\u003c/p\u003e \u003c!-- strong 表示强调,重要的内容 --\u003e \u003cp\u003e你今天必须要\u003cstrong\u003e完成作业!\u003c/strong\u003e\u003c/p\u003e 鲁迅说, \u003c!-- blockquote 表示一个引用 --\u003e \u003cblockquote\u003e这句话我是从来没有说过\u003c/blockquote\u003e \u003c!-- q 表示一个短引用 --\u003e 子曰\u003cq\u003e学而时学志,乐呵乐呵!\u003c/q\u003e \u003c!-- br 表示换行 --\u003e \u003cbr\u003e \u003cbr\u003e 今天天气真不错 \u003c/body\u003e \u003c/html\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 块元素(block element) - 在网页中一般通过块元素对页面进行布局 行内元素(inline element) - 行内元素主要用来包裹文字 - 一般情况下会在块元素中放行内元素,而不会在行内元素中放块元素 - 块元素中基本什么都能放 - p元素中不能放任何的块元素 浏览器在解析网页时,会自动对网页中不符合规范的内容进行修整 比如: 标签写在了根元素的外部 p元素中嵌套了块元素 根元素中出现了除head和body以外的子元素 --\u003e \u003c/body\u003e \u003c/html\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- header 表示网页的头部 main 表示网页的主体部分(一个网页中只会有一个main) footer 表示网页的底部 nav 表示网页的导航 aside 表示主体相关的其他内容(侧边栏) article 文章 section 表示一个独立的区块,上边的标签都不能表示时使用section div 没有语义,就是表示一个区块 span 行内元素,没有语义,一般用于在网页中选中文字 --\u003e \u003cheader\u003e\u003c/header\u003e \u003cmain\u003e\u003c/main\u003e \u003cfooter\u003e\u003c/footer\u003e \u003cnav\u003e\u003c/nav\u003e \u003caside\u003e\u003c/aside\u003e \u003carticle\u003e\u003c/article\u003e \u003csection\u003e\u003c/section\u003e \u003cdiv\u003e\u003c/div\u003e \u003cspan\u003e\u003c/span\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-01","objectID":"/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/:0:0","tags":["HTML"],"title":"Web学习笔记 - 语义化标签","uri":"/%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"主要用于设置网页中的一些元数据,元数据不是给用户看","date":"2022-12-01","objectID":"/meta%E6%A0%87%E7%AD%BE/","tags":["HTML"],"title":"Web学习笔记 - Meta标签","uri":"/meta%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":" \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c!-- meta主要用于设置网页中的一些元数据,元数据不是给用户看 charset 指定网页的字符集 name 指定的数据的名称 content 指定的数据的内容 keywords 表示网站的关键字,可以同时指定多个关键字,关键字之间使用`,`隔开 \u003cmeta name=\"keywords\" content=\"网上购物,网上商城,手机\"\u003e \u003cmeta name=\"keywords\" content=\"网上购物,网上商城,手机\"\u003e --\u003e \u003cmeta name=\"keywords\" content=\"html5,前端,CSS3\"\u003e \u003cmeta name=\"description\" content=\"这是一个非常不错的网站\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-01","objectID":"/meta%E6%A0%87%E7%AD%BE/:0:0","tags":["HTML"],"title":"Web学习笔记 - Meta标签","uri":"/meta%E6%A0%87%E7%AD%BE/"},{"categories":["前端"],"content":"在网页中书写这些特殊字符,则需要使用html中的实体(转义字符)","date":"2022-12-01","objectID":"/%E5%AE%9E%E4%BD%93/","tags":["HTML"],"title":"Web学习笔记 - 实体","uri":"/%E5%AE%9E%E4%BD%93/"},{"categories":["前端"],"content":"实体 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e实体\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 在网页中编写的多个空格默认情况会自动被浏览器解析为一个空格 在HTML中有些时候,我们不能直接书写一些特殊符号 比如,多个连续的空格,比如字母两侧的大于和小于号. 如果我们需要在网页中书写这些特殊字符,则需要使用html中的实体(转义字符) 实体的语法: \u0026实体的名字; 空格: \u0026nbsp; --\u003e \u003cp\u003e '今天\u0026nbsp;天气真不错' \u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-01","objectID":"/%E5%AE%9E%E4%BD%93/:1:0","tags":["HTML"],"title":"Web学习笔记 - 实体","uri":"/%E5%AE%9E%E4%BD%93/"},{"categories":["前端"],"content":"HTML用于描述页面的结构","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"软件 应用软件C/S架构;C: Client /S: Server 网页端的软件B/S架构; B: Browser ","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/:1:0","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"结构,表现,行为 结构 HTML用于描述页面的结构 表现 CSS用于控制页面中元素的样式 行为 JavaScript用于响应用户操作 ","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/:2:0","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"HTML \u003chtml\u003e\u003c/html\u003e根标签(元素),网页中的所有内容都要写在根元素里边; \u003chead\u003e\u003c/head\u003e头; 不会出现在内容中;主要用来帮助浏览器或搜索引擎来解析网页; \u003cbody\u003e\u003c/body\u003e体; \u003c!-- 文档声明HTML5的规范; --\u003e \u003c!DOCTYPE html\u003e \u003c!-- 告诉浏览器语言(提示是否翻译此页) --\u003e \u003chtml lang=\"en\"\u003e \u003c!-- 根标签(元素),网页中的所有内容都要写根元素里面 --\u003e \u003chtml\u003e \u003c!-- head是网页的头部,head中的内容不会在网页中出现,主要用来帮助浏览器或者搜索引擎来解析网页 --\u003e \u003chead\u003e \u003c!-- meta标签用来设置网页的元数据,这里可以通过meta标签设置网页的字符集,避免乱码问题 --\u003e \u003cmeta charset=\"utf-8\"\u003e \u003c!-- title中的内容会显示在浏览器的标题栏,搜索引擎会主要根据title中的内容来判断网页的主要内容,不会出现在内容中 --\u003e \u003ctitle\u003e网页的基本结构\u003c/title\u003e \u003c/head\u003e \u003c!-- body是html的子元素,表示网页的主体,网页中所有的可见内容都应该写在body里面 --\u003e \u003cbody\u003e \u003c!-- h1网页的一级标题 --\u003e \u003ch1\u003e网页的大标题\u003c/h1\u003e \u003c!-- 大标题,属性问题,空格隔开;--\u003e \u003ch1\u003e这是我的\u003cfont color=\"red\" size=\"18\"\u003e第三个\u003c/font\u003e网页\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/:3:0","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"进制: 十进制(日常使用) 特点:满10进1 计数:0 1 2 3 4 5 6 7 8 9 单位数字:10个(0~9) 二进制(计算机底层的进制) 特点:满2进1 计数:0 1 10 11 100 101 110… 单位数字:2个(0,1) 扩展: 所有的数据在计算机底层都会以二进制的形式保存 可以将内存想象为一个有多个小格子组成的容器,每一个格子中可以存储一个1或者一个0 这一个小格子在内存中被称为1位(bit) 8bit = 1byte(字节) 1024byte = 1kb(千字节) 1024kb = 1mb(兆字节) 1024mb = 1gb(吉字节) 1024gb = 1tb(特字节) 1024tb = 1pb 八进制(很少用) 特点:满8进1 计数:0 1 2 3 4 5 6 7 10 … 单位数字:8个(0~7) 十六进制(一般显示一个二进制数字时,都会转换为十六进制) 特点:满16进1 计数:0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 … 1a 1b 1c 1d 1e 1f 20… 单位数字:16个(0~f) ","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/:4:0","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["前端"],"content":"字符编码 李立超 -\u003e 1100 0011 (编码) 1100 0011 -\u003e 李立超 (解码) 所有的数据在计算机中存储时都是以二进制形式存储的,文字也不例外,所以一段文字在存储到内存中时,都需要转换为二进制编码,当我们读取这段文字时,计算机会将编码转换为字符,供我们阅读 编码 将字符转换为二进制码的过程称为编码 解码 将二进制码转换为字符的过程称为解码 字符集 编码和解码所采用的规则称为字符集 乱码 如果编码和解码采用的字符集不同,就会产生乱码 常见的字符集: ASCII 美国 ISO88591 欧洲扩充 GB2312 国标,中国扩充 GBK UTF-8 万国码,在开发时我们使用的字符集都是UTF-8 ","date":"2022-12-01","objectID":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/:5:0","tags":["HTML"],"title":"Web学习笔记 - HTML相关简介","uri":"/html%E7%9B%B8%E5%85%B3%E7%AE%80%E4%BB%8B/"},{"categories":["文档"],"content":"提交信息由 `Header`+`Body`+`Footer`组成","date":"2022-12-01","objectID":"/git-submit/","tags":["git"],"title":"代码提交规范","uri":"/git-submit/"},{"categories":["文档"],"content":"代码提交记录示例 feat(home): add a homepage feat(首页): 添加一个首页 ","date":"2022-12-01","objectID":"/git-submit/:1:0","tags":["git"],"title":"代码提交规范","uri":"/git-submit/"},{"categories":["文档"],"content":"格式说明 提交信息由 Header+Body+Footer组成 Header:feat: 本次提交类型描述 Body:(home): 功能模块,自己分类 Footer:add a homepage: 具体描述 ","date":"2022-12-01","objectID":"/git-submit/:2:0","tags":["git"],"title":"代码提交规范","uri":"/git-submit/"},{"categories":["文档"],"content":"提交类型说明 type 说明 feat 新增feature fix 修复bug docs 文档修改,比如readme文件 perf 优化 style 修改了代码格式,不修改逻辑,比如删除多余的空格和空行 refactor 代码重构,没有新增功能,也没有修复bug test 测试用例,包含单元测试和集成测试 ci 修改ci配置文件或者脚本,比如jenkins fastlane chore 修改构建脚本,或者增加依赖库,工具等 revert 回滚之前的commit ","date":"2022-12-01","objectID":"/git-submit/:3:0","tags":["git"],"title":"代码提交规范","uri":"/git-submit/"},{"categories":["文档"],"content":"常用markdown语法(hugo+loveit主题)","date":"2022-11-30","objectID":"/markdown/","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"前言 本文大部分是在hugo+loveit主题两者基础上才有作用,具体参考loveit主题shortcode文档 ","date":"2022-11-30","objectID":"/markdown/:1:0","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"代码块 ","date":"2022-11-30","objectID":"/markdown/:2:0","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"TOML baseURL = \"http://example.org/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true ","date":"2022-11-30","objectID":"/markdown/:2:1","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"bash git clone https://github.com/dillonzq/LoveIt.git themes/LoveI ","date":"2022-11-30","objectID":"/markdown/:2:2","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"css @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; ","date":"2022-11-30","objectID":"/markdown/:2:3","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"admonition 注意 注意 admonition note admonition note admonition tip admonition tip 【更多admonition参考】 ","date":"2022-11-30","objectID":"/markdown/:3:0","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"版本 ","date":"2022-11-30","objectID":"/markdown/:4:0","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"图片 ","date":"2022-11-30","objectID":"/markdown/:5:0","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"默认 ![](/images/fengmian4.jpg) ","date":"2022-11-30","objectID":"/markdown/:5:1","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"控制大小和位置(1) \u003cp align=\"center\"\u003e \u003cimg src=\"/images/fengmian4.jpg\" width=\"200\" /\u003e \u003c/p\u003e \u003ccenter\u003e图示\u003c/center\u003e 图示 ","date":"2022-11-30","objectID":"/markdown/:5:2","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"控制大小和位置(2) \u003ccenter\u003e \u003cimg width=\"300\" src=\"/images/fengmian4.jpg\"\u003e \u003cdiv style=\"color:black;\"\u003e \u003cb\u003e 图示 \u003c/b\u003e \u003c/div\u003e \u003c/center\u003e 图示 ","date":"2022-11-30","objectID":"/markdown/:5:3","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"控制大小和位置(3) \u003ccenter\u003e {{\u003c image src=\"/images/fengmian4.jpg\" title=\"停留显示\"width=\"50%\" \u003e}} \u003cdiv style=\"color:black;\"\u003e \u003cb\u003e 图示 \u003c/b\u003e \u003c/div\u003e \u003c/center\u003e 技巧 1.此shortcode需loveit主题支持 2.这种方式显示的图片配合loveit主题可以点击放大,停留显示文案等 图示 Bug 主题应该是有bug, 当设置caption图片标题, 会造成width属性失效,所以这里加div标签达到效果 ","date":"2022-11-30","objectID":"/markdown/:5:4","tags":["hugo"],"title":"常用markdown语法(hugo)","uri":"/markdown/"},{"categories":["文档"],"content":"git github问题记录","date":"2022-11-30","objectID":"/git/","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"生成ssh-key,对应不同平台 ","date":"2022-11-30","objectID":"/git/:1:0","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"1. 利用ssh生成秘钥(这里以github平台为例) ssh-keygen -t rsa -C \"youremail@xxx.com\" -f ~/.ssh/id_rsa 注意 id_rsa是文件名,可自己修改,大部分默认名为id_rsa 如果想要多个平台分开不同秘钥,再次执行上面指令,文件名替换其他,例:gitlab_id_rsa ","date":"2022-11-30","objectID":"/git/:1:1","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"2. 添加私钥 ssh-add ~/.ssh/id_rsa ","date":"2022-11-30","objectID":"/git/:1:2","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"3. 查看公钥内容并复制到对应的git平台的ssh keys设置中 cat ~/.ssh/id_rsa.pub ","date":"2022-11-30","objectID":"/git/:1:3","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"4. 测试链接 ssh -T git@github.com ","date":"2022-11-30","objectID":"/git/:1:4","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"gitignore忽略文件不生效 1.准备工作: 删除pods文件,然后提交代码 2.缓存导致不生效,按如下解决: git rm -r --cached . git add . git commit -m 'update gitignore' ","date":"2022-11-30","objectID":"/git/:2:0","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"},{"categories":["文档"],"content":"github提示账号密码不对 仓库是https拉取,终端提示输入账号密码,怎么输入都不对? 这是因为github不再支持原密码登录,替换为token登录. 解决办法 打开github设置(settings) -\u003e Developer settings -\u003e Personal access tokens -\u003e Tokens 选择新建一个如下图所示,得到一个token字符串,登录的时候密码使用此token替换原来的密码进行登录 设置github token ","date":"2022-11-30","objectID":"/git/:3:0","tags":["git"],"title":"Git常见问题汇总","uri":"/git/"}]